/* This file created by JSCacher. Last modified: Wed Jan 23 18:44:32 EST 2019 */
function Bubblelines(config) {
	this.container = config.container;
	this.externalClickHandler = config.clickHandler;
	
	this.INTERVAL = 50; // milliseconds between each redraw
	this.DISMISS_DELAY = 2500; // milliseconds before tooltip auto hides
	this.UNIFORM_LINE_LENGTH = true; // should all document lines be the same length?
	this.SEPARATE_LINES_FOR_TERMS = false; // draw a separate line for each term?
	
	// these 2 get set in the code
	this.MAX_LABEL_WIDTH = 0;
	this.MAX_LINE_WIDTH = 0;
	
	this.DRAW_TITLES = true; // where to draw the document titles for each graph; gets set to false if the corpus has only 1 document
	this.DRAW_SHORT_TITLES = false; // whether to use the docIndex for the title or not; gets set to true if the window is small enough
	
	this.MIN_GRAPH_SEPARATION = 50; // vertical separation between graphs
	this.graphSeparation = 50;
	
	this.yIndex = 0; // for tracking yIndex during the drawing process
	
	this.mouseOver = false; // is the mouse over the canvas
	this.intervalId = null;
	this.clearToolTipId = null;
	this.overBubbles = [];
	this.lastClickedBubbles = {};
	this.dragInfo = null;
	this.canvas = null;
	this.ctx = null;
	this.maxDocLength = 2;
	this.maxFreq = {term: null, value: 0};
	this.maxRadius = 0;
	
	/**
	 * The cache of docs. Each has the following properties:
	 * @param {String} id
	 * @param {String} title
	 * @param {Integer} index
	 * @param {Integer} totalTokens
	 * @param {Object} terms Stores the terms for this doc
	 * @param {Object} freqCounts Used for tool tip display
	 * @param {Float} height The height of the graph for this doc
	 * @param {Float} titleWidth The width of the title
	 * @param {Float} lineLength The length of the graph line for this doc
	 */
	this.cache = new Ext.util.MixedCollection();
	
	this.currentTerms = {}; // tracks what terms we're currently showing
	this.termsFilter = []; // tracks the subset of terms
	this.bubbleSpacing = 50;

	this.initialized = false;
}

Bubblelines.prototype = {
	constructor: Bubblelines,
	
	initializeCanvas: function() {
		var container = this.container;
		var height = container.getHeight();
		var width = container.getWidth();
		this.DRAW_SHORT_TITLES = width < 500;
		var id = Ext.id('bubblelines');
		container.add({
			xtype: 'container',
			width: width,
			height: height,
			html: '<canvas id="'+id+'" width="'+width+'" height="'+height+'"></canvas>',
			border: false,
        	listeners: {
        		afterrender: {
        			fn: function(cnt) {
    					this.canvas = document.getElementById(id);
        				this.ctx = this.canvas.getContext('2d');
        				this.canvas.addEventListener('click', this.clickHandler.bind(this), false);
        				this.canvas.addEventListener('mousedown', this.mouseDownHandler.bind(this), false);
        				this.canvas.addEventListener('mouseup', this.mouseUpHandler.bind(this), false);
        				this.canvas.addEventListener('mousemove', this.moveHandler.bind(this), false);
        				this.canvas.addEventListener('mouseenter', this.mouseEnterHandler.bind(this), false);
        				this.canvas.addEventListener('mouseleave', this.mouseLeaveHandler.bind(this), false);
        				            				
//        				this.findLongestDocumentTitle();
//        				
//        				var padding = 75;
//        				if (this.DRAW_SHORT_TITLES) padding = 50;
//        				this.setMaxLineWidth(width - this.MAX_LABEL_WIDTH - padding);
        			},
        			single: true,
        			scope: this
        		}
        	}
		});
		container.updateLayout();
		this.initialized = true;
	},
	
	doBubblelinesLayout: function() {
		if (this.initialized) {
			var width = this.container.getWidth();
			
			// width related calculations
			this.DRAW_SHORT_TITLES = width < 500;
			this.setTitleWidthsAndMaxTitleWidth();
			
			var children = Ext.DomQuery.jsSelect('div:not(div[class*=term])', this.container.el.dom);
			for (var i = 0; i < children.length; i++) {
				var child = Ext.fly(children[i]);
				child.setWidth(width);
			}
			this.canvas.width = width;
			
			var padding = 75;
			if (this.DRAW_SHORT_TITLES) padding = 50;
			this.setMaxLineWidth(width - this.MAX_LABEL_WIDTH - padding);
			this.setLineLengths();
			
			this.recache();
			
			// height related calculations
			this.setCanvasHeight();
			
			this.drawGraph();
		}
	},
	
	addDocToCache: function(doc) {
		this.cacheBubbles(doc);
		this.calculateBubbleRadii(doc);
		doc.lineLength = 600;
		doc.freqCounts = {}; // used for tool tip display
		if (this.cache.containsKey(doc.id) === false) {
			this.cache.add(doc);
		} else {
			this.cache.replace(doc.id, doc);
		}
		this.cache.sort('index', 'ASC');
	},
	
	addTermsToDoc: function(termsObj, docId) {
		var term;
		// only one key
		for (var key in termsObj) {
			term = key;
		}
		this.currentTerms[term] = true;
		
		var doc = this.cache.get(docId);
		Ext.apply(doc.terms, termsObj);
		var maxFreqChanged = this.cacheBubbles(doc);
		if (maxFreqChanged) {
			this.recache();
		} else {
			this.calculateBubbleRadii(doc);
		}
	},
	
	cacheBubbles: function(doc) {
		var maxFreqChanged = false;
		for (var term in doc.terms) {
			var termInfo = doc.terms[term];
			var bins = termInfo.distributions.length;
			var spacing = doc.lineLength / bins;
			
			var cachedPositions = [];
			var tokenPos = 0;
			var maxDistribution = 0;
			var xIndex = 0;
			for (var i = 0; i < bins; i++) {
				var d = termInfo.distributions[i];
				if (d > maxDistribution) {
					maxDistribution = d;
				}
				
				cachedPositions.push({id: Ext.id(null, 'bub'), x: xIndex, freq: d, radius: 0, bin: i, tokenPositions: termInfo.positions.slice(tokenPos, tokenPos+=d)});
				xIndex += spacing;
			}
			
			doc.terms[term].maxDistribution = maxDistribution;
			doc.terms[term].pos = cachedPositions;
			
			if (maxDistribution > this.maxFreq.value) {
				maxFreqChanged = true;
				this.setMaxFreq({term: term, value: maxDistribution});
			}
		}
		return maxFreqChanged;
	},
	
	calculateBubbleRadii: function(doc, newTerm) {
		var maxFreqLog = Math.log(this.maxFreq.value);
		var minFreq = Math.log(2) / 2;
//		this.cache.each(function(doc) {
			for (var t in doc.terms) {
				var term = doc.terms[t];
				if (term) {
					if (newTerm == null || t == newTerm) {
						for (var i = 0; i < term.pos.length; i++) {
							var bubble = term.pos[i];
							if (bubble.freq > 0) {
								var freqLog = Math.max(Math.log(bubble.freq), minFreq);
								var radius = freqLog / maxFreqLog * this.maxRadius;
								bubble.radius = radius;
							} else {
								bubble.radius = 0;
							}
						}
					}
				}
			}
//		}, this);
	},
	
	
	recache: function() {
		function doCache(doc) {
			this.cacheBubbles(doc);
			this.calculateBubbleRadii(doc);
		}
		
		this.cache.each(doCache, this);
	},
	
	/**
	 * Get the total height of the all the graphs
	 */
	getTotalHeight: function() {
		var totalHeight = this.maxRadius;
		this.cache.each(function(doc, index, length) {
			totalHeight += doc.height;
		}, this);
		return totalHeight;
	},
	

	/**
	 * Set the height for the canvas and associated elements
	 */
	setCanvasHeight: function() {
		this.calculateGraphHeights();
		var height = this.getTotalHeight();
		var container = this.container.dom;
		if (container !== undefined) {
			var children = Ext.DomQuery.jsSelect('div', container);
			for (var i = 0; i < children.length; i++) {
				var child = Ext.fly(children[i]);
				child.setHeight(height);
			}
		}
		if (this.canvas) {
			this.canvas.height = height;
		}
	},
	
	/**
	 * Set max line width as well as maxRadius
	 */
	setMaxLineWidth: function(width) {
		this.maxRadius = width / 30;
		this.MAX_LINE_WIDTH = width - this.maxRadius / 2;
	},
	
	/**
	 * Calculate graph heights, based on maxRadius
	 */
	calculateGraphHeights: function() {
		var graphSeparation = this.maxRadius * 0.5;
		if (this.SEPARATE_LINES_FOR_TERMS) {
			var terms = this.termsFilter;
			this.cache.each(function(doc, index, length) {
				var height = this.maxRadius * terms.length;
				for (var i = 0; i < terms.length; i++) {
					if (!doc.terms[terms[i]]) {
						height -= this.maxRadius;
					}
				}
				if (height == 0) height = this.maxRadius;
				
				doc.height = height + graphSeparation;
			}, this);
		} else {
			var height = Math.max(this.maxRadius, this.MIN_GRAPH_SEPARATION);
			this.cache.each(function(doc, index, length) {
				doc.height = height + graphSeparation;
			}, this);
		}
	},
	
	findLongestDocument: function(doc) {
		var twt = doc.getTotalWordTokens();
		if (twt > this.maxDocLength) {
			this.maxDocLength = twt;
		}
	},
	
	getTitleWidth: function(doc) {
		var title = doc.title;
		if (this.DRAW_SHORT_TITLES) {
			var index = this.cache.indexOf(doc);
			title = (index+1)+')';
		}
		this.ctx.textBaseline = 'top';
		this.ctx.font = 'bold 12px Verdana';
		var width = this.ctx.measureText(title).width;
		return width;
	},
	
	setTitleWidthsAndMaxTitleWidth: function() {
		function doTitle(doc, index) {
			var width = this.getTitleWidth(doc);
			doc.titleWidth = width;
			if (width > this.MAX_LABEL_WIDTH) {
				this.MAX_LABEL_WIDTH = width;
			}
		}
		this.cache.each(doTitle, this);
	},
	
	setLineLengths: function() {
		function doLength(doc, index) {
			var lineLength;
			if (this.UNIFORM_LINE_LENGTH) {
				lineLength = this.MAX_LINE_WIDTH;
			} else {
				var percentage = Math.log(doc.getTotalWordTokens()) / Math.log(this.maxDocLength);
				lineLength = percentage * this.MAX_LINE_WIDTH;
			}
			doc.lineLength = lineLength;
		}
		
		this.cache.each(doLength, this);
	},
	
	drawGraph: function(includeLegend) {
		if (this.intervalId != null) clearInterval(this.intervalId);
		
		if (this.mouseOver) {
			this.intervalId = setInterval(this.doDraw.bind(this, [includeLegend]), this.INTERVAL);
		} else {
			setTimeout(this.doDraw.bind(this, [includeLegend]), 5);
		}
	},
	
	doDraw: function(includeLegend) {
		this.clearCanvas();
		this.yIndex = this.maxRadius;
		if (includeLegend === true) this.yIndex += 30;
		this.cache.each(this.drawDocument, this);
		if (includeLegend === true) this.drawLegend();
		else this.drawToolTip();
		this.doDrag();
	},
	
	drawDocument: function(doc, index, totalDocs) {
		if (!doc.hidden) {
			var lineLength = doc.lineLength;
			var titleIndent = this.MAX_LABEL_WIDTH - doc.titleWidth;
			
			var xIndex = 5;
			
			this.ctx.textBaseline = 'top';
			this.ctx.font = 'bold 12px Verdana';
			
			if (this.dragInfo != null && this.dragInfo.oldIndex == index) {
				this.ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
				xIndex += titleIndent;
				this.ctx.fillText(doc.title, xIndex, this.yIndex);
				if (this.SEPARATE_LINES_FOR_TERMS) {
					this.yIndex += doc.height;
				}
			} else {			
				// draw label
				if (this.DRAW_TITLES) {
					xIndex += titleIndent;
	//				var c = this.getColor(this.getApplication().getCorpus().getDocument(doc.id).getIndex());
	//				this.ctx.strokeStyle = 'rgba('+c[0]+', '+c[1]+', '+c[2]+', 1.0)';
	//				this.ctx.lineWidth = 2;
	//				this.ctx.beginPath();
	//				this.ctx.moveTo(xIndex, this.yIndex+12);
	//				this.ctx.lineTo(this.MAX_LABEL_WIDTH, this.yIndex+12);
	//				this.ctx.stroke();
					
					this.ctx.fillStyle = 'rgba(128, 128, 128, 1.0)';
					var title = doc.title;
					if (this.DRAW_SHORT_TITLES) title = (index+1)+')';
					this.ctx.fillText(title, xIndex, this.yIndex);
				}
				
	//			this.ctx.fillStyle = 'rgba(0, 0, 128, 1.0)';
	//			this.ctx.fillRect(0, this.yIndex-this.maxRadius*0.75, 250, 2);
				
				// shift down slightly to vertically align line and bubbles with label
				this.yIndex += 4;
				
				// draw line
				var that = this;
				function drawLine() {
					xIndex = that.MAX_LABEL_WIDTH + that.maxRadius;
					that.ctx.strokeStyle = 'rgba(128, 128, 128, 1.0)';
					that.ctx.fillStyle = 'rgba(128, 128, 128, 1.0)';
					that.ctx.lineWidth = 0.25;
					
					that.ctx.beginPath();
					that.ctx.moveTo(xIndex, that.yIndex-6);
					that.ctx.lineTo(xIndex, that.yIndex+6);
					that.ctx.stroke();
					
					that.ctx.beginPath();
					that.ctx.moveTo(xIndex, that.yIndex);
					that.ctx.lineTo(xIndex + lineLength, that.yIndex);
					that.ctx.stroke();
					
					that.ctx.beginPath();
					that.ctx.moveTo(xIndex + lineLength, that.yIndex-6);
					that.ctx.lineTo(xIndex + lineLength, that.yIndex+6);
					that.ctx.stroke();
				}
				
	//			var filter = this.getApiParamValue('typeFilter');
	//			var filter = [];
	//			for (var term in this.currentTerms) {
	//				filter.push(term);
	//			}
				
				if (!this.SEPARATE_LINES_FOR_TERMS) {
					drawLine();
				} else if (this.termsFilter == null || this.termsFilter.length === 0) {
					drawLine();
				}
				
				// draw bubbles
				var pi2 = Math.PI * 2;
				
				var freqTotal = 0;
				doc.freqCounts = {};
				var terms = doc.terms;
				var checkClickedBubbles = this.lastClickedBubbles[index] != null;
				var termsDrawn = 0;
				for (var t in terms) {
					if (this.termsFilter.indexOf(t) !== -1) {
						var info = terms[t];
						if (info) {
							termsDrawn++;
							if (this.SEPARATE_LINES_FOR_TERMS) {
								drawLine();
							}
							
							var freqForType = 0;
							
							var c = info.color.join(',');
							this.ctx.strokeStyle = 'rgba('+c+', 1)';
							this.ctx.fillStyle = 'rgba('+c+', 0.35)';
							this.ctx.lineWidth = 0.25;
							
							freqTotal += info.rawFreq;
							freqForType += info.rawFreq;
							
							var checkCurrentType = checkClickedBubbles && this.lastClickedBubbles[index][t];
							
							for (var i = 0; i < info.pos.length; i++) {
								var b = info.pos[i];
								if (b.radius > 0) {
									var doClickedBubble = false;
									if (checkCurrentType && this.lastClickedBubbles[index][t] == b.id) {
										this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.75)';
										this.ctx.fillStyle = 'rgba('+c+', 0.5)';
										this.ctx.lineWidth = 1;
										doClickedBubble = true;
									}
									
									this.ctx.beginPath();
									this.ctx.arc(b.x+xIndex, this.yIndex, b.radius, 0, pi2, true);
									this.ctx.closePath();
									this.ctx.fill();
									this.ctx.stroke();
									
									if (doClickedBubble) {
										this.ctx.strokeStyle = 'rgba('+c+', 1)';
										this.ctx.fillStyle = 'rgba('+c+', 0.35)';
										this.ctx.lineWidth = 0.25;
									}
								}
							}
							doc.freqCounts[t] = freqForType;
							
							if (this.SEPARATE_LINES_FOR_TERMS) {
								this.ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
								this.ctx.font = '10px Verdana';
								this.ctx.fillText(freqForType, xIndex + lineLength + 5, this.yIndex-4);
								
								this.yIndex += this.maxRadius;
							}
						}
					}
				}
				
				if (this.SEPARATE_LINES_FOR_TERMS && termsDrawn == 0) {
					drawLine();
					
					this.ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
					this.ctx.font = '10px Verdana';
					this.ctx.fillText(0, xIndex + lineLength + 5, this.yIndex-4);
					
					this.yIndex += this.maxRadius;
				}
				
				xIndex += lineLength;
				
				if (!this.SEPARATE_LINES_FOR_TERMS) {
					this.ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
					this.ctx.font = '10px Verdana';
					this.ctx.fillText(freqTotal, xIndex + 5, this.yIndex-4);
				}
			}
			
			if (!this.SEPARATE_LINES_FOR_TERMS) {
				this.yIndex += doc.height;
			} else {
				this.yIndex += this.maxRadius * 0.5;
			}
			
			// undo previous shift
			this.yIndex -= 4;
			
	//		this.ctx.fillStyle = 'rgba(128, 0, 0, 1.0)';
	//		this.ctx.fillRect(0, this.yIndex-this.maxRadius*0.75, 350, 2);
		}
	},
	
	drawLegend: function() { // obsolete code?
		var x = this.MAX_LABEL_WIDTH + this.maxRadius;
		var y = 5;
		this.ctx.textBaseline = 'top';
		this.ctx.font = '16px serif';
		if (this.typeStore) {
			this.typeStore.each(function(record) {
				var color = record.get('color').join(',');
				this.ctx.fillStyle = 'rgb('+color+')';
				var type = record.get('type');
				this.ctx.fillText(type, x, y);
				var width = this.ctx.measureText(type).width;
				x += width + 8;
			}, this);
		}
	},
	
	drawToolTip: function() {
		if (this.overBubbles.length > 0) {
			this.ctx.lineWidth = 0.5;
			this.ctx.fillStyle = 'rgba(224, 224, 224, 0.8)';
			this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
			
			var x = this.overBubbles[0].x;
			var y = this.overBubbles[0].y;
			var width = 110;
			if (x + width > this.canvas.width) {
				x -= width;
			}
			var height;
			var summary = this.overBubbles[0].label == null;
			if (summary) {
				var doc = this.cache.get(this.overBubbles[0].docIndex);
				var count = 1;
				for (var t in doc.freqCounts) {
					count++;
				}
				height = count * 16;// + 10;
				if (y + height > this.canvas.height) {
					y -= height;
				}
				this.ctx.fillRect(x, y, width, height);
				this.ctx.strokeRect(x, y, width, height);
				x += 10;
				y += 10;
				this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
				this.ctx.font = '10px Verdana';
//				var total = 0;
				for (var t in doc.freqCounts) {
					var freq = doc.freqCounts[t];
//					total += freq;
					this.ctx.fillText(t+': '+freq, x, y, 90);
					y += 16;
				}
//				this.ctx.fillText(this.localize('total')+': '+total, x, y, 90);
				
			} else {
				height = this.overBubbles.length * 16 + 10;
				if (y + height > this.canvas.height) {
					y -= height;
				}
				this.ctx.fillRect(x, y, width, height);
				this.ctx.strokeRect(x, y, width, height);
				x += 10;
				y += 10;
				this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
				this.ctx.font = '10px Verdana';
				for (var i = 0; i < this.overBubbles.length; i++) {
					var b = this.overBubbles[i];
					this.ctx.fillText(b.label+': '+b.freq, x, y, 90);
					y += 16;
				}
			}
			
			if (this.clearToolTipId == null) {
				this.clearToolTipId = setTimeout(this.clearToolTip.bind(this), this.DISMISS_DELAY);
			}
		}
	},
	
	clearToolTip: function() {
		this.overBubbles = [];
		clearTimeout(this.clearToolTipId);
		this.clearToolTipId = null;
	},
	
	mouseEnterHandler: function(event) {
		this.mouseOver = true;
		this.drawGraph();
	},
	
	mouseLeaveHandler: function(event) {
		this.mouseOver = false;
		if (this.intervalId != null) clearInterval(this.intervalId);
		// draw once to remove any popup
		this.overBubbles = [];
		this.drawGraph();
	},
	
	moveHandler: function(event) {
		this.clearToolTip();
		
		this.overBubbles = [];
		var x = event.layerX - this.MAX_LABEL_WIDTH;
		var y = event.layerY;
		
		var docHeight = this.maxRadius*0.25; // where the first graph actually starts
		
		var docIndex = -1;
		this.cache.each(function(doc, index, length) {
			if (y < docHeight) {
				return false;
			} else {
				docHeight += doc.height;
				if (y < docHeight) {
					docIndex = index;
					return false;
				}
			}
		}, this);
		
		if (this.dragInfo != null) {
			this.dragInfo.x = event.layerX;
			this.dragInfo.y = y;

			if (docIndex >= this.cache.getCount()) {
				docIndex = this.cache.getCount()-1;
			} else if (docIndex < 0) {
				if (y + this.maxRadius > this.canvas.height) {
					docIndex = this.cache.getCount()-1;
				} else {
					docIndex = 0;
				}
			}
			
			this.dragInfo.newIndex = docIndex;
			document.body.style.cursor = 'move';
		} else {
			if (docIndex >= 0 && docIndex < this.cache.getCount()) {
				if (x >= 0) {
					var showPointer = false;
					x -= this.maxRadius; // re-adjust x to the start of the doc line 
					var hits = [];
					var doc = this.cache.get(docIndex);
					if (x >= doc.lineLength) {
						this.overBubbles = [{
							docIndex: docIndex,
							x: event.layerX+10,
							y: event.layerY+10
						}];
					} else {
						var spacing = doc.lineLength / this.bubbleSpacing;
						var xIndex = Math.round(x / spacing);
						var prevDocHeight = this.maxRadius;
						if (docIndex > 0) {
							prevDocHeight = docHeight - (this.cache.get(docIndex).height - this.maxRadius*0.75);
						}
						var yIndex = Math.round((y - prevDocHeight) / this.maxRadius);
						
						var count = 0;
						for (var t in doc.terms) {
							if (this.termsFilter.indexOf(t) !== -1) {
								var type = doc.terms[t];
								if (type) {
									if (this.SEPARATE_LINES_FOR_TERMS && count == yIndex || !this.SEPARATE_LINES_FOR_TERMS) {
										if (type.pos[xIndex] && type.pos[xIndex].radius > 0) {
											showPointer = true;
											this.overBubbles.push({
												label: t,
												type: type,
												docId: doc.id,
												docIndex: docIndex,
												xIndex: xIndex,
												yIndex: yIndex,
												freq: type.pos[xIndex].freq,
												id: type.pos[xIndex].id,
												tokenPositions: type.pos[xIndex].tokenPositions,
												x: event.layerX+10,
												y: event.layerY+10
											});
										}
									}
								} else if (this.SEPARATE_LINES_FOR_TERMS) count--;
								count++;
							}
						}
					}
					if (showPointer) {
						document.body.style.cursor = 'pointer';
					} else {
						document.body.style.cursor = 'auto';
					}
				} else {
					document.body.style.cursor = 'move';
				}
			} else {
				document.body.style.cursor = 'auto';
			}
		}
	},
	
	mouseDownHandler: function(event) {
		var x = event.layerX;
		var y = event.layerY;
		if (x < this.MAX_LABEL_WIDTH) {
			
			var docHeight = this.maxRadius*0.25;
			var docIndex = -1;
			this.cache.each(function(doc, index, length) {
				if (y < docHeight) {
					return false;
				} else {
					docHeight += doc.height;
					if (y < docHeight) {
						docIndex = index;
						return false;
					}
				}
			}, this);

			if (docIndex >= 0 && docIndex < this.cache.getCount()) {
				var xOffset = x - 5;
				var yOffset = 5;
				this.dragInfo = {
					oldIndex: docIndex,
					newIndex: docIndex,
					xOffset: xOffset,
					yOffset: yOffset,
					x: x,
					y: y
				};
			}
		}
	},
	
	mouseUpHandler: function(event) {
		this.dragInfo = null;
	},
	
	doDrag: function() {
		if (this.dragInfo != null) {
			var ordering = {};
			for (var i = 0; i < this.cache.getCount(); i++) {
				if (i < this.dragInfo.oldIndex && i < this.dragInfo.newIndex) {
					ordering[i] = i;
				} else if (i < this.dragInfo.oldIndex && i >= this.dragInfo.newIndex) {
					ordering[i] = i + 1;
				} else if (i == this.dragInfo.oldIndex) {
					ordering[i] = this.dragInfo.newIndex;
				} else if (i > this.dragInfo.oldIndex && i > this.dragInfo.newIndex) {
					ordering[i] = i;
				} else if (i > this.dragInfo.oldIndex && i <= this.dragInfo.newIndex) {
					ordering[i] = i - 1;
				}
			}
			this.dragInfo.oldIndex = this.dragInfo.newIndex;
			
			this.cache.reorder(ordering);
			
			var doc = this.cache.get(this.dragInfo.oldIndex);
			this.ctx.fillStyle = 'rgba(128, 128, 128, 1)';
			this.ctx.textBaseline = 'top';
			this.ctx.font = 'bold 12px Verdana';

			this.ctx.fillText(doc.title, this.dragInfo.x - this.dragInfo.xOffset, this.dragInfo.y - this.dragInfo.yOffset);
		}
	},
	
	clickHandler: function(event) {
		this.lastClickedBubbles = {};
		if (this.overBubbles.length > 0 && this.overBubbles[0].label) {
			var hits = [];
			var tokenPositions = [];
			var termData = [];
			for (var i = 0; i < this.overBubbles.length; i++) {
				var b = this.overBubbles[i];
				
				termData.push({term: b.label, docIndex: b.docIndex, docId: b.docId, tokenPositions: b.tokenPositions});
				
				if (this.lastClickedBubbles[b.docIndex] == null) {
					this.lastClickedBubbles[b.docIndex] = {};
				}
				this.lastClickedBubbles[b.docIndex][b.label] = b.id;
				hits.push(b.docId+':'+b.label);
				tokenPositions.push(b.tokenPositions);
			}
			tokenPositions = Ext.flatten(tokenPositions);
			tokenPositions.sort();
			
			if (this.externalClickHandler !== undefined) {
				this.externalClickHandler(termData);
			}
		}
		this.overBubbles = [];
	},
	
	setMaxFreq: function(maxObj) {
		if (maxObj == null) {
			maxObj = this.findMaxFreq();
		}
		this.maxFreq = maxObj;
	},
	
	findMaxFreq: function() {
		var max = {term: '', value: 0};
		this.cache.each(function(doc) {
			for (var t in doc.terms) {
				var maxDistribution = doc.terms[t].maxDistribution;
				if (maxDistribution > max.value) {
					max = {term: t, value: maxDistribution};
				}
			}
		}, this);
		return max;
	},
	
	getNewColor: function() {
		var color = null;
		for (var i = 0; i < this.colors.length; i++) {
			color = this.colors[i];
			var match = this.typeStore.findExact('color', color);
			if (match == -1) break;
			else color = null;
		}
		if (color == null) color = [128, 128, 128];
		return color;
	},
	
	removeAllTerms: function() {
		this.cache.each(function(doc) {
			doc.terms = {};
		}, this);
		this.currentTerms = {};
		this.termsFilter = [];
	},
	
	removeTerm: function(term) {
//		var types = this.store.query('type', type);
//		types.each(function(type) {
//			this.store.remove(type);
//		}, this);
		
		delete this.currentTerms[term];
		
//		var types = this.getApiParamValue('type');
//		types = types.remove(type);
//		this.setApiParams({type: types});
		
		var getNewMax = false;
		this.cache.each(function(doc) {
			for (var t in doc.terms) {
				if (t == term) {
					if (this.maxFreq.term == term) {
						this.maxFreq = {term: null, value: 0};
						getNewMax = true;
					}
					delete doc.terms[t];
				}
			}
		}, this);
		
		for (var i in this.lastClickedBubbles) {
			var lcTypes = this.lastClickedBubbles[i];
			for (var lcType in lcTypes) {
				if (lcType == term) {
					delete this.lastClickedBubbles[i][lcType];
				}
			}
			
		}
		
		if (getNewMax) {
			this.setMaxFreq();
			this.calculateBubbleRadii();
			this.drawGraph();
		}
	},
	
	clearCanvas: function() {
		this.canvas.width = this.canvas.width;
	}
};
function Knots(config) {
	this.container = config.container;
	this.externalClickHandler = config.clickHandler;
	
	this.MAX_LINE_LENGTH = 0;
	this.LINE_SIZE = 2.5;
	
	this.progressiveDraw = true;
	this.progDrawDone = false;
	this.drawStep = 0;
	
	this.mouseOver = false;
	this.refreshInterval = 100;
	this.forceRedraw = false;
	this.lastDrawTime = new Date().getTime();
	this.intervalId = null;
	this.startAngle = 315;
	this.angleIncrement = 15;
	
	this.canvas = null;
	this.ctx = null;
	this.currentDoc = {
		terms: {},
		lineLength: undefined
	};
	this.maxDocLength = 0;
	
	this.offset = {x: 0, y: 0};

	this.termsFilter = [];
	
	this.initialized = false;
	
	this.audio = config.audio;
	this.audioCtx = null;
}


Knots.prototype = {
	constructor: Knots,
	
	initializeCanvas: function() {
		var container = this.container;
		var height = container.getHeight()-5;
		var width = container.getWidth();
		this.MAX_LINE_LENGTH = Math.sqrt((width * width) + (height * height));
		
		var id = Ext.id('knots');
		container.add({
			xtype: 'container',
			width: width,
			height: height,
			html: '<canvas id="'+id+'" width="'+width+'" height="'+height+'"></canvas>',
			border: false,
        	listeners: {
        		afterrender: {
        			fn: function(cnt) {
    					this.canvas = document.getElementById(id);
        				this.ctx = this.canvas.getContext('2d');
        				this.canvas.addEventListener('click', this.clickHandler.bind(this), false);
        				this.canvas.addEventListener('mousedown', this.mouseDownHandler.bind(this), false);
        				this.canvas.addEventListener('mouseup', this.mouseUpHandler.bind(this), false);
        				this.canvas.addEventListener('mousemove', this.moveHandler.bind(this), false);
        			},
        			single: true,
        			scope: this
        		}
        	}
		});
		container.updateLayout();
		this.initialized = true;
	},
	
	doLayout: function() {
		if (this.initialized) {
			var width = this.container.getWidth();
			var height = this.container.getHeight()-5;
			this.canvas.width = width;
			this.canvas.height = height;
			this.recache();
			this.buildGraph();
		}
	},
	
	buildGraph: function(drawStep) {
		if (this.intervalId != null) {
			this.progDrawDone = false;
			clearInterval(this.intervalId);
		}
		this.forceRedraw = true;

		this.drawStep = drawStep || 0;
		
		for (var t in this.currentDoc.terms) {
			var term = this.currentDoc.terms[t];
			term.done = false;
		}
		
		if (!this.progressiveDraw) {
			this.doDraw(false);
		} else {
			this.intervalId = setInterval(this.doDraw.createDelegate(this, [false]), 50);
		}
	},
	
	drawGraph: function(includeLegend) {
		if (this.intervalId != null) {
			this.progDrawDone = false;
			clearInterval(this.intervalId);
		}
		this.forceRedraw = true;
		
		if (!this.progressiveDraw) {
			this.doDraw(false, includeLegend);
		} else {
			this.intervalId = setInterval(this.doDraw.createDelegate(this, [includeLegend]), 50);
		}
	},
	
	doDraw: function(includeLegend) {
		var time = new Date().getTime();
		if (this.forceRedraw || time - this.lastDrawTime >= this.refreshInterval) {
			this.forceRedraw = false;
			
			this.clearCanvas();
			
			this.ctx.save();
			this.ctx.translate(this.offset.x, this.offset.y);
			
			this.drawDocument(this.currentDoc);
			
			// animate the origin
	//		this.originOpacity -= 0.01;
	//		if (this.originOpacity < 0) {
	//			this.originOpacity = 1.0;
	//		}
			this.originOpacity = 0.5;
			this.originColor = '128,128,128';
			this.ctx.lineWidth = Math.abs(this.originOpacity - 1) * 15;
			this.ctx.fillStyle = 'rgba('+this.originColor+',1.0)';
			this.ctx.strokeStyle = 'rgba('+this.originColor+','+this.originOpacity+')';
			this.ctx.beginPath();
			this.ctx.arc(0, 0, this.LINE_SIZE*2, 0, Math.PI*2, true);
			this.ctx.closePath();
			this.ctx.fill();
			
			if (!includeLegend) this.ctx.stroke();
			this.ctx.restore();
			this.ctx.lineWidth = 1;
			
			if (includeLegend === true) {
				this.drawLegend();
			}
			
			this.lastDrawTime = new Date().getTime();
			
			// test to see if each doc term is done
			if (this.progressiveDraw) {
				var done = true;
				for (var t in this.currentDoc.terms) {
					done = done && this.currentDoc.terms[t].done;
				}
				this.progDrawDone = done;
				if (done) {
					clearInterval(this.intervalId);
					this.intervalId = null;
					this.muteTerms();
				} else {
					this.drawStep++;
				}
			}
		}
	},
	
	setAudio: function(audio) {
		this.audio = audio;
		if (!audio) {this.muteTerms();}
	},
	
	muteTerms: function() {
		for (t in this.currentDoc.terms) {
			if (this.currentDoc.terms[t].audio) {
				this.currentDoc.terms[t].audio.gainNode.gain.value=0;
			}
		}
	},
	
	drawDocument: function(doc) {
		var terms = doc.terms;
		
		for (var t in terms) {
			if (this.termsFilter.indexOf(t) != -1) {
				var info = terms[t];
				if (info && info.pos) {
					var prevXY = [[0,0],[0,0]];
					if (this.progressiveDraw) {
						var length = this.drawStep + 1;
						if (info.pos.length <= this.drawStep) {
							info.done = true;
							length = info.pos.length;
							if (info.audio) {info.audio.gainNode.gain.value=0};
						} else {
							if (this.audio && info.audio) {
								info.audio.gainNode.gain.value=.1;
								setTimeout(function() {
									info.audio.gainNode.gain.value=0;
								}, this.refreshInterval*.75)
							}
							info.done = false;
						}
						for (var i = 0; i < length; i++) {
							var xy = info.pos[i];
							this.drawPolygon(xy, prevXY, info.color);
							prevXY = [[xy.polygon[0][3], xy.polygon[1][3]], [xy.polygon[0][2], xy.polygon[1][2]]];
						}
					} else {
						for (var i = 0; i < info.pos.length; i++) {
							var xy = info.pos[i];
							this.drawPolygon(xy, prevXY, info.color);
							prevXY = [[xy.polygon[0][3], xy.polygon[1][3]], [xy.polygon[0][2], xy.polygon[1][2]]];
						}
					}
				}
			}
		}
	},
	
	drawPolygon: function(xy, prevXY, color) {
		var polyX = xy.polygon[0];
		var polyY = xy.polygon[1];
		
		// connect to previous polygon to make smoother turns
		this.ctx.beginPath();
		this.ctx.moveTo(prevXY[0][0], prevXY[0][1]);
		this.ctx.lineTo(polyX[0], polyY[0]);
		this.ctx.lineTo(polyX[1], polyY[1]);
		this.ctx.lineTo(prevXY[1][0], prevXY[1][1]);
		this.ctx.closePath();
		
		this.ctx.fillStyle = 'rgba('+color+', 0.6)';
		this.ctx.fill();

		// draw the current polygon
		this.ctx.beginPath();
		this.ctx.moveTo(polyX[0], polyY[0]);
		this.ctx.lineTo(polyX[1], polyY[1]);
		this.ctx.lineTo(polyX[2], polyY[2]);
		this.ctx.lineTo(polyX[3], polyY[3]);
		this.ctx.closePath();

		if (xy.over) this.ctx.fillStyle = 'rgba('+color+', 1.0)';
		this.ctx.fill();
	},
	
	drawLegend: function() {
		var x = 5;
		var y = 5;
		this.ctx.textBaseline = 'top';
		this.ctx.font = '16px serif';
		this.termStore.each(function(record) {
			var color = record.get('color');
			this.ctx.fillStyle = 'rgb('+color+')';
			var term = record.get('term');
			this.ctx.fillText(term, x, y);
			var width = this.ctx.measureText(term).width;
			x += width + 8;
		}, this);
	},
	
	setCurrentDoc: function(doc) {
		this.currentDoc = doc;
		this.cacheCurrentDocument();
	},
	
	addTerms: function(termsObj) {
		Ext.apply(this.currentDoc.terms, termsObj);
		this.recache();
	},
	
	removeTerm: function(term) {
		if (this.currentDoc.terms[term].audio) {this.currentDoc.terms[term].audio.oscillator.stop();}
		delete this.currentDoc.terms[term];
		this.recache();
	},
	
	removeAllTerms: function() {
		for (term in this.currentDoc.terms) {
			if (this.currentDoc.terms[term].audio) {
				this.currentDoc.terms[term].audio.oscillator.stop();
			}
		}
		this.currentDoc.terms = {};
		this.recache();
	},
	
	recache: function() {
		this.MAX_LINE_LENGTH = Math.sqrt((this.canvas.width * this.canvas.width) + (this.canvas.height * this.canvas.height));
		this.cacheCurrentDocument();
		this.determineGraphSizeAndPosition();
	},
	
	cacheCurrentDocument: function() {
		var lineLength = this.MAX_LINE_LENGTH;
		
		this.currentDoc.lineLength = lineLength;
		
		if (this.audio && this.audioCtx == null) {
			try {
				this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			} catch(e) {
			}
		}
		
		for (var term in this.currentDoc.terms) {
			if (this.audio && this.audioCtx && !this.currentDoc.terms[term].audio) {
				var oscillator = this.audioCtx.createOscillator();
				var gainNode = this.audioCtx.createGain();
				oscillator.connect(gainNode);
				gainNode.connect(this.audioCtx.destination);
				oscillator.frequency.value = (Math.random()*500)+150; // value in hertz
				oscillator.start();
				gainNode.gain.value = 0;
				this.currentDoc.terms[term].audio = {oscillator: oscillator, gainNode: gainNode}
			} 
			this.cacheTurns(this.currentDoc.terms[term], lineLength);
		}
	},
	
	cacheTurns: function(info, lineLength) {
		var rawFreq = info.rawFreq;
		if (rawFreq > 0) {
			var doc = this.currentDoc;
			
			var term = info.term;
			var color = info.color;

			var cachedPositions = [];
			
			var tokenIds = info.positions;
			var lastTokenId = tokenIds[tokenIds.length-1];
			
			var angle = this.startAngle;
			var angleIncrement = this.angleIncrement;
			var prevX = 0;
			var prevY = 0;
			var x = 0;
			var y = 0;
			var prevLength = 0;
			
			for (var i = 0; i < tokenIds.length; i++) {
				var o = tokenIds[i];
				
				var length = o / lastTokenId * lineLength;
				var segment = length - prevLength;
				
				prevX = x;
				prevY = y;
				
				var newPoint = this.findEndPoint([x, y], segment, angle);
				x = newPoint[0];
				y = newPoint[1];
				
				var polygon = this.getPolygonFromLine([prevX, prevY], [x, y], angle, this.LINE_SIZE);
				
				cachedPositions.push({tokenId: o, polygon: polygon, over: false});
				
				prevLength = length;
				angle += angleIncrement;
			}
			
//			doc.terms[term] = {pos: cachedPositions, rawFreq: rawFreq, color: color, done: false};
			doc.terms[term].pos = cachedPositions;
			doc.terms[term].done = false;
		}
	},
	
	findEndPoint: function(point, length, angle) {
		var radians = this.degreesToRadians(angle);
		var x2 = point[0] + (length * Math.cos(radians));
		var y2 = point[1] + (length * Math.sin(radians));
		return [x2, y2];
	},
	
	determineGraphSizeAndPosition: function() {		
		var bb = this.findBoundingBoxForGraph();

		// find the size ratio between the graph and the canvas
		var width = bb.maxX - bb.minX;
		var height = bb.maxY - bb.minY;
		var widthRatio = this.canvas.width / width;
		var heightRatio = this.canvas.height / height;
		var ratio = Math.min(widthRatio, heightRatio);
		ratio -= 0.05; // create some space around the borders
		
		width *= ratio;
		height *= ratio;
		
		this.offset.x = Math.abs(bb.minX * ratio - (this.canvas.width / 2 - width / 2));
		this.offset.y = Math.abs(bb.minY * ratio - (this.canvas.height / 2 - height / 2));
		
		this.MAX_LINE_LENGTH = Math.sqrt((this.canvas.width * this.canvas.width) + (this.canvas.height * this.canvas.height)) * ratio;
		
		this.cacheCurrentDocument();
	},
	
	findBoundingBoxForGraph: function() {
		var minX = null;
		var maxX = null;
		var minY = null;
		var maxY = null;
		for (var t in this.currentDoc.terms) {
			var pos = this.currentDoc.terms[t].pos;
			for (var i = 0; i < pos.length; i++) {
				var polygon = pos[i].polygon;
				var bb = this.getBoundingBox(polygon[0], polygon[1]);
				if (minX == null || bb[0] < minX) minX = bb[0];
				if (maxX == null || bb[2] > maxX) maxX = bb[2];
				if (minY == null || bb[1] < minY) minY = bb[1];
				if (maxY == null || bb[3] > maxY) maxY = bb[3];
			}
		}
		
		return {minX: minX, minY: minY, maxX: maxX, maxY: maxY};
	},
	
	getBoundingBox: function(polyX, polyY) {
		var minX = Math.min(polyX[0], polyX[2]);
		var maxX = Math.max(polyX[0], polyX[2])
		var minY = Math.min(polyY[0], polyY[2]);
		var maxY = Math.max(polyY[0], polyY[2]);
		return [minX, minY, maxX, maxY];
	},
	
	degreesToRadians: function(d) {
		return d * (Math.PI / 180);
	},
	
	clickHandler: function(event) {
		var x = event.layerX - this.offset.x;
		var y = event.layerY - this.offset.y;
		var hit = null;
		var tokenId = 0;
		for (var t in this.currentDoc.terms) {
			if (this.termsFilter.indexOf(t) != -1) {
				var pos = this.currentDoc.terms[t].pos;
				for (var i = 0; i < pos.length; i++) {
					var polygon = pos[i].polygon;
					var test = this.isPointInPolygon(polygon[0], polygon[1], x, y);
					if (test) {
						hit = t;
						tokenId = pos[i].tokenId;
						break;
					}
				}
			}
		}

		if (hit) {
			if (this.externalClickHandler !== undefined) {
				this.externalClickHandler({term: hit, tokenId: tokenId});
			}
		}
	},
	
	moveHandler: function(event) {
		var x = event.layerX - this.offset.x;
		var y = event.layerY - this.offset.y;
		if (this.dragInfo != null) {
			document.body.style.cursor = 'move';
			this.dragInfo.lastX = this.dragInfo.x;
			this.dragInfo.lastY = this.dragInfo.y;
			this.dragInfo.x = event.layerX;
			this.dragInfo.y = event.layerY;
			var xDiff = this.dragInfo.x - this.dragInfo.lastX;
			var yDiff = this.dragInfo.y - this.dragInfo.lastY;
			this.offset.x += xDiff;
			this.offset.y += yDiff;
		} else {
			this.mouseOver = false;
			for (var t in this.currentDoc.terms) {
				if (this.termsFilter.indexOf(t) != -1) {
					var pos = this.currentDoc.terms[t].pos;
					for (var i = 0; i < pos.length; i++) {
						if (!this.mouseOver) {
							var polygon = pos[i].polygon;
							var test = this.isPointInPolygon(polygon[0], polygon[1], x, y);
							if (test) {
								this.currentDoc.terms[t].pos[i].over = true;
								this.mouseOver = true;
							} else {
								this.currentDoc.terms[t].pos[i].over = false;
							}
						} else {
							this.currentDoc.terms[t].pos[i].over = false;
						}
					}
				}
			}
			if (this.mouseOver) {
				document.body.style.cursor = 'pointer';
				if (!this.progressiveDraw || (this.progressiveDraw && this.progDrawDone)) {
					clearInterval(this.intervalId);
					this.intervalId = setInterval(this.doDraw.createDelegate(this, [false]), 50);
				}
			} else {
				document.body.style.cursor = 'auto';
				if (!this.progressiveDraw || (this.progressiveDraw && this.progDrawDone)) {
					clearInterval(this.intervalId);
					this.doDraw(false);
				}
			}
		}
	},
	
	mouseDownHandler: function(event) {
		var x = event.layerX;
		var y = event.layerY;
		this.dragInfo = {
			lastX: x,
			lastY: y,
			x: x,
			y: y
		};
	},
	
	mouseUpHandler: function(event) {
		this.dragInfo = null;
	},
	
	getPolygonFromLine: function(point1, point2, angle, size) {
		var perpDown = angle + 90;
		var perpUp = angle - 90;
		
		var p1 = this.findEndPoint(point1, size, perpDown);
		var p2 = this.findEndPoint(point1, size, perpUp);
		var p3 = this.findEndPoint(point2, size, perpUp);
		var p4 = this.findEndPoint(point2, size, perpDown);
		
		var polyX = [p1[0], p2[0], p3[0], p4[0]];
		var polyY = [p1[1], p2[1], p3[1], p4[1]];
		return [polyX, polyY];
	},
	
	// from http://alienryderflex.com/polygon/
	isPointInPolygon: function(polyX, polyY, x, y) {
		var i = 0;
		var j = 3; // number of polygon sides minus 1
		var oddNodes = false;
		for (i = 0; i < 4; i++) {
			if ((polyY[i] < y && polyY[j] >= y) ||
				(polyY[j] < y && polyY[i] >= y)) {
				if (polyX[i] + (y - polyY[i]) / (polyY[j] - polyY[i]) * (polyX[j] - polyX[i]) < x) {
					oddNodes = !oddNodes;
				}
			}
			j = i;
		}
		return oddNodes;
	},
	
	clearCanvas: function() {
		this.canvas.width = this.canvas.width;
	}
};
/*
 * Author: Andrew MacDonald
 * Licensed for use under the GNU General Public License
 * http://creativecommons.org/licenses/GPL/2.0/
 */

function Cirrus(config) {
    var that = this;
    this.config = config;
    var canvasId = Ext.id(null, 'cirrusCanvas');
    if (this.config.containerId == null) {
        alert('You must provide a valid container ID!');
        return;
    }
    var containerId = '#'+this.config.containerId;
    var wordController = null;
    var resizeTimer = null;
    
    this.clear = function() {
        this.canvas.width = this.canvas.width;
    };
    
    this.addWords = function(words) {
        wordController.addWords(words);
    };
    
    this.arrangeWords = function() {
        wordController.arrangeWords();
    };

    this.clearAll = function() {
        wordController.setWords([]);
        wordController.grid = [];
        this.clear();
    };

    this.resizeWords = function() {
        that.setCanvasDimensions();
        wordController.resetWordCoordinates();
        wordController.calculateSizeAdjustment();
        wordController.resizeWords();
        wordController.arrangeWords();
        resizeTimer = null;
    };

    this.setCanvasDimensions = function() {
        var container = $(containerId)[0];
        var width = Math.max(container.offsetWidth, container.clientWidth);
        var height = Math.max(container.offsetHeight, container.clientHeight);
        this.canvas.width = width;
        this.canvas.height = height;
    };

    function hex2RGB(hex) {
        hex = hex.charAt(0) == '#' ? hex.substring(1,7) : hex;
        var rgb = [];
        rgb.push(parseInt(hex.substring(0, 2), 16));
        rgb.push(parseInt(hex.substring(2, 4), 16));
        rgb.push(parseInt(hex.substring(4, 6), 16));
        return rgb;
    }
    
    function init() {
        
        if ($('#'+that.config.containerId).length == 0) {
            alert('You must provide a valid container ID!');
            return;
        }
        
        // create the canvas
        that.canvas = document.createElement('canvas');
        that.canvas.setAttribute('id', canvasId);
        that.canvas.setAttribute('tabIndex', 1);
        that.setCanvasDimensions();
        $(containerId).append(that.canvas);
        canvasId = '#'+canvasId;
        
        that.context = that.canvas.getContext('2d');
        var isLocal = false; // should we call the server for words or use local ones?
        that.wordData = new Array(); // the word data to input into the app
        that.useFadeEffect = true; // should we use a fade effect for displaying words?
        that.colors = [[116,116,181], [139,163,83], [189,157,60], [171,75,75], [174,61,155]];
        wordController = new WordController(that);
        
        for (var key in that.config) {
            if (key == 'words') that.wordData = that.config[key];
            if (key == 'layout') {
                if (that.config[key] == 'circle') wordController.layout = wordController.CIRCLE;
                else if (that.config[key] == 'square') wordController.layout = wordController.SQUARE;
            }
            if (key == 'colors') {
                // expects an array of hex colors
                if ($.isArray(that.config[key]) && that.config[key].length > 0) {
                    that.colors = [];
                    for (var c in that.config[key]) {
                        that.colors.push(hex2RGB(that.config[key][c]));
                    }
                }
            }
            if (key == 'background') {
                $(canvasId).css("background-color", that.config[key]);
            }
            if (key == 'fade') {
                if (that.config[key] == 'true') that.useFadeEffect = true;
                else if (that.config[key] == 'false') that.useFadeEffect = false;
            }
            if (key == 'smoothness') {
                wordController.wordsToArrange = Math.max(1, Math.min(20, parseInt(that.config[key]))); // set to value between 1-20
            }
        }
        
        if (isLocal && testData) {
            var cnt = 0;
            for (var key in testData) {
                that.wordData.push({word: key, size: testData[key] / 13, label: key});
                cnt++;
                if (cnt == 100) break;
            }
        }
        
        if (that.wordData.length > 0) {
            that.clear();
            wordController.addWords(that.wordData);
            wordController.arrangeWords();
        }
        
        $(window).resize(function() {
            if (resizeTimer != null) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(that.resizeWords, 1000);
        });

        $(canvasId).keypress(function(event) {
            if (event.which == 114) wordController.arrangeWords(); // r was pressed
        });
        
        $(canvasId).click(function(event) {
            var matchingWord = wordController.handleWordClick(event);
            if (matchingWord !== undefined) {
	            if (that.config.clickHandler) {
	            	that.config.clickHandler({term: matchingWord.text, value: matchingWord.value});
	            }
            }
        });
        
        $(canvasId).mouseover(function(event) {
        	wordController.startUpdates();
        });
        $(canvasId).mouseout(function(event) {
        	wordController.stopUpdates();
        });
        
        $(canvasId).mousemove(function(event) {
            wordController.handleMouseMove(event);
        });
    }
    
    $(document).ready(init);
}

/**
 * The word object.  Stores various properties related to diplaying the word.
 * @author Andrew
 */
function Word(_text, _origSize, _color, _rolloverText, _value) {
    this.height = 0;					// the height of the label
    this.width = 0;						// the width of the label
    this.rotation = 0; 					// rotation of the label, in radians
    this.relativeSize = 0;				// the size relative to the largest and smallest word sizes
    this.mask = null;					// a 2 dimensional array containing the local xy co-ordinates of opaque pixels
    this.size = 0;						// the largest of either the height or width, used in the circle layout
    
    /* Init */
    this.text = _text;					// the actual word
    this.color = _color;				// the color of the label
    this.origSize = _origSize;			// the original size (used when re-calculating relative sizes of words)
    this.rolloverText = _rolloverText;	// the text to show on rollover
    this.value = _value || 0;			// a value associated with the word (can be anything)
    this.x = 0;							// the x co-ordinate
    this.y = 0;							// the y co-ordinate
    this.tx = 0;						// the translation value for x
    this.ty = 0;						// the translation value for y
    this.fontFamily = 'Arial';			// the font family
    this.fontSize = 12;					// the font family
    this.alpha = 1;						// alpha of the label
    this.live = false;					// true if the word should be displayed
    this.isOver = false;				// true if the mouse if over the word
    
    this.draw = function(ctx) {
        ctx.save();
        ctx.fillStyle = 'rgba('+this.color[0]+','+this.color[1]+','+this.color[2]+','+this.alpha+')';
        ctx.textBaseline = 'alphabetic';
        ctx.font = this.fontSize + 'px '+ this.fontFamily;
        ctx.translate(this.x + this.tx, this.y + this.ty);
        ctx.rotate(this.rotation);
        ctx.fillText(this.text, 0, 0);
        ctx.restore();
    };
}

function WordController(parentApp) {
    var that = this;
    
    var app = parentApp;
    
    var myFont = 'Impact';
    
    this.CIRCLE = 0; // circle layout
    
    this.ratio = 1; // the width to height ratio
    
    var _layout = this.CIRCLE; // what layout to use
    this.getLayout = function() {
        return _layout;
    };
    this.setLayout = function(value) {
        _layout = value;
    };
    
    this.HORIZONTAL = 0;
    this.MIXED = 1; // horizontal and vertical
    
    var _wordOrientation = this.MIXED;
    this.getWordOrientation = function() {
        return _wordOrientation;
    };
    this.setWordOrientation = function(value) {
    	_wordOrientation = value;
    };
    
    this.UPDATE_RATE = 25; // update frequency in milliseconds
    this.COARSENESS = 5; // how many pixels do we skip when creating the mask?
//    if ($.browser.webkit) this.COARSENESS = 3; 
    this.grid = new Array(); // a multidimensional array ([x][y]), holding co-ords for words
    var timer_i = 0;
    var timer; // timer used to incrementally call the arrange method
    this.doingArrange = false;
    this.wordsToArrange = 5; // how many words to arrange for each call to the arrange method
    var overWord = null; // what word is the user mousing over?
    var overX = 0; // position of the mouse when over a word
    var overY = 0;
    
    var _words = new Array(); // the list of word objects
    this.getWords = function() {
        return _words;
    }
    this.setWords = function(value) {
        _words = value;
    }
    
    this.sizeAdjustment = 100; // amount to multiply a word's relative size by
    
    this.minFontSize = 12;
    
    // for tracking sizes in word data
    this.largestWordSize = 0;
    this.smallestWordSize = 10000;
    
    var _uniqueWords = new Object(); // stores words as properties, making sure we don't have duplicates
    
    /**
     * Creates a word object and adds it to the list.
     * If the size value is outside the current max/min value, returns true (meaning we have to resize all the words).
     * @param	word
     * @param	size
     * @param	color
     * @param	label
     * @param	value
     * @return
     */
    function addWord(word, size, color, label, value) {
        var sizeChanged = false;
        if (_uniqueWords[word] == null) {
            _uniqueWords[word] = true;
            
            if (size > that.largestWordSize) {
                that.largestWordSize = size;
                sizeChanged = true;
            }
            if (size < that.smallestWordSize) {
                that.smallestWordSize = size * 0.8; // set the smallest size a bit smaller than the actual smallest size; this will insure all words are legible.
                sizeChanged = true;
            }
            var wordObj = new Word(word, size, color, label, value);
            _words.push(wordObj);
        }
        return sizeChanged;
    }
    
    /**
     * Adds an array of objects with the following properties: word, size, color, label, value.
     * @param	words
     */
    this.addWords = function(newWords) {
        var sizeChanged = false;
        for (var i = 0; i < newWords.length; i++) {
            var wordObj = newWords[i];
            
            var color;
            if (typeof(wordObj.color) == undefined || wordObj.color == null || wordObj.color == '') {
                color = app.colors[Math.floor(Math.random() * (app.colors.length))];
            } else color = wordObj.color;
            
            var size;
            if (typeof(wordObj.size) == undefined || wordObj.size == null || wordObj.size == '') {
                size = Math.floor(Math.random() * 40);
            } else size = parseFloat(wordObj.size);
            
            sizeChanged = addWord(wordObj.word, size, color, wordObj.label, wordObj.value) || sizeChanged;
        }
        sortWords();
        
        this.setRelativeSizes();
        this.calculateSizeAdjustment();
        if (sizeChanged) this.resizeWords();
        else createAllGraphics();
    }
    
    this.resetWordCoordinates = function() {
        app.clear();
        clearTimeout(timer);
        for (var i = 0; i < _words.length; i++) {
            var word = _words[i];
            word.x = 0;
            word.y = 0;
            word.tx = 0;
            word.ty = 0;
        }
    }
    
    this.calculateSizeAdjustment = function() {
    	this.ratio = app.canvas.width / app.canvas.height;
        var stageArea = app.canvas.width * app.canvas.height;
        if (stageArea < 100000) this.minFontSize = 8;
        else this.minFontSize = 12;
        var pixelsPerWord = stageArea / _words.length;
        var totalWordsSize = 0;
        for (var i = 0; i < _words.length; i++) {
            var word = _words[i];
            var wordArea = calculateWordArea(word);
            totalWordsSize += wordArea;
        }
        this.sizeAdjustment = stageArea / totalWordsSize;
    }
    
    function calculateWordArea(word) {
        var baseSize = Math.log(word.relativeSize * 10) * Math.LOG10E; // take the relativeSize (0.1 to 1.0), multiply by 10, then get the base-10 log of it
        var height = (baseSize + word.relativeSize) / 2; // find the average between relativeSize and the log
        var width = 0; //(baseSize / 1.5) * word.text.length;
        for (var i = 0; i < word.text.length; i++ ) {
            var letter = word.text.charAt(i);
            if (letter == 'f' || letter == 'i' || letter == 'j' || letter == 'l' || letter == 'r' || letter == 't') width += baseSize / 3;
            else if (letter == 'm' || letter == 'w') width += baseSize / (4 / 3);
            else width += baseSize / 1.9;
        }
        var wordArea = height * width;
        return wordArea;
    }
    
    // based on post from http://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas
    // not really working yet
    function measureTextHeight(label) {
        app.context.fillStyle = 'rgb(255,255,255)';
        app.context.fillRect(label.x, label.y, label.width, label.height);
        label.draw(app.context);
        var imageData = app.context.getImageData(label.x, label.y, label.width, label.height);
        var first = false;
        var last = false;
        var y = label.height;
        var x = 0;
        while (!last && y) {
            y--;
            for (x = 0; x < label.width; x++) {
                var pixel = getPixel(x, y, imageData);
                if (pixel[0] != 255 || pixel[1] != 255 || pixel[2] != 255) {
                    last = y;
                    break;
                }
            }
        }
        while (y) {
            y--;
            for (x = 0; x < label.width; x++) {
                var pixel = getPixel(x, y, imageData);
                if (pixel[0] != 255 || pixel[1] != 255 || pixel[2] != 255) {
                    first = y;
                    break;
                }
            }
            if (first != y) {
                return last - first;
            }
        }
        return 0;
    }
    
    function measureDimensions(word) {
        app.context.save();
        app.context.textBaseline = 'alphabetic';
        app.context.font = word.fontSize + 'px '+ word.fontFamily;
        word.width = app.context.measureText(word.text).width;
        word.height = Math.ceil(app.context.measureText('m').width * 1.15); // initial estimate (make it bigger for when we actually measure the height)
        app.context.restore();
    }
    
    // returns an array [r, g, b, a]
    function getPixel(x, y, imageData) {
        var index = (x + y * imageData.width) * 4;
        return [imageData.data[index], imageData.data[index+1], imageData.data[index+2], imageData.data[index+3]];
    }
    
    function setPixel(imageData, x, y, r, g, b, a) {
        var index = (x + y * imageData.width) * 4;
        imageData.data[index] = r;
        imageData.data[index+1] = g;
        imageData.data[index+2] = b;
        imageData.data[index+3] = a;
    }
    
    function findNewRelativeSize(word, areaMultiplier) {
        var area = calculateWordArea(word) * areaMultiplier;
        // given the area = (x+6)*(2*x/3*y), solve for x
        var newRelativeSize = (Math.sqrt(6) * Math.sqrt(6 * Math.pow(word.text.length, 2) + area * word.text.length) - 6 * word.text.length) / (2 * word.text.length);
        return newRelativeSize;
    }
    
    /**
     * Determines the relative size for each word.
     * Call after all/new words are added and before createAllGraphics.
     */
    this.setRelativeSizes = function() {
    	for (var i = 0; i < _words.length; i++) {
            var word = _words[i];
            word.relativeSize = mapValue(word.origSize, this.smallestWordSize, this.largestWordSize, 0.1, 1);
        }
    }
    
    /**
     * Re-adds words using new adjusted sizes.
     * Run after the largestWordSize and/or smallestWordSize have changed.
     * Need to run manually, since it's intensive.
     */
    this.resizeWords = function() {
        app.clear();
        createAllGraphics();
        sortWords();
    }
    
    /**
     * Sort the word list by size, largest first.
     */
    function sortWords() {
        _words.sort(function(a, b) {
            if (a.origSize > b.origSize) return -1;
            else if (a.origSize < b.origSize) return 1;
            else return 0;
        });
    }
    
    /**
     * Creates the Label that gets displayed on the stage.
     * Randomly selects an angle from possible values.
     * Calculates the mask of the word (used in hit detection).
     * @param	wordObj
     */

    function createWordGraphics(wordObj) {
        var adjustedSize = findNewRelativeSize(wordObj, that.sizeAdjustment);
        wordObj.fontSize = adjustedSize > that.minFontSize ? adjustedSize : that.minFontSize;
        wordObj.fontFamily = myFont;
        
        measureDimensions(wordObj);
        // these values are needed for accurate x and y co-ordinates after rotating the word
        wordObj.tx = 0;
        wordObj.ty = wordObj.height;
        //~ var trueHeight = measureTextHeight(wordObj);
        //~ console.log(wordObj.height, trueHeight);
        //~ wordObj.height = trueHeight;
        
        var angle = 0;
        
        if (that.getWordOrientation() === that.MIXED) {
	        if (wordObj.text.match(/\s/) == null) {
				if (Math.random() > 0.66) {
					var tempHeight = wordObj.height;
					var tempWidth = wordObj.width;
					wordObj.height = tempWidth;
					wordObj.width = tempHeight;
					if (Math.round(Math.random()) == 0) {
						angle = 90;
						wordObj.ty = 0;
					} else {
						angle = -90;
						wordObj.ty = wordObj.height;
						wordObj.tx = wordObj.width;
					}
				}
			}
        }
        
        

        wordObj.size = Math.max(wordObj.height, wordObj.width);
        wordObj.rotation = degreesToRadians(angle);
        
        // find the pixels that aren't transparent and store them as the mask
        app.context.fillStyle = app.canvas.style.backgroundColor;
        app.context.fillRect(0, 0, app.canvas.width, app.canvas.height);
        wordObj.draw(app.context);
        var imageData = app.context.getImageData(wordObj.x, wordObj.y, wordObj.width, wordObj.height);
        var mask = new Array();
        for (var x = 0; x < wordObj.width; x++) {
            var xm = Math.floor(x / that.COARSENESS) * that.COARSENESS;
            if (mask[xm] == null) mask[xm] = {};
            for (var y = 0; y < wordObj.height; y++) {
                var ym = Math.floor(y / that.COARSENESS) * that.COARSENESS;
                var pixel = getPixel(x, y, imageData);
                var pixelColor = 'rgb('+pixel[0]+', '+pixel[1]+', '+pixel[2]+')';
                if (pixelColor != app.canvas.style.backgroundColor) {
                    mask[xm][ym] = true;
                }
                if (mask[xm][ym]) {
                    y = ym + that.COARSENESS; // there's a match, so skip ahead
                    continue;
                }
            }
        }
        wordObj.mask = mask;
    }
    
    /**
     * Helper method which runs createWordGraphics for all the words.
     */
    function createAllGraphics() {
    	for (var i = 0; i < _words.length; i++) {
            createWordGraphics(_words[i]);
        }
    }
    
    /**
     * Arrange the words on the stage using the chosen layout scheme.
     */
    this.arrangeWords = function() {
//    	console.profile();
        clearTimeout(timer);
        app.clear(); // reset canvas
        
        this.toggleLoadingText();

        if (_words.length > 0) {
            
            this.grid = [];
            timer_i = 0; // used as the increment for the word list
      
            function doArrange() {                
                // common variables between the layout schemes
                var x;
                var y;
                var word;
                var breakOut;
                var fail;
                var wordCount = this.wordsToArrange - 1;
                var appCanvasWidth = app.canvas.width;
                var appCanvasHeight = app.canvas.height;
                var halfWidth = appCanvasWidth * 0.5;
                var halfHeight = appCanvasHeight * 0.5;
                var dd = 0.05;

                do {
                    word = _words[timer_i];
                    if (word !== undefined) {
	                    var a = Math.random() * Math.PI; // angle?
	                    var d = Math.random() * (word.size * 0.25); // diameter?
	                    var da = (Math.random() - 0.5) * 0.5;
	                    var halfWordWidth = word.width * 0.5;
	                    var halfWordHeight = word.height * 0.5;
	
	                    while (true) {
	                        x = Math.floor((halfWidth + (Math.cos(a) * d * this.ratio) - halfWordWidth) / this.COARSENESS) * this.COARSENESS;
	                        y = Math.floor((halfHeight + (Math.sin(a) * d) - halfWordHeight) / this.COARSENESS) * this.COARSENESS;
	
	                        fail = false;
	                        if (x + halfWordWidth >= appCanvasWidth || y + halfWordHeight >= appCanvasHeight) {
	                            fail = true;
	                        } else {
	                        	fail = hitTest(x, y, word.height, word.width, word.mask);
	                        }
	                        if (!fail) {
	                            break;
	                        }
	                        a += da;
	                        d += dd;
	                    }
	
	                    finalizeWord(x, y, word);
	                    if (app.useFadeEffect) {
	                    	word.alpha = 0;
		                    for (var w = 0; w < timer_i; w++) {
		                        var wrd = _words[w];
		                        if (wrd.alpha < 1) fadeWord(wrd);
		                    }
	                    } else {
	                    	word.alpha = 1;
	                    	word.draw(app.context);
	                    }
                    }
                    timer_i++;
                    if (timer_i >= _words.length) {
                        clearTimeout(timer);
//                        console.profileEnd();
                        this.doingArrange = false;
                        
                        this.toggleLoadingText(false);                               
                        
                        drawWords();
                        
                        break;
                    }
                } while (wordCount--);
            }
            
            /**
             * Test the mask of a word against the overall grid to see if they intersect.
             * @param	x
             * @param	y
             * @param	h
             * @param	w
             * @param	mask
             * @return
             */
            function hitTest(x, y, h, w, mask) {
                for (var xt = 0; xt <= w; xt += this.COARSENESS) {
                    for (var yt = 0; yt <= h; yt += this.COARSENESS) {
                        if (mask[xt] && mask[xt][yt] && this.grid[xt + x] != null && this.grid[xt + x][yt + y] != null) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            /**
             * Set the new position of the word, and make it visible.
             * @param	x
             * @param	y
             * @param	word
             * @param   drawIt
             */
            function finalizeWord(x, y, word, drawIt) {
                set_grid(x, y, word);

                word.x = x;
                word.y = y;

                word.live = true;
                if (drawIt) {
                	/*
                    if ($.browser.webkit) {
                        // cover the canvas with a transparent rectangle
                        // forces webkit to show the words
                        app.context.fillStyle = 'rgba(0,0,0,0)';
                        app.context.fillRect(0, 0, app.canvas.width, app.canvas.height);
                    }
                    */
                    word.draw(app.context);
                }
            }
            
            function fadeWord(word) {
                word.alpha += 0.25;
//                if ($.browser.webkit) {
                    // cover the canvas with a transparent rectangle
                    // forces webkit to show the words
//                    app.context.fillStyle = 'rgba(0,0,0,0)';
//                    app.context.fillRect(0, 0, app.canvas.width, app.canvas.height);
//               }
                word.draw(app.context);
            }

            /**
             * Mark the spots on the grid where the word is located.
             * @param	x
             * @param	y
             * @param	word
             */
            function set_grid(x, y, word) {
                for (var xt = 0; xt < word.width; xt += this.COARSENESS) {
                    for (var yt = 0; yt < word.height; yt += this.COARSENESS) {
                        if (word.mask[xt] && word.mask[xt][yt]) {
                            if (!this.grid[xt + x]) this.grid[xt + x] = [];
                            this.grid[xt + x][yt + y] = word;
                        }
                    }
                }
            }
            
            doArrange = doArrange.createDelegate(this);
            hitTest = hitTest.createDelegate(this);
            finalizeWord = finalizeWord.createDelegate(this);
            fadeWord = fadeWord.createDelegate(this);
            set_grid = set_grid.createDelegate(this);
            this.doingArrange = true;
            
//            if ($.browser.mozilla) {
//                // FF needs more time to perform each layout run
//                timer = setInterval(doArrange, 250);
//            } else {
                timer = setInterval(doArrange, 50);
//            }
            
        } else {
            alert("Error: There are no words to arrange.");
        }
    }
    
    this.toggleLoadingText = function(show) {
        app.context.save();
        
        if (show) app.context.fillStyle = 'black';
        else app.context.fillStyle = app.canvas.style.backgroundColor;
        
        app.context.textBaseline = 'top';
        app.context.font = '10px Arial';
        var offset = app.context.measureText('Loading').width + 10;
        app.context.fillText('Loading', app.canvas.width - offset, 10);
        
        app.context.restore();
    }
    
    this.startUpdates = function() {
    	timer = setInterval(drawWords, that.UPDATE_RATE);
    }
    
    this.stopUpdates = function() {
    	if (overWord != null) {
	    	// remove existing tooltip
	    	overWord = null;
	    	drawWords();
    	}
    	clearTimeout(timer);
    }
    
    function drawWords() {
        app.clear();
        var i = _words.length;
        while(i--) {
        	var word = _words[i];
            word.alpha = 1;
            if (word.live) word.draw(app.context);
        }
        var $canvasEl = $(app.canvas);
        if (overWord != null) {
        	// add pointer cursor
        	$canvasEl.css('cursor', 'pointer');
        	
            // draw the tooltip
            app.context.save();
            app.context.textBaseline = 'alphabetic';
            app.context.font = '12px Arial';
            
            var wordWidth = app.context.measureText(overWord.text).width;
            var valueWidth = app.context.measureText(overWord.value).width;
            var maxWidth = wordWidth > valueWidth ? wordWidth : valueWidth;
            maxWidth += 20;
            
            var x = overX + 15;
            var y = overY + 25;
            var appWidth = $canvasEl.width();
            var appHeight = $canvasEl.height();
            if (x + maxWidth >= appWidth) {
            	x -= maxWidth;
            }
            if (y + 40 >= appHeight) {
            	y -= 40;
            }
            
            app.context.fillStyle = 'rgba(255,255,255,0.9)';
            app.context.strokeStyle = 'rgba(100,100,100,0.9)';
            app.context.translate(x, y);
            app.context.fillRect(0, 0, maxWidth, 40);
            app.context.strokeRect(0, 0, maxWidth, 40);
            app.context.fillStyle = 'rgba(0,0,0,0.9)';
            app.context.fillText(overWord.text+':', 8, 18);
            app.context.fillText(overWord.value, 8, 30);
            app.context.restore();
        } else {
        	$canvasEl.css('cursor', 'default');
        }
    }
    
    /**
     * Checks to see if the mouse is currently over a word.
     * @param	event
     */
    this.handleMouseMove = function(event) {
        if (!this.doingArrange) {
        	var i = _words.length;
            while(i--) {
                _words[i].isOver = false;
            }
            var offset = $(app.canvas).offset();
            var remainder = (event.pageX - offset.left) % this.COARSENESS;
            var x = (event.pageX - offset.left) - remainder;
            remainder = (event.pageY - offset.top) % this.COARSENESS;
            var y = (event.pageY - offset.top) - remainder;
            overWord = this.findWordByCoords(x, y);
            if (overWord != null) {
                overWord.isOver = true;
                overX = x;
                overY = y;
            }
        }
    }
    
    /**
     * Checks to see if a word was clicked on, and then sends out the corresponding event.
     * @param	event
     * @return
     */
    this.handleWordClick = function(event) {
        var offset = $(app.canvas).offset();
        var remainder = (event.pageX - offset.left) % this.COARSENESS;
        var x = (event.pageX - offset.left) - remainder;
        remainder = (event.pageY - offset.top) % this.COARSENESS;
        var y = (event.pageY - offset.top) - remainder;
        var matchingWord = this.findWordByCoords(x, y);
        
        if (matchingWord != null) {
            return {text: matchingWord.text, value: matchingWord.value};
        }
    }
    
    /**
     * Returns the word which occupies the co-ordinates that were passed in.
     * @param	x
     * @param	y
     * @return
     */
    this.findWordByCoords = function(x, y) {
        var matchingWord = null;
        if (this.grid[x] !=  null) {
            if (this.grid[x][y] != null) {
                matchingWord = this.grid[x][y];
            } else if (this.grid[x][y + this.COARSENESS] != null) {
                matchingWord = this.grid[x][y + this.COARSENESS];
            }
        }
        if (matchingWord == null && this.grid[x + this.COARSENESS] != null) {
            if (this.grid[x + this.COARSENESS][y] != null) {
                matchingWord = this.grid[x + this.COARSENESS][y];
            } else if (this.grid [x + this.COARSENESS][y + this.COARSENESS] != null) {
                matchingWord = this.grid[x + this.COARSENESS][y + this.COARSENESS];
            }
        }
        
        return matchingWord;
    }
    
    /**
     * Convert an angle in degrees to radians.
     * @param	degrees
     * @return
     */
    function degreesToRadians(degrees) {
        var radians = degrees * (Math.PI / 180);
        return radians;
    }
    
    /**
     * Convenience function to map a variable from one coordinate space to another (from processing).
     */
    function mapValue(value, istart, istop, ostart, ostop) {
        return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
    }
    
}

// from Ext
Function.prototype.createDelegate = function(obj, args, appendArgs){
    var method = this;
    return function() {
        var callArgs = args || arguments;
        if (appendArgs === true){
            callArgs = Array.prototype.slice.call(arguments, 0);
            callArgs = callArgs.concat(args);
        }else if (typeof appendArgs=="number"){
            callArgs = Array.prototype.slice.call(arguments, 0); // copy arguments first
            var applyArgs = [appendArgs, 0].concat(args); // create method call params
            Array.prototype.splice.apply(callArgs, applyArgs); // splice them in
        }
        return method.apply(obj || window, callArgs);
    };
}
/**
 * Voyant changes & additions:
 * - height setter, height no longer calculated based on content
 * - replaced tree.size with tree.nodeSize
 * - pointer cursor for node
 * - rect now behind text, made opaque to block paths obscuring text
 * - branch length based on text length on per node basis
 * - click handler
 * - zoom fixes
 * - redraw checks for tries before re-running setup
 * - prevent negative height error
 */

/*
 * (This is the new BSD license.) Copyright (c) 2012-2014, Chris Culy All rights
 * reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. * Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution. * Neither the name of the Chris Culy nor the names of
 * its contributors may be used to endorse or promote products from this
 * software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY Chris Culy ``AS IS'' AND ANY OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL Chris Culy BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
/**
 * @namespace doubletree All of the functionality is in the doubletree namespace
 */
var doubletree = {};

(function() {

// TBD what about visWidth? to be fixed visWidth is really width and width
// is really just the width of one side of the doubletree

/**
 * @class doubletree.DoubleTree This is the class for the DoubleTree
 *        visualization
 */
doubletree.DoubleTree = function() {
	var containers = []; // nominally for allowing the same tree in
							// multiple places, but not tested and probably
							// doesn't work right (e.g. for search)
	// defaults. see below for getter/setters
	var visWidth = 600;
	var visHt = 400; // calculated, not settable
	var prefixesOnRight = false; // true for right to left writing systems
	var filters = {
		"left" : [],
		"right" : []
	};
	var handlers = {
		"alt" : noOp,
		"shift" : noOp,
		"click" : noOp
	};
	var showTokenExtra = true;
	var scaleLabels = true;
	var sortFun = doubletree.sortByStrFld("token");
	var nodeText = doubletree.tokenText; // default
	var tokenExtraText = function(info) {
		return doubletree.fieldText(info, "POS");
	};
	var rectColor = function(info) {
		return "rgba(255,255,255,1)";
	};
	var rectBorderColor = function(info) {
		return "rgba(255,255,255,1)";
	};
	var continuationColor = function(info) {
		return "red";
	};
	var basicStyles = {
		"node" : {
			"fill" : "white",
			"stroke" : "steelblue",
			"stroke-width" : "1.5px"
		},
		"branch" : {
			"stroke" : "#aaa",
			"stroke-width" : "1.5px"
		}
	};

	var succeeded = false; // did we succeed in building a DoubleTree? we
							// need this flag, since we no longer return
							// true/false from setupFromX (since we do
							// chaining)

	var dispatch = d3.dispatch("idsUpdated");
	dispatch.on("idsUpdated", function() {
		if (this == leftTree) {
			rtTree.setIds(leftTree.continuationIDs);
			rtTree.updateContinuations();
		} else if (this == rtTree) {
			leftTree.setIds(rtTree.continuationIDs);
			leftTree.updateContinuations();
		}
	});

	var leftTrie, rtTrie, leftTree, rtTree;
	var visibleIDs; // the ids of the results that are showing

	// tmp, until we can do sizing right. the font sizes are specified in
	// doubletree.css and manually copied here
	var kFontSize = 14; // normal
	var kBigFontSize = 1.15 * kFontSize; // for found text and
											// continuations (was 18) NB:
											// this is 0.05 bigger than in
											// doubletree.css
	var kMinFontSize = 8; // smallest that we'll scale to
	var textScale;

	/** @exports mine as doubletree.DoubleTree */
	/** @ignore */
	function mine(selection) {
		// generate container and data independent part of chart here, using
		// `width` and `height` etc

		selection.each(function(d, i) {
			// generate chart here; `d` is the data and `this` is the
			// element
			// really, storing containers. Use updateData and redraw to
			// really do the generation
			containers.push(this.node());
		});

	}

	/**
	 * initialize the visualization in one or more html containers
	 * <p>
	 * 
	 * @param containerPattern
	 *            CSS selector for the containers
	 */
	mine.init = function(containerPattern) {
		d3.select(d3.selectAll(containerPattern)).call(this);
		return mine;
	};

	/**
	 * redraw the visualization
	 */
	mine.redraw = function() {
		if (leftTrie !== undefined && rtTrie !== undefined) {
			mine.setupFromTries(leftTrie, rtTrie);
		}

		return mine;
	};

	/**
	 * set up the visualization using 2 {@link doubletree.Trie}s
	 * 
	 * @param leftOne
	 *            the left {@link doubletree.Trie}
	 * @param rtOne
	 *            the right {@link doubletree.Trie}
	 */
	mine.setupFromTries = function(leftOne, rtOne) {
		leftTrie = leftOne.getUniqRoot();
		rtTrie = rtOne.getUniqRoot();

		var leftTrieTree = leftTrie.toTree(filters.left);
		var rtTrieTree = rtTrie.toTree(filters.right);

		var copyIDs = true;
		if (Object.keys(rtTrieTree.pruned).length > 0) {
			new_pruneTree(rtTrieTree, rtTrieTree.pruned, copyIDs);
			new_pruneTree(leftTrieTree, rtTrieTree.pruned, copyIDs);
			copyIDs = false;
		}

		if (Object.keys(leftTrieTree.pruned).length > 0) {
			new_pruneTree(leftTrieTree, leftTrieTree.pruned, copyIDs);
			new_pruneTree(rtTrieTree, leftTrieTree.pruned, copyIDs);
		}

		// combine the info's from the two trees
		var newInfo = {}; // rtTrieTree.info;

		for ( var k in rtTrieTree.info) {
			if (k != "continuations" && k != "ids" && k != "count") {
				newInfo[k] = rtTrieTree.info[k];
			}
		}

		newInfo["right continuations"] = rtTrieTree.info.continuations;
		newInfo["left continuations"] = leftTrieTree.info.continuations;

		newInfo.ids = {};
		addTo(newInfo.ids, rtTrieTree.info.ids);
		addTo(newInfo.ids, leftTrieTree.info.ids);
		newInfo.count = Object.keys(newInfo.ids).length;
		visibleIDs = Object.keys(newInfo.ids);

		if (rtTrieTree.info.origIDs || leftTrieTree.info.origIDs) {
			newInfo.origIDs = {};
			addTo(newInfo.origIDs, rtTrieTree.info.origIDs);
			addTo(newInfo.origIDs, leftTrieTree.info.origIDs);
			newInfo.origCount = Object.keys(newInfo.origIDs).length;
		}

		rtTrieTree.info = newInfo;
		leftTrieTree.info = newInfo;

		var maxChildren = Math.max(leftTrieTree.maxChildren,
				rtTrieTree.maxChildren);
		if (isNaN(maxChildren) || maxChildren == 0) {
			succeeded = false;
			return mine;
		}

		if (scaleLabels) {
			textScale = d3.scaleLog().range([ kMinFontSize, kFontSize ]);
		} else {
			textScale = function() {
				return kFontSize;
			};
			textScale.domain = function() {
			};
		}

		var minCount = Math.min(leftTrieTree.minCount, rtTrieTree.minCount);
		textScale.domain([ minCount, leftTrieTree.info.count ]);

		// TBD ?? margin, width, height, duplicated in Tree
		var margin = {
			top : 20,
			right : 20,
			bottom : 20,
			left : 20
		};
		var width = visWidth - margin.right - margin.left;
		var height = visHt - margin.top - margin.bottom;

		containers.forEach(function(d, i) {
			var thisContainer = d;
			var thisVis;

			var tmp = d3.select(thisContainer).select("svg");
			if (tmp.node() == null) {
				thisVis = d3.select(thisContainer).append("svg")
					.attr("width", width + margin.right + margin.left)
					.attr("height", height + margin.top + margin.bottom)
					.attr("cursor", "move")
					.call(d3.zoom().scaleExtent([1,1]).on('zoom', function() {
						var x = d3.event.transform.x + width/2; // need offset because of initial offset in g element
						var y = d3.event.transform.y + height/2;
						d3.select(thisContainer).select("svg > g").attr("transform", 'translate('+x+','+y+')');
					}));

				thisVis.append("g") // container for both trees
					.attr('transform', 'translate('+width/2+','+height/2+')'); // initial offset

			} else {
				thisVis = tmp;
				thisVis
					.attr("width", width + margin.right + margin.left)
					.attr("height", height + margin.top + margin.bottom);
				thisVis.selectAll("g *").remove(); // clear
													// previous
			}

			leftTree = new doubletree.Tree(thisVis.select("g"),
					visWidth, visHt, leftTrieTree, true,
					sortFun, dispatch, textScale, showTokenExtra,
					nodeText, tokenExtraText, rectColor,
					rectBorderColor, continuationColor, basicStyles);
			rtTree = new doubletree.Tree(thisVis.select("g"),
					visWidth, visHt, rtTrieTree, false,
					sortFun, dispatch, textScale, showTokenExtra,
					nodeText, tokenExtraText, rectColor,
					rectBorderColor, continuationColor, basicStyles);
		});

		leftTree.handleAltPress = handlers.alt;
		rtTree.handleAltPress = handlers.alt;

		leftTree.handleShiftPress = handlers.shift;
		rtTree.handleShiftPress = handlers.shift;
		
		leftTree.handleClick = handlers.click;
		rtTree.handleClick = handlers.click;

		succeeded = true;
		return mine;
	};

	// hitArray is an array of items, prefixArray and suffixArray are arrays
	// of arrays of items
	/**
	 * set up the visualization from arrays corresponding to the hit, the
	 * prefix, and the suffix of a key word in context result.
	 * <p>
	 * The ith elements should correspond with each other. Each item
	 * consists of fields separated by a field delimiter. For example we
	 * might have word/tag (with / as the delimiter) or word\tlemma\tauthor
	 * (with tab (\t) as the delimiter) Only certain fields are relevant for
	 * deciding whether two items are to be considered the same (e.g. we
	 * might ignore an author field)
	 * 
	 * @param prefixArray
	 *            the array of arrays of the prefixes of the hits
	 * @param hitArray
	 *            the array of the hits
	 * @param suffixArray
	 *            the array of arrays of the suffixes of the hits
	 * @param idArray
	 *            the array of ids of the hits (or null, if there are no ids
	 *            for the hits)
	 * @param caseSensitive
	 *            are the hits case sensitive
	 * @param fieldNames
	 *            the names of the fields
	 * @param fieldDelim
	 *            the field delimiter
	 * @param distinguishingFieldsArray
	 *            the fields that determine identity
	 * @param prefixesOnRight
	 *            display the prefixes on the right, for right-to-left
	 *            writing systems. Default is false
	 */
	mine.setupFromArrays = function(prefixArray, hitArray, suffixArray, idArray, caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray) {

		if (undefined == caseSensitive && leftTrie) {
			caseSensitive = leftTrie.caseSensitive();
		}
		if (undefined == fieldNames && leftTrie) {
			fieldNames = leftTrie.fieldNames();
		}
		if (undefined == fieldDelim && leftTrie) {
			fieldDelim = leftTrie.fieldDelim();
		}
		if (undefined == distinguishingFieldsArray && leftTrie) {
			distinguishingFieldsArray = leftTrie.distinguishingFieldsArray();
		}

		leftTrie = new doubletree.Trie(caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);
		rtTrie = new doubletree.Trie(caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);

		var n = hitArray.length;
		for ( var i = 0; i < n; i++) {
			var thisID = idArray ? idArray[i] : i;
			var thisHit = hitArray[i];
			var thesePrefixes = prefixArray[i].slice();
			var theseSuffixes = suffixArray[i].slice();

			thesePrefixes.push(thisHit);
			thesePrefixes.reverse();
			theseSuffixes.unshift(thisHit);

			/*
			 * if (prefixesOnRight) { //e.g. for Arabic, Hebrew, N'Ko, ...
			 * thesePrefixes.push(thisHit); thesePrefixes.reverse();
			 * 
			 * rtTrie.addNgram( thesePrefixes, thisID);
			 * 
			 * theseSuffixes.unshift(thisHit); leftTrie.addNgram(
			 * theseSuffixes, thisID);
			 *  } else { thesePrefixes.push(thisHit);
			 * thesePrefixes.reverse(); leftTrie.addNgram( thesePrefixes,
			 * thisID);
			 * 
			 * theseSuffixes.unshift(thisHit); rtTrie.addNgram(
			 * theseSuffixes, thisID); }
			 */

			if (prefixesOnRight) {
				rtTrie.addNgram(thesePrefixes, thisID);
				leftTrie.addNgram(theseSuffixes, thisID);
			} else {
				leftTrie.addNgram(thesePrefixes, thisID);
				rtTrie.addNgram(theseSuffixes, thisID);
			}
		}

		mine.setupFromTries(leftTrie, rtTrie);
		return mine;
	};

	/**
	 * @returns just the <em>ids</em> of the data that satisfies the
	 *          current filters
	 */
	mine.filteredIDs = function() {
		return visibleIDs;
	};

	// return how many found
	/**
	 * search the nodes of the visualization for a pattern
	 * <p>
	 * The found nodes will get the CSS class foundText
	 * 
	 * @param searchRE
	 *            the regular expression to look for
	 * @returns how many nodes were found
	 */
	mine.search = function(searchRE) {
		leftTree.search(searchRE);
		rtTree.search(searchRE);

		var thisVis = d3.select(containers[0]);
		var found = thisVis.selectAll("text.foundText");

		if (found.empty()) {
			return 0;
		}

		var what = found[0].length;

		var foundRt = thisVis.selectAll("text.rtNdText.foundText");

		if (foundRt.node() != null) {
			what--; // root node, and we have 2 of those, so subtract one
					// from the count
		}
		return what;
	};

	/**
	 * clear the visualization of the search results
	 * <p>
	 * the CSS class foundText is removed
	 */
	mine.clearSearch = function() {
		leftTree.clearSearch();
		rtTree.clearSearch();
		return mine;
	};

	/**
	 * update the showing/hiding of extra information associated with the
	 * basic item, e.g. part of speech information
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>This <em>DOES</em> redraw the visualization.</li>
	 * <li>Safari does not update the visualization correctly by itself, so
	 * we force it to rebuild the entire visualization, unlike in other
	 * browsers.</li>
	 * </ul>
	 */
	mine.updateTokenExtras = function() {
		leftTree.showTokenExtras(showTokenExtra);
		rtTree.showTokenExtras(showTokenExtra);

		// Safari doesn't update reshowing correctly, so we'll force it to
		// build this again :( (Chrome works correctly, so it's not a webkit
		// issue)
		var thisVis = d3.select(containers[0]);
		var tokExtra = thisVis.select('.tokenExtra[display="inline"]');
		if (!tokExtra.empty()) {
			var ht = tokExtra.style("height");
			if (ht == "0px") {
				mine.redraw();
			}
		}

		return mine;
	};

	// ////////// getter/setters
	/**
	 * Getter/setter for the maximum width of the DoubleTree area
	 * 
	 * @param value
	 *            the maximum width
	 */
	mine.visWidth = function(value) {
		if (!arguments.length)
			return visWidth;
		visWidth = value;
		return mine;
	};

	// ADDED
	mine.visHeight = function(value) {
		if (!arguments.length)
			return visHt;
		visHt = value;
		return mine;
	};

	/**
	 * Getter/setter for whether the prefixes are displayed on the right or
	 * the left.
	 * <p>
	 * The default value is false, i.e. the prefixes are displayed on the
	 * left, as in English. <em>prefixesOnRight</em> should be set to true
	 * for right-to-left writing systems such as Arabic, Hebrew, N'Ko, etc.
	 * 
	 * @param value
	 *            true or false
	 */
	mine.prefixesOnRight = function(value) {
		if (!arguments.length)
			return prefixesOnRight;
		prefixesOnRight = value;
		return mine;
	};

	// NB: doesn't redraw
	/**
	 * Getter/setter for the filter functions.
	 * <p>
	 * The filter functions get an information object as their argument, and
	 * return true/false. Each position away from the root has its own
	 * filter, and the left and right sides also have their own filters. The
	 * filters are specified via an object with "left" and "right" keys
	 * whose values are arrays of functions The function at index <em>i</em>
	 * filters position <em>i + 1</em> away from the root. Default is no
	 * filtering (via empty arrays)
	 * <p>
	 * Note: setting the filters does <em>not</em> redraw the
	 * visualization. See {@link #redraw}
	 * 
	 * @param value
	 *            an object containing the filters
	 */
	mine.filters = function(value) {
		if (!arguments.length)
			return filters;
		filters = value;
		return mine;
	};

	/**
	 * Getter/setter for the handlers for alt-click and shift-click on the
	 * nodes.
	 * <p>
	 * The handlers get an information object as their argument. The
	 * handlers are specified via an object with "alt" and "shift" keys
	 * whose values are functions The default is no handlers, i.e.
	 * <em>NO</em> interaction
	 * 
	 * @param value
	 *            an object containing the handlers
	 */
	mine.handlers = function(value) {
		if (!arguments.length)
			return handlers;
		handlers = value;
		return mine;
	};

	// NB: doesn't redraw
	/**
	 * Getter/setter for showing/hiding extra information associated with
	 * the main value, e.g. part of speech information.
	 * <p>
	 * Note: setting this value does <em>not</em> redraw the
	 * visualization. See {@link #redraw} Default is true
	 * 
	 * @param value
	 *            a boolean specifying whether to show the information or
	 *            not
	 */
	mine.showTokenExtra = function(value) {
		if (!arguments.length)
			return showTokenExtra;
		showTokenExtra = value;
		return mine;
	};

	/**
	 * Getter/setter for scaling the node labels by their frequency.
	 * <p>
	 * Default is true
	 * 
	 * @param value
	 *            a boolean specifying whether to scale the labels or not
	 */
	mine.scaleLabels = function(value) {
		if (!arguments.length)
			return scaleLabels;
		scaleLabels = value;
		return mine;
	};

	// succeeded is read only
	/**
	 * Reports whether the DoubleTree was constructed successfully
	 * <p>
	 * 
	 * @returns true if the DoubleTree was constructed successfully and
	 *          false otherwise
	 */
	mine.succeeded = function() {
		return succeeded;
	};

	/**
	 * Getter/setter for the function determining the sort order of sibling
	 * nodes.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return -1 for precedes, 1 for follows and 0 for don't care The nodes
	 * are displayed in "preceding" (i.e. ascending) order, from top to
	 * bottom. The default is alphabetical by a "token" field if there is
	 * one: doubletree.sortByStrFld("token")
	 * 
	 * @param the
	 *            sort order function
	 */
	mine.sortFun = function(value) {
		if (!arguments.length)
			return sortFun;
		sortFun = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the content of the node
	 * labels.
	 * <p>
	 * The function gets an information object as its first argument and a
	 * boolean indicating whether the node is the root or not as its second
	 * argument. The function should return a string. The default is
	 * {@link #tokenText}
	 * 
	 * @param the
	 *            content function
	 */
	mine.nodeText = function(value) {
		if (!arguments.length)
			return nodeText;
		nodeText = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the content of the "extra"
	 * information for the labels labels
	 * <p>
	 * The function gets an information object as its first argument and a
	 * boolean indicating whether the node is the root or not as its second
	 * argument. The function should return a string. The default is the POS
	 * field of the information object
	 * 
	 * @param the
	 *            content function
	 */
	mine.tokenExtraText = function(value) {
		if (!arguments.length)
			return tokenExtraText;
		tokenExtraText = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the color of the
	 * background rectangles for the nodes.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return a CSS color in a string, e.g. "rgba(255,128,0,0.5)" The
	 * default is transparent white (i.e., effectively no color);
	 * 
	 * @param value
	 *            the background color function
	 */
	mine.rectColor = function(value) {
		if (!arguments.length)
			return rectColor;
		rectColor = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the color of the borders
	 * of the background rectangles for the nodes.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return a CSS color in a string, e.g. "rgba(255,128,0,0.5)" The
	 * default is transparent white (i.e., effectively no color);
	 * 
	 * @param value
	 *            the border color function
	 */
	mine.rectBorderColor = function(value) {
		if (!arguments.length)
			return rectBorderColor;
		rectBorderColor = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the color of the text of
	 * the nodes that are continuations of the clicked node.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return a CSS color in a string, e.g. "rgba(255,128,0,0.5)" The
	 * default is transparent white (i.e., effectively no color);
	 * 
	 * @param value
	 *            the border color function
	 */
	mine.continuationColor = function(value) {
		if (!arguments.length)
			return continuationColor;
		continuationColor = value;
		return mine;
	};

	/**
	 * Getter/setter for the styles of the nodes and branches. For now these
	 * are constant throughout the tree. Takes an object of the form:
	 * {"node":{"fill":cssColor, "stroke":cssColor,
	 * "stroke-width":cssWidth}, "branch":{"stroke":cssColor,
	 * "stroke-width":cssWidth}} All of the attributes are optional Defaults
	 * are: {"node":{"fill":"white", "stroke":"steelblue",
	 * "stroke-width":"1.5px"}, "branch":{"stroke":"#777",
	 * "stroke-width":"1.5px"}};
	 */
	mine.basicStyles = function(stylesObj) {
		if (!arguments.length)
			return basicStyles;

		Object.keys(basicStyles).forEach(
			function(aspect) {
				if (aspect in stylesObj) {
					Object.keys(basicStyles[aspect]).forEach(
						function(attr) {
							if (attr in stylesObj[aspect]) {
								basicStyles[aspect][attr] = stylesObj[aspect][attr];
							}
						});
				}
			});
		return mine;
	};

	return mine;
};

// ////// tree for doubletree
/** @private */
doubletree.Tree = function(vis, visWidth, visHt, data, toLeft,
		sortFun, dispatch, textScale, showTokenXtra, nodeTextFun,
		tokenExtraTextFun, rectColorFun, rectBorderFun, contColorFun,
		baseStyles) {
	var showTokenExtra = false || showTokenXtra;
	var continuationIDs = {};
	var clickedNode;
	var nodeText = nodeTextFun;
	var tokenExtraText = tokenExtraTextFun;
	var rectColor = rectColorFun;
	var rectBorderColor = rectBorderFun;
	var continuationColor = contColorFun;
	var basicStyles = baseStyles;

	var margin = {
		top : 20,
		right : 20,
		bottom : 20,
		left : 20
	}, width = visWidth - margin.right - margin.left, height = visHt - margin.top - margin.bottom, i = 0, duration = 200, root;
	var dx;

	if (!sortFun) {
		sortFun = doubletree.sortByStrFld("token");
	}

	var i = 0;
	var tree = d3.tree()
	.size([height, width])
	.nodeSize([ 40, 40 ]);
	//.sort(sortFun);

	var diagonal = d3.linkHorizontal()
		.x(function(d) { return positionX(d.y); })
		.y(function(d) { return positionY(d.x); });

	vis = vis.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	// //////
	this.readJSONTree = function(json) {
		root = d3.hierarchy(json);
		root.x0 = 0;
		root.y0 = 0;

		root.children.forEach(collapse);
		this.update(root);
	};

	// CC had been inside readJSONTree
	function collapse(d) {
		if (d.children) {
			d._children = d.children;
			d._children.forEach(collapse);
			d.children = null;
		}
	}

	// CC new
	function collapseSiblings(nd) {
		if (nd.parent) {
			nd.parent.children.forEach(function(d) {
				if (d != nd) {
					collapse(d);
				}
			});
		}
	}

	this.update = function(source) {
		// seems unnecessary
//		if (!source) {
//			source = root;
//		}

		// Compute the new tree layout.
		var treeData = tree(root);
		var nodes = treeData.descendants();

		var baseBranchSegmentWidth = 25;
		// Normalize for fixed-depth.
		nodes.forEach(function(d) {
			var textSize = d.textSize;
			if (textSize == undefined) {
				textSize = 0;
				var parent = d.parent;
				while (parent != null) {
					var measured = Ext.draw.TextMeasurer.measureText(parent.data.name, 'arial').width;
					textSize += measured;
					parent = parent.parent;
				}
				d.textSize = textSize; // cache the size so we don't recalculate each time
			}
			d.y = (d.depth * baseBranchSegmentWidth) + textSize;
		});
		
		
		// Update the nodes
		var node = vis.selectAll("g.node_" + toLeft)
			.data(nodes, function(d) {
				return d.id || (d.id = ++i);
			});

		// Enter any new nodes at the parent's previous position.
		var nodeEnter = node.enter().append("g").attr("class", "node node_" + toLeft).attr("cursor", "pointer")
			.attr("transform", function(d) {
				return "translate(" + positionX(source.y0) + "," + positionY(source.x0) + ")";
			})
			.on("click", click);

		nodeEnter.append("title").text(function(d) {
			var what = doubletree.infoToText(d.data.info);
			return what;
		});

		nodeEnter.append("circle")
			.attr("r", 1e-6)
			.style("fill", function(d) {
				return d._children ? "#fff" : basicStyles.node.fill;
			})
			.style("stroke", function(d) {
				return basicStyles.node.stroke;
			});

		var txtNode = nodeEnter.append("text").attr("class", function(d) {
			if (d.depth == 0) {
				return "rtNdText";
			} else {
				return "";
			}
		}).attr("x", function(d) {
			if (d.children || d._children) {
				return 0;
			} else {
				return toLeft ? 10 : -10;
			}
		}).attr("text-anchor", function(d) {
			if (!d.parent) {
				return "middle";
			}
			if (d.children || d._children) {
				return toLeft ? "end" : "start";
			} else {
				return toLeft ? "start" : "end";
			}
		}).style("font-size", function(d) {
			/*
			 * if (d.depth == 0 && toLeft) { return 0; //suppress left side
			 * root -- do this because of differences in counts when
			 * filtering }
			 */
			return textScale(d.data.info.count) + "pt";
		});

		txtNode.append("tspan").attr("dy", ".35em").attr("class", "tokenText").text(function(d) {
			return nodeText(d.data.info, d.depth < 1);
		}).style("fill-opacity", 1e-6);

		txtNode.append("tspan").attr("dx", ".35em").attr("class", "tokenExtra").text(function(d) {
			return tokenExtraText(d.data.info, d.depth < 1);
		}).style("fill-opacity", 1e-6);

		
		this.drawRects();

		var nodeUpdate = nodeEnter.merge(node);
		
		// Transition nodes to their new position.
		nodeUpdate.transition().duration(duration)
			.attr("transform", function(d) {
				return "translate(" + positionX(d.y) + "," + positionY(d.x) + ")";
			});

		nodeUpdate.select("circle")
			// .attr("r", 4.5)
			.attr("r", function(d) {
				return (d.children || d._children) ? 1e-6 : 4.5;
			})
			.style("fill", function(d) {
				return d._children ? "#fff" : basicStyles.node.fill;
			}) // function(d) { return d._children ? "lightsteelblue" : "#fff";
				// })
			.style("stroke-width", basicStyles.node["stroke-width"]);

		nodeUpdate.selectAll("tspan").style("fill-opacity", 1);

		// Transition exiting nodes to the parent's new position.
		var nodeExit = node.exit().transition().duration(duration).attr("transform", function(d) {
			return "translate(" + positionX(source.y) + "," + positionY(source.x) + ")";
		}).remove();

		nodeExit.select("circle").attr("r", 1e-6);

		// nodeExit.select("text")
		nodeExit.selectAll("tspan").style("fill-opacity", 1e-6);

		// Update the links
		var link = vis.selectAll("path.link_" + toLeft)
			.data(root.links(), function(d) {
				var id = d.source.id+'-'+d.target.id;
				return id;
			});

		// Enter any new links at the parent's previous position.
		var linkEnter = link.enter().insert("path", "g").attr("class", "link link_" + toLeft)
			.attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return diagonal({source: o, target: o});
			})
			.style("fill", "none").style("stroke", basicStyles.branch.stroke).style("stroke-width", basicStyles.branch["stroke-width"]);

		var linkUpdate = linkEnter.merge(link);
		
		// Transition links to their new position.
		linkUpdate.transition().duration(duration).attr("d", diagonal);

		// Transition exiting nodes to the parent's new position.
		var linkExit = link.exit().transition().duration(duration)
			.attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return diagonal({source: o, target: o});
			})
			.remove();

		// Stash the old positions for transition.
		nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
		});

		this.updateContinuations();		
	};
	
	this.drawRects = function() {
		var which = showTokenExtra ? "inline" : "none";
		vis.selectAll(".tokenExtra").attr("display", which);

		var node = vis.selectAll("g.node_" + toLeft);
		
		node.selectAll("rect").remove(); // remove previous rects

		var nodeRect = node
				.insert("rect", "text")
				.attr("class", "nodeRect")
				.attr("height", function() {
					var height = this.parentElement.getBBox().height;
					if (height < 6) {
						// end of branch, need to prevent negative height
						height = 6.1;
					}
					return height - 6;
				})
				.attr("y", function(d) {
					if (!d.parent) {
						return -0.5 * this.parentElement.getBBox().height / 2 - 2;
					} else {
						return -0.5 * this.parentElement.getBBox().height / 2;
					}
				})
				.attr("width", function() {
					return this.parentElement.getBBox().width;
				})
				.attr("x", function(d) {
					var parentW = this.parentElement.getBBox().width;
					if (!d.parent) {
						return -0.33333 * parentW;
					}
					if (!toLeft) {
						return 0;
					}
					return -0.5 * parentW;
				})
				// .style("stroke-opacity", 1e-6)
				.style("stroke-opacity", 1).style("stroke-width", 1)
				.style("stroke", function(d) {
					return rectBorderColor(d.data.info);
				}).style("fill", function(d) {
					return rectColor(d.data.info);
				}).style("fill-opacity", function(d) {
					return 1;
//					if (!d.parent && !toLeft) {
//						return 1e-6;
//					} else {
//						return 1;
//					}
				});
	};

	var that = this;
	
	// Toggle children on click.
	function click(d, i) {
		if (d3.event.altKey) {
			that.handleAltPress(d, i);
			// that.showTokenExtras(showTokenExtra);
			return;
		}
		if (d3.event.shiftKey) {
			that.handleShiftPress(d, i);
			// that.showTokenExtras(showTokenExtra);
			return;
		}

		that.handleClick(d, i);
		
		if (!d.parent) {
			return;
		}
		if (that.continuationIDs != d.data.info.ids) {
			that.setIds(d.data.info.ids);
			that.clickedNode = d.id;
			dispatch.call('idsUpdated', that);
		}

		collapseSiblings(d); // CC new
		/*
		 * if (d.children) { d._children = d.children; d.children = null; }
		 * else { d.children = d._children; d._children = null; }
		 * that.update(d);
		 */
		toggleChildren(d, true);
	}

	function toggleChildren(d, update) { // we only update the clicked
											// node, not recursively
		// collapseSiblings(d); //CC we don't do this here, since after the
		// top level there's no point

		if (d.children) {
			if (d.children && d.children.length == 1) {
				toggleChildren(d.children[0], true); // need true to make
														// sure we toggle
														// all the way down
			}
			d._children = d.children;
			d.children = null;

		} else {
			d.children = d._children;
			d._children = null;

			// expand all if there is only one path
			if (d.children && d.children.length == 1) {
				toggleChildren(d.children[0], false);
			}
		}
		if (update) {
			that.update(d);
		}
	}

	this.setIds = function(ids) {
		that.continuationIDs = ids;
	};
	this.updateContinuations = function() {
		vis.selectAll("g.node_" + toLeft + " text")
			.classed("continuation", function(d) {
					var isContinuation = overlap(d.data.info.ids, that.continuationIDs || {});
					return isContinuation;
			})
			.style("fill", function(d) {
				if (d3.select(this).classed("continuation")) {
					return continuationColor(d.data.info);
				}
				return "#444"; // default text color
			}); // this is duplicated from above, nodeUpdate
	};

	this.search = function(searchRE) {
		vis.selectAll("g.node text").classed("foundText", function(d) {
			var what = searchRE.test(nodeText(d.data.info));
			return what;
		});
	};

	this.clearSearch = function() {
		vis.selectAll("g.node text").classed("foundText", false);
	};

	this.showTokenExtras = function(show) {
		if (arguments.length == 0) {
			return showTokenExtra;
		}
		showTokenExtra = show;

		this.drawRects();
		return this;
	};

	this.setRectColor = function(rectColorFun) {
		if (arguments.length == 0) {
			return rectColor;
		}
		rectColor = rectColorFun;
		this.drawRects();
		return this;
	};

	// /////////////
	function positionX(x) {
		return toLeft ? -x : x;
	}
	function positionY(y) {
		return y;
	}

	// //default modifier handlers
	this.handleAltPress = function() {
	};
	this.handleShifttPress = function() {
	};
	this.handleClick = function() {
	};

	this.readJSONTree(data);
	return this;
};

// /////////////////////////////// tree sorting functions
/**
 * function to sort the nodes (case insenstive) by a field in the
 * information object
 * 
 * @param fld
 *            the field to sort by
 */
doubletree.sortByStrFld = function(fld) {
	var field = fld;
	return function(a, b) {
		var aUndefined = (undefined == a.data.info[field]);
		var bUndefined = (undefined == b.data.info[field]);
		if (aUndefined && bUndefined) {
			return 0;
		} else if (aUndefined) {
			return -1;
		} else if (bUndefined) {
			return 1;
		}
		var aVal = a.data.info[field].join(" ").toLowerCase();
		var bVal = b.data.info[field].join(" ").toLowerCase();
		if (aVal < bVal) {
			return -1;
		} else if (aVal > bVal) {
			return 1;
		}
		return 0;
	};
};
/**
 * function to sort the nodes according to the count field in the
 * information object
 */
doubletree.sortByCount = function() {
	return function(a, b) {
		return b.data.info.count - a.data.info.count;
	};
};

/**
 * function to sort the nodes according to the continuations field in the
 * information object
 */
doubletree.sortByContinuations = function() {
	return function(a, b) {
		return b.data.info.continuations - a.data.info.continuations;
	};
};

// /////////////////////////////// some tree filtering functions
/**
 * function to filter the nodes according to a minimum for the count field
 * 
 * @param n
 *            the minimum count to include
 */
doubletree.filterByMinCount = function(n) {
	return function(inf) {
		return inf.count >= n;
	};
};

/**
 * function to filter the nodes according to a maximum for the count field
 * 
 * @param n
 *            the maximum count to include
 */
doubletree.filterByMaxCount = function(n) {
	return function(inf) {
		return inf.count <= n;
	};
};

/**
 * function to filter the nodes according to the "POS" field (if it exists)
 * 
 * @param n
 *            a string for a regular expression of the POS values to include
 */
doubletree.filterByPOS = function(pos) {
	var re = new RegExp(pos);
	return function(inf) {
		return inf["POS"] && inf["POS"].filter(function(p) {
			return p.search(re) > -1;
		}).length > 0; // end of ng has no POS
	};
};

// /////////////////////////////// formatting functions

// doubletree.nodeText = function(info) {
// return doubletree.tokenText(info); //default
// }

// extracts a field
/**
 * return the value of a field in the provided information object
 * 
 * @param info
 *            the information object
 * @param the
 *            field to get
 * @returns the value of the field in the information object
 */
doubletree.fieldText = function(info, fieldName) {
	return info[fieldName];
};
// extracts the "token" field
/**
 * convenience function to return the value of the "token" field (if it
 * exists). The same as doubletree.fieldText(info, "token")
 * 
 * @param info
 *            the information object
 * @returns the value of the "token" field of the information object
 */
doubletree.tokenText = function(info) {
	var tokenText = '';
	if (info.token !== undefined) {
		tokenText = info.token;//info.token[0]; // don't return all token values, just the first
	}
	return tokenText;
};

/**
 * converts an information object to a string
 * 
 * @param the
 *            information object
 * @returns a string with one key/value pair per line
 */
doubletree.infoToText = function(info) {
	var what = "";
	for ( var infp in info) {
		if (infp == "ids" || infp == "origIDs") {
			what += infp + "\t:\t" + Object.keys(info[infp]).join(",")
					+ "\n";
		} else {
			what += (infp + "\t:\t" + info[infp] + "\n");
		}
	}
	return what;
};
// //////////////// internal utility functions

function old_pruneTree(tree, ids) {

	if (!tree.children) {
		return;
	}

	var n = tree.children.length;
	for ( var i = 0; i < n; i++) {
		var c = tree.children[i];

		if (containedIn(c.info.ids, ids)) {
			tree.children[i] = null;
		} else {
			old_pruneTree(c, ids);
		}
	}
	tree.children = tree.children.filter(function(c) {
		return c != null;
	});

	// recalculate maxChildren
	var cMax = d3.max(tree.children.map(function(c) {
		return c.maxChildren;
	}));
	tree.maxChildren = Math.max(tree.children.length, cMax);
}

function new_pruneTree(tree, ids, copyIDs) {

	if (!tree.children) {
		return;
	}

	// copy over original ids
	if (copyIDs) {
		if (!tree.info.origIDs) {
			tree.info.origIDs = {};
			addTo(tree.info.origIDs, tree.info.ids);
			tree.info.origCount = Object.keys(tree.info.origIDs).length;
		} else {
			tree.info.ids = {};
			addTo(tree.info.ids, tree.info.origIDs);
			tree.info.count = Object.keys(tree.info.ids).length;
		}
	}

	// adjust IDs
	var idNums = Object.keys(ids);
	for ( var i = 0, n = idNums.length; i < n; i++) {
		var cid = idNums[i];
		delete tree.info.ids[cid];
	}
	tree.info.count = Object.keys(tree.info.ids).length;

	// recurse and prune
	var n = tree.children.length;
	for ( var i = 0; i < n; i++) {
		var c = tree.children[i];

		if (containedIn(c.info.ids, ids)) {
			tree.children[i] = null;
		} else {
			new_pruneTree(c, ids, false);
		}
	}
	tree.children = tree.children.filter(function(c) {
		return c != null;
	});
	tree.info.continuations = tree.children.length;

	// recalculate maxChildren
	var cMax = d3.max(tree.children.map(function(c) {
		return c.maxChildren;
	}));
	tree.maxChildren = Math.max(tree.children.length, cMax);
}

function restoreTree(tree) {

	if (tree.info.origCount) { // otherwise tree was suppressed, so its ids
								// never got switched around
		// restore originals
		tree.info.ids = {};
		addTo(tree.info.ids, tree.info.origIDs);
		// delete tree.info.origIDs;
		tree.info.count = tree.info.origCount;
		// delete tree.info.origCount;

		var n = tree.children.length;
		tree.info.continuations = n;
		for ( var i = 0; i < n; i++) {
			var c = tree.children[i];
			restoreTree(c);
		}
	}

}

// do the keys in o1 and o2 overlap
function overlap(o1, o2) {
	for ( var k in o1) {
		if (k in o2) {
			return true;
		}
	}
	return false;
}
// are all the keys in o1 also in o2
function containedIn(o1, o2) {
	if (!o1 || !o2) {
		return false;
	}
	for ( var k in o1) {
		if (!(k in o2)) {
			return false;
		}
	}
	return true;
}

// add key/vals of o2 to o1 and return o1; (top level key-value only, o2
// values maintained over o1)
// same as in Trie.js
function addTo(o1, o2) {
	for ( var k in o2) {
		o1[k] = o2[k];
	}
}

function noOp() {
}

// ////////////////

})();
/* (This is the new BSD license.)
* Copyright (c) 2012-2014, Chris Culy
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Chris Culy nor the 
*		names of its contributors may be used to endorse or promote 
*		products from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Chris Culy
* ``AS IS'' AND ANY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
* ARE DISCLAIMED. IN NO EVENT SHALL Chris Culy
* BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
* CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
* GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
* CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
* TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

"use strict";
var doubletree = doubletree || {};

(function(){
    
    /**
     * @class doubletree.Trie
     * This is the class for the specialized trie that is the data for {@link doubletree.DoubleTree}.
 * The Trie will get pieces of data that contain fields. Some (possibly all) of those fields will be used for distinguishing among items.
 * For example, we might have an "author" field, but not use it when distinguishing among items for the Trie.
 * @param caseSensitive are the elements in the first distinguishing field compared in a case sensitive fashion
 * @param fldNames the names of the fields
 * @param fldDelim the field delimiter
 * @distinguishingFldsArray the distinguishing fields
 * @undistinguishedRoot true if the root should be calculated without using the distinguishing fields
 */
doubletree.Trie = function(caseSensitive, fldNames, fldDelim, distinguishingFldsArray, undistinguishedRoot) {
    var endNG = " ";
    var rootName = "_root_";
    var noCase = (! caseSensitive) && true;
    if (! fldNames) {
        fldNames = ["item"];
    }
    var fieldNames = fldNames;
    if (! fieldDelim) {
        fieldDelim = "\t"; //default
    }
    var fieldDelim = fldDelim;
    if (! distinguishingFieldsArray) {
        distinguishingFieldsArray = [ fieldNames[0] ];
    }
    var distinguishingFieldsArray = distinguishingFldsArray;
    var undistinguishedRt = undistinguishedRoot;
    if (undefined == undistinguishedRt) {
        undistinguishedRt = true; //TBD: check to make sure this doesn't break anything
    }
    
    var trie = new TrieNode(rootName,-1,0);
    
    /** @private */
    function TrieNode(item, id, count) {
        this.id = id;
        this.count = count;        
        this.info = {"count":count, "ids":{}};
        
        if (item == null) {
            this.item = rootName;        
        } else {
            this.item = item;
            this.info.ids = {};
            this.info.ids[id] = true;
            var flds = item.split(fieldDelim);
            for(var i in flds) {
                this.info[ fieldNames[i] ] = [ flds[i] ];
            }
        }
        this.nodes = {};
        
         /** @private */
        this.addNgram = function(itemArray, id, count) {
            if (! count) {
                count = 1;
            }
            var thisItem, thisKey;
            if (itemArray.length > 0) {
                thisItem = itemArray.shift();
                    
                var theseFlds = thisItem.split(fieldDelim);

                if (undistinguishedRt && this.item == rootName) {
                    thisKey = "";
                } else {
                    thisKey = theseFlds.filter(function(f,i) {
                            return distinguishingFieldsArray.indexOf( fieldNames[i] ) > -1;
                        })
                    .map(function(f) {
                            if (noCase) {
                                return f.toLocaleLowerCase();
                            }
                            return f;
                        })
                    .join(fieldDelim);
                }
                
            } else {
                thisItem = endNG;
                thisKey = thisItem;
            }
            
            var subTrie;
            if (thisKey in this.nodes && this.nodes[thisKey] instanceof TrieNode) { //we need the instanceof TrieNode so we can override Object properties -- hope that none are already arrays
                subTrie = this.nodes[thisKey];
                subTrie.info.count += count;
                subTrie.info.ids[id] = true;
                
                for(var f in theseFlds) {
                    var thisFld = theseFlds[f];
                    if (subTrie.info[ fieldNames[f] ].indexOf( thisFld ) == -1 ){
                        subTrie.info[ fieldNames[f] ].push(thisFld);
                    }                
                }
                
                
            } else {
                subTrie = new TrieNode(thisItem, id, count);            
                this.nodes[thisKey] = subTrie;
            }
            if (thisItem != endNG) {
                subTrie.addNgram(itemArray,id, count);
            }
        };
            
         /** @private */
        this.getUniqRoot = function() {
            if (this.item == rootName) {
                var children = Object.keys(this.nodes);
                if (children.length == 1) {
                    return this.nodes[ children[0] ];
                }
            }
        
            return this;
        };
        
        /** @private */
        this.toTree = function(filterFuns) {
            
            function toTreeHelper(filterFuns, descendentLevel, trieData) {
                
                var what = {"children":[]};
                what.name = trieData.item;
                what.info = {};
                for(var k in trieData.info) {
                    if (typeof(trieData.info[k]) === 'Object') {
                        what.info[k] = {};
                        for(var k2 in trieData.info[k]) {
                            what.info[k][k2] = this.info[k][k2];
                        }
                    } else {
                        what.info[k] = trieData.info[k];
                    }
                }
                what.pruned = {};
                
                
                for(var item in trieData.nodes) {
                    var itemNode = trieData.nodes[item];
                    var thisFilter = filterFuns[descendentLevel];            
                    if ( ! thisFilter || (thisFilter && thisFilter(itemNode.info)) ) {
                        what.children.push( toTreeHelper(filterFuns, descendentLevel +1, itemNode) );
                        if (itemNode.pruned != {}) {
                            addTo(what.pruned, itemNode.pruned);
                        }
                    } else {
                        addTo(what.pruned, itemNode.info.ids);
                    }
                }
        
                what.info.continuations = what.children.length;
                //this is to record info we need for sizing the tree, since D3 automatically scales to fit, which is not what we want
                //we also need to keep track of the minimum count (the root always has the max, of course), for scaling
                if (what.children.length == 0) {
                   what.children = null; //the trees expect null if there are no children, not the empty array. Odd, but true.
                   what.maxChildren = 0;
                   
                   if (what.name) {
                    what.maxLen = what.name.length;
                   } else {
                    what.maxLen = 0;
                   }
                   
                   what.minCount = what.info.count;
                   //what.maxChildren = 0; //new
                   
                } else {
                    var cMax = d3.max( what.children.map(function(c) {return c.maxChildren;}) );
                    what.maxChildren = Math.max(what.children.length, cMax);
                    
                    var maxLen = d3.max( what.children.map(function(c) {return c.maxLen;}));
                    what.maxLen = Math.max(maxLen, what.name.length);
                    
                    what.minCount = d3.min( what.children.map(function(c) {return c.minCount;})); //the children are always <= the parent
                }
                return what;
            }
            
            if (! filterFuns ) {
                filterFuns = [];
            }
            
            var trieData = JSON.parse(JSON.stringify(this)); //CuC make a copy of the data, to keep the real trie immutable
        
            return toTreeHelper(filterFuns, 0, trieData);
        };
    }
    
    
    
    
    /**
     * Add an ngram to the Trie
     * @param itemArray an array of delimited items (the ngrams)
     * @param id an id for this ngram 
     * @param count a count for this ngram. Default is 1
     */
    this.addNgram = function(itemArray, id, count) {trie.addNgram(itemArray, id, count);};
    
    /**
     * get the unique root of this Trie. Used only by {@link DoubleTree}
     * @returns a new Trie with a unique item as the root
     */
    this.getUniqRoot = function() {
        var what = new doubletree.Trie((!noCase), fieldNames, fieldDelim, distinguishingFieldsArray);
        what.trie( trie.getUniqRoot() );
        return what;
    };
    
    /**
     * convert the Trie to a tree structure for display. Used only by {@link DoubleTree}
     * @param filterFuns the filtering functions to apply to the tree see {@link DoubleTree.filters}
     * @param descendentLevel the current level we are filtering
     * @returns the tree
     */
    this.toTree = function(filterFuns, descendentLevel) {return trie.toTree(filterFuns, descendentLevel);};
    
    /**
     * serialize the Trie as a JSON string
     * @returns the JSON string representation of the Trie
     */
    this.serialize = function() {
        return JSON.stringify(this);
    };
    
    /**
     * make this Trie have the values of a previously serialized Trie see {@link #serialize}
     */
    this.deserialize = function(serialized) {
        var obj = JSON.parse(serialized);
        
        endNG = obj.endNG();
        rootName = obj.rootName();
        noCase = obj.caseSensitive();
        fieldNames = obj.fieldNames();
        fieldDelim = obj.fieldDelim();
        distinguishingFieldsArray = obj.distinguishingFieldsArray();
        trie = obj.trie();
        
    };
    
    //getters -- the properties are readonly, set in constructor
    
    //private, only used in deserialization
    /** @private */
    this.endNG = function() {
        return endNG;
    };
    //private, only used in deserialization
    /** @private */
    this.rootName = function() {
        return rootName;
    };
    
    //private, also a setter, only used in deserialization and getUniqRoot;
    /** @private */
    this.trie = function(value) {
      if (arguments.length > 0) {
        trie = value;
      }
      return trie;
    };
    
    /**
     * @returns whether this Trie uses case sensitive comparison
     */
    this.caseSensitive = function() {
        return ! noCase;
    };
    
    /**
     * get the field names in the data
     * @returns the field names in the data
     */
    this.fieldNames = function() {
        return fieldNames;
    };
    
    /**
     * get the field delimiter for the data
     * @returns the field delimiter for the data
     */
    this.fieldDelim = function() {
        return fieldDelim;
    };
    
    /**
     * get the distinguishing fields for the data
     * @returns the distinguishing fields for the data
     */
    this.distinguishingFieldsArray = function() {
        return distinguishingFieldsArray;
    };
    
    //add key/vals of o2 to o1 and return o1; (top level key-value only, o2 values maintained over o1)
    /** @private */
    function addTo(o1, o2) {
        for(var k in o2) {
            o1[k] = o2[k];
        }
    }

    
};  

})();

/**
 * @param {object} config
 * @param {Voyant.panel.TermsRadio} config.parent
 * @param {Ext.dom.Element} config.container
 * @param {boolean} config.showSlider
 */
function TermsRadio(config) {
	this.parent = config.parent;
	this.container = config.container;
	this.isSliderVisible = config.showSlider == undefined ? true : config.showSlider;
	
	this.chart = null;
	
	this.absMaxFreq = 0;
	this.absMinFreq = 0;
	this.allData = [];
	
	this.continueTransition = true;
	this.counterSeries = [];
	this.displayData = [];
	this.dragged = false;
//	this.intervalIdArray = [];
	this.isTransitioning = false;
	this.lastSlippery = null;
	this.lastSticky = null;
	this.maxFont = 30;
	this.minFreq = 0;
	this.numDataPoints = 0;
	this.numVisPoints = 5;
	this.overlayQueue = [];
	this.records = 0;
	this.recordsLength = 0;
	this.reselectTop = false;
	this.shiftCount = 0;
	this.sliderDragSum = 0;
	this.titlesArray = [];
	this.transitionCall = 'draw'; //possible calls 'draw', 'redraw', 'left', and 'right'
	this.valFraction = 1;
	this.win = 0;
	
	//window padding dimensions, b - bottom, l - left, r - right, t - top
	this.bPadding = 25;
	this.lPadding = 40;
	this.rPadding = 20;
	this.tPadding = 10;
	
	this.sliderHeightRatio = 0.1; // slider/container height ratio
	this.sliderHeight = 0; // set in init and resize
	this.sliderBPadding = 10;
	
	//tracks largest dimensions, used in resizing
	this.largestW = 0;
	this.largestH = 0;
	
	this.xAxisEl = undefined;
	this.xAxis = d3.axisBottom();
	this.xScale = d3.scaleLinear();
	this.xSliderScale = d3.scaleLinear();
	
	this.yAxisEl = undefined;
	this.yAxis = d3.axisLeft();
	this.yScale = d3.scaleLinear();
	this.ySliderScale = d3.scaleLinear();
	
	this.fontScale = d3.scaleLinear();
	this.opacityScale = d3.scaleLinear();
	
	this.container.on('resize', this.doResize, this);
}

TermsRadio.prototype = {
	constructor: TermsRadio
	
	,loadRecords: function(records) {
		this.initData(records);
		this.prepareData();
		//for shiftcount > 0 exclusively
		var len = this.shiftCount;
		while(len-- > 0){
		//for(var j = 0; j < this.shiftCount; j++){
			this.displayData.shift();
		}
		if (this.chart != null) {
			this.redraw();
		} else {
			this.initializeChart();
		}
	}

	,highlightQuery: function(query, sticky) {
		var docId = null;
		if (this.parent.getApiParam("mode") === 'document') {
			docId = this.parent.getCorpus().getDocument(0).getId();
		}
		var info = {wordString : query, docId : docId};
		var paramsBundle = this.buildParamsBundle(info);
		if (sticky) {
			this.manageOverlaySticky(paramsBundle);
		} else {
			this.manageOverlaySlippery(paramsBundle);
		}
	}
	
	,highlightRecord: function(record, sticky) {
		var info = {wordString : record.get('term'), docId : record.get('docId')};
		var paramsBundle = this.buildParamsBundle(info);
		if (sticky) {
			this.manageOverlaySticky(paramsBundle);
		} else {
			this.manageOverlaySlippery(paramsBundle);
		}
	}
	
	//
	//DATA FUNCTIONS
	//	

	,initData: function (records) { 	
		//console.log("fn: initData")
		//console.profile('profilethis')
		this.records = records;
		
		this.recordsLength = this.records.length;
	
		this.numVisPoints = parseInt(this.parent.getApiParam('visibleBins'));
		this.shiftCount = parseInt(this.parent.getApiParam('position'));
		
		if(this.parent.getApiParam('mode') === 'document') {
			this.numDataPoints = this.records[0].get('distributions').length;
			var parentBins = parseInt(this.parent.getApiParam('bins'));
			if(this.numDataPoints !== parentBins){
				this.numDataPoints = parentBins;
				this.loadStore();
			}
		} else {
			this.numDataPoints = this.records[0].get('distributions').length;
		}
		
    	this.counterSeries = [];
    	var transferArray = [];
			
    	//find max frequency value
    	this.absMaxFreq = 0;
		for( var k = 0; k < this.numDataPoints; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	if(this.records[p].get('distributions')[k] > this.absMaxFreq) {
	        		this.absMaxFreq = this.records[p].get('distributions')[k];
	        	}
	        }
		}
			    
		//find the absolute minimum frequency value
		//first start by setting the minimum frequency to the maximum frequency
		this.absMinFreq = this.absMaxFreq;
		for( var k = 0; k < this.numDataPoints; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	if(this.records[p].get('distributions')[k] <= this.absMinFreq && this.records[p].get('distributions')[k] !== 0) { 
	        		this.absMinFreq = this.records[p].get('distributions')[k];
	        	}
	        }
		}
		
		//Calculate the lower value of the y axis, must be > 0 
		if( this.absMinFreq < 0) {
			this.absMinFreq = 0;
		}
		
		this.minFreq = this.absMinFreq * 1.01;
		
	    //transfer all of the relevant data from 'records' to an array 'allData'
		for( var k = 0; k < this.numDataPoints; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	var rec = this.records[p];
	        	var dists = rec.get('distributions')[k];
//	        	if (dists > this.minFreq && dists <= this.absMaxFreq) {
	        	if (dists > 0) {
	        		transferArray.push({
	        			freq: dists,
		                wordString: rec.get('term'),
		                counter: k,
		                posInSeries: 0, 
		                numInSeries: 0,
		                docId: rec.get('docId')
		            });
	        	}
//	        	} else { //do nothing
//	        	}
	        }
	        this.counterSeries.push(transferArray);
	        transferArray = [];
	    }
	}

	,prepareData: function() {
		//console.log("fn: prepareData")
	    var frequencySeries = [],
	    	copy1 = [],
	    	copy2 = [],
	    	copy3 = [],
	    	copy4 = [],
	    	check = 0;
		
		this.allData = [];
		this.displayData = [];
		
		//set the number of points to be displayed at once
		if(this.numDataPoints < this.numVisPoints) {
			this.numVisPoints = this.numDataPoints;
		}
		
		//adjust shiftCount if it for some reason is out of the normal range
		if(this.shiftCount + this.numVisPoints > this.numDataPoints){ 
			this.shiftCount = this.numDataPoints - this.numVisPoints; 
		}
		
	    for( var k = 0; k < this.numDataPoints; k++ ) {
			var check1 = 0; //add a single first data point
	    	for(var p = 0; p < this.counterSeries[k].length; p++ ) {
	    			
    			var check2 = 0; //check will make sure a data point is not added to a series more than once
    			
	    		//add very first point, this is done like this so the for loop can use the .length operator
	    		if(check1 === 0){
			    	copy1.push(this.counterSeries[k][p]);
			    	copy2.push({freq: this.counterSeries[k][p].freq,
		    			frequencyArray: copy1,
		    			numInSeries: 0
		    		});
		    		frequencySeries.push(copy2);
		    		
		    		copy1 = [];
		    		copy2 = [];
		    		check1 = 1;
		    		check2 = 1;
	    		}
	    		
	    		//checks if a given frequency has an existing 'series' that the data point can be grouped into
	    		for( var l = 0; l < frequencySeries[k].length && check2 === 0; l++) {
					if(this.counterSeries[k][p].freq === frequencySeries[k][l].freq) {
						var inSeries = 0; 
						inSeries = frequencySeries[k][l].numInSeries;
						this.counterSeries[k][p].posInSeries = ++inSeries;
						frequencySeries[k][l].numInSeries = inSeries;
						frequencySeries[k][l].frequencyArray.push(this.counterSeries[k][p]);
						check2 = 1;
					}	
	    		}
	    		
	    		//if there is no existing series then create a new one
	    		if(check2 === 0) {
					copy4.push(this.counterSeries[k][p]);
		    		frequencySeries[k].push({freq: this.counterSeries[k][p].freq,
		    			frequencyArray: copy4,
		    			numInSeries: 0
		    		});
		    		copy4 = [];
		    		check2 = 1;
				}
	    	}	
	    	//if counterSeries[k] is empty add or there is no eligible value add an empty array to frequencySeries such that frequencySeries[k] is not undefined
	    	if(this.counterSeries[k].length < 1 || check1 === 0) {  
	    		frequencySeries.push([]);
    		}
	    }
	    
	    for( var k = 0; k < this.numDataPoints; k++ ) {
	    	for( var p = 0; p < frequencySeries[k].length; p++) {
	    		++frequencySeries[k][p].numInSeries;
	    		for( var l = 0; l < frequencySeries[k][p].frequencyArray.length; l++) {
	    			frequencySeries[k][p].frequencyArray[l].numInSeries = frequencySeries[k][p].numInSeries;
	    		}
	    	}
	    }
	    
	    var allDataSetup = [];
	    
	    //add the selected points into the array that will be used to display the data
	    for( var k = 0; k < this.numDataPoints; k++ ) {
	        this.allData.push({allDataInternal: frequencySeries[k],
	            outerCounter: k});
	    }
	    
    	var displaySetup = [],
    		transferArray = [];
		
	    //transfer the first x points (= numVisPoints, the number of points to be visualized)
	    //into an array that will be used to display the data
	    for( var k = 0; k < this.numVisPoints + this.shiftCount; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	if(this.allData[k].allDataInternal[p]) {
		            transferArray.push({freq: this.allData[k].allDataInternal[p].freq,
		                inSeries: this.allData[k].allDataInternal[p].numInSeries,
		                frequencyArray: this.allData[k].allDataInternal[p].frequencyArray,
		                dotObject: [{counter: k, freq: this.allData[k].allDataInternal[p].freq}]
		            });
	        	}
	        }
	        displaySetup.push(transferArray);
	        transferArray = [];
	    }
	    
	    //add the selected points into the array that will be used to display the data
	    for( var k = 0; k < this.numVisPoints + this.shiftCount; k++ ) {
	        this.displayData.push({displayInternal: displaySetup[k],
	            outerCounter: k});
	    }
	    displaySetup = [];
	}
	
	//TRANSITION FUNCTIONS
	
	//disable forward back if moving, disable pause if stopped, disable back if at beginning
	,manageMvtButtons: function () {
		//console.log('fn: manageMvtButtons')
		this.parent.queryById("play").setPlaying(this.isTransitioning);
		/*
		if(this.isTransitioning === true) {
			this.toggleRight.setDisabled(true);
			this.toggleLeft.setDisabled(true);
			this.stop.setDisabled(false);
		}
		if(this.isTransitioning === false) {
			this.toggleRight.setDisabled(false);
			this.toggleLeft.setDisabled(false);
			this.stop.setDisabled(true);
			
			if(this.shiftCount === 0){
				this.toggleLeft.setDisabled(true);
			} else {
				this.toggleLeft.setDisabled(false);
			}
			
			if(this.shiftCount + this.numVisPoints === this.numDataPoints){
				this.toggleRight.setDisabled(true);
			} else {
				this.toggleRight.setDisabled(false);
			}
		}	
		*/
	}

	//provides the next value to the left     
    ,nextR: function () {
    	//console.log('fn: nextR')
    	
    	var displaySetup = [];
    	//this.displayData.shift();
		
    	for( var p = 0; p < this.recordsLength; p++ ) {
    		if(this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p]) {
	            displaySetup.push({freq: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].freq,
	            	inSeries: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].numInSeries,
	            	frequencyArray: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].frequencyArray,
	                dotObject: [{counter: this.numVisPoints + this.shiftCount, freq: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].freq}]
	            });
    		}
        }
        
	    this.displayData.push({displayInternal: displaySetup, outerCounter: this.numVisPoints + this.shiftCount});
	    displaySetup = [];
    }
    
    //verifies that data CAN be moved to the right
    ,toggleRightCheck: function () {
    	//console.log("fn: toggleRightCheck")
    	if(this.numVisPoints + this.shiftCount < this.numDataPoints) {
    		//manage transition movements and controls
    		this.isTransitioning = true;
    		this.continueTransition = true;
    		this.manageMvtButtons();
    		
    		//draw
	        this.nextR();
			this.shiftCount = ++this.shiftCount;
			this.manageXScale();
			this.parent.setApiParams({position: this.shiftCount});
			this.transitionCall = 'right';
			this.animateVis();
			this.displayData.shift();
		} else {
    		//manage transition movements and controls
			this.isTransitioning = false;
			this.continueTransition = false;
			this.manageMvtButtons();
		}
    }
    
    //provide the next value
    ,nextL: function () {
    	//console.log('fn: nextLeft')
    	var displaySetup = [];
        
        for( var p = 0; p < this.recordsLength; p++ ) {
        	if(this.allData[this.shiftCount].allDataInternal[p]) {
        		displaySetup.push({freq: this.allData[this.shiftCount].allDataInternal[p].freq,
	            	inSeries: this.allData[this.shiftCount].allDataInternal[p].numInSeries,
	            	frequencyArray: this.allData[this.shiftCount].allDataInternal[p].frequencyArray,
	                dotObject: [{counter: this.shiftCount, freq: this.allData[this.shiftCount].allDataInternal[p].freq}]
	            });
        	}
        }
	    this.displayData.unshift({displayInternal: displaySetup, outerCounter: this.shiftCount});
        displaySetup = [];
    }
    
    /*
    ,toggleLeftCheck: function () {    	
    	//console.log("fn: toggleLeftCheck")
    	if(this.shiftCount > 0) {
    		//manage transition movement and controls
    		this.isTransitioning = true;
			this.continueTransition = true;
			this.manageMvtButtons();
			
			//draw
			this.shiftCount = --this.shiftCount;
			this.manageXScale();
			this.parent.setApiParams({position: this.shiftCount});
	        this.nextL();
			this.transitionCall = 'left';
	        this.animateVis();
	        this.displayData.pop();
		} else {
			//manage transition movements and controls
			this.isTransitioning = false;
			this.manageMvtButtons();
		}
    }
    */
    
    ,startScroll: function() {
    	//console.log("fn: startScroll")
    	var me = this;
    	
    	if(me.numDataPoints > me.numVisPoints && me.shiftCount === 0){
			//manage transition movements and controls
			me.isTransitioning = true;
			this.manageMvtButtons();
    		
    		//repeat transition
			setTimeout(function(){
				me.toggleRightCheck();
			},3000);
		}
    }
    
    //
    //DISPLAY FUNCTIONS
    //
	
	
	// init and draw everything
	,initializeChart: function() {
		this.initChart();
		
		this.drawXAxis();
		this.drawYAxis();
		this.drawChart();
		if (this.isSliderVisible) {
			this.drawSlider();
			this.drawVerticalSlider();
			this.redrawSliderOverlay();
		}
		this.transitionCall = 'draw';
	}
	
    ,redraw: function() {

//    	console.log("fn: redraw")
    	this.transitionCall = 'redraw';
    	this.updateFullPath();
		this.redrawXAxis();
		this.redrawYAxis();
		this.redrawChart();
		if (this.isSliderVisible) {
			this.redrawSlider();
			this.redrawVerticalSlider();
			this.redrawSliderOverlay();
		}
		this.redrawChartOverlay();
    }
    
	,initChart: function () {
		var h = this.container.getHeight(),
			w = this.container.getWidth();
    
		//create main SVG Element
		var chartSVG = Ext.DomHelper.append(this.container.down('div[class$=innerCt]'), '<svg class="chart" width="'+w+'" height="'+h+'"></svg>');
	    this.chart = d3.select(chartSVG);
	    
	    this.setSliderHeight();
	    
		this.largestW = w;
		this.largestH = h - this.getSliderHeight();
		
		var y = this.tPadding + this.getSliderHeight();
	    	    
	    this.chart.append('clipPath')
	        .attr('id', 'clip1')
	      .append('rect')
	      	.attr('class', 'clipping-rectangle')
	        .attr("x", 0)
	        .attr("y", y)
	        .attr("width", w)
	        .attr("height", this.largestH);
	    
	    this.chart.append('g')
	    	.attr('class','overlay')
	    	.attr("clip-path", "url(#clip1)");
	    
		//depending on the size of display set the length that labels can be
		this.setTitleLength();
	}
    
	,doResize: function() {
		if(this.chart) {
			var h = this.container.getHeight(),
				w = this.container.getWidth();

			this.setSliderHeight();
			
			this.largestH = h - this.getSliderHeight();
			this.largestW = w;
			
			this.chart.attr('height', h)
				.attr('width', w);
				
			this.setTitleLength();
			
			this.chart.select('rect[class=clipping-rectangle]')
		        .attr("x", 0)
		        .attr("y", this.tPadding + this.getSliderHeight())
		        .attr("width", w)
		        .attr("height", this.largestH);
		
			this.redraw();
		}
	}
	
    ,drawXAxis: function() {
    	var me = this;
    	//svg element constants
		var h = this.container.getHeight(),
			w = this.container.getWidth();
    	
		//initialize x scales
		this.manageAllXScales();
			
    	//define X axis
		this.xAxis = d3.axisBottom(me.xScale)
		    .ticks(Math.round(me.numVisPoints))
		    .tickFormat(function(d){
		    	var val;
		    	if(me.parent.getApiParam('mode') === 'document') { 
					val = 'Segment ' + (parseInt(d) + 1);
				}
				if(me.parent.getApiParam('mode') === 'corpus') {
					val = d + 1 + '. ' + me.titlesArray[d];
				}
				return val;
		    });
		
		//draw the x-axis
		this.xAxisEl = this.chart.append('g')
    		.attr('class', 'axisX')
    		.attr('transform', 'translate(0,' + (h - this.bPadding) + ')')
    		.call(this.xAxis);
    	
//    	this.xAxisEl.selectAll('text')
//			.on('mouseover', function () {
//				d3.select(this)
//					.attr('fill', 'red')
//					.style("font-size", '18px');
//			})
//			.on('mouseout', function () {
//				d3.select(this)
//					.attr('fill', 'black')
//					.style("font-size", '11px');
//			});
		this.styleXAxis();
    }
    
    ,styleXAxis: function() {
    	this.xAxisEl.selectAll('text')
	        .style('font-family', 'sans-serif')
	        .style('font-size', '11px');

	    this.xAxisEl.selectAll('line')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges');
	        
	    this.xAxisEl.selectAll('path')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges');
    }
    
    ,redrawXAxis: function() {
    	this.chart.selectAll('g[class=axisX]')
			.remove();
		
		this.drawXAxis();
    }
    
    ,drawYAxis: function() {
    	var me = this;
    	
    	//svg element constants
		var h = this.container.getHeight(),
			w = this.container.getWidth();
		
		//initialize Y scales
		this.manageAllYScales();
    	
    	var yTicksScale = d3.scaleLinear()
			.domain([200,700])
			.range([5,15]);
			
		var numberFormat = d3.format(".2r");
		function logFormat(d) {
			var x = Math.log(d) / Math.log(10) + 1e-6;
			return Math.abs(x - Math.floor(x)) < 0.7 ? numberFormat(d) : "";
		} 
		
		this.yAxis = d3.axisLeft(me.yScale)
	    	.ticks(yTicksScale(h))
	    	.tickFormat(logFormat)
			.tickSize(-w + this.rPadding + this.lPadding);
		
		//draw the y-axis
		this.yAxisEl = this.chart.append('g')
	    	.attr('class', 'axisY')
	    	.attr('transform', 'translate(' + this.lPadding + ',0)')
	    	.call(this.yAxis);
		
	    this.yAxisEl.selectAll('text')
	        .style('font-family', 'sans-serif')
	        .style('font-size', '11px');
	    
	    //controls horizontal grid line-opacity
	    this.yAxisEl.selectAll('line')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges')
	        .style('stroke-opacity', 0.05);
	        
	    this.yAxisEl.selectAll('path')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges');
    }
    
    ,redrawYAxis: function() {
    	this.chart.selectAll('g[class=axisY]')
			.remove();
		
		this.drawYAxis();
    }
    
    ,drawChart: function() {
    	var me = this;
    	
    	//create graph text
	    //attach the nested data to svg:g elements
		var counterSeriesDiv = this.chart.selectAll('g[class=section]')
	        .data(me.displayData, function(d) { return d.outerCounter; })
	      .enter().append('g')
	        .attr('class', 'section')
	        .attr("clip-path", "url(#clip1)");
		
		var frequencySeriesDiv = counterSeriesDiv.selectAll('g')
			.data(function(d) { return d.displayInternal; })
	      .enter().append('g')
	        .attr('class', 'frequencies')
	        .on('mouseover', function() {
				d3.select(this).style('fill', 'red');
			})
			.on('mouseout', function() {
	            d3.select(this).style('fill', 'black');
			});
	             
        //attach the frequency data to data points 
		var dataPoint = frequencySeriesDiv.selectAll('text')
    		.data(function(d) { return d.frequencyArray; })
		  .enter().append('text')
	        .attr('class', function(d) {
	        	return me.removeFilteredCharacters(d.wordString);
	        })
	    	.attr('x', function (d) {
	    		var startPoint = (0.5 / d.numInSeries) - 0.5
					,valueRange = (d.posInSeries / d.numInSeries * 0.8)
					,x = d.counter + me.callOffset() + startPoint + valueRange; 
				return me.xScale(x);
			})
	    	.attr('y', function (d) { 
				var y = d.freq;
				return me.yScale(y);
	    	})
	    	.attr('text-anchor', 'middle')
	    	.attr('transform', function (d) {
	    		var startPoint = (0.5 / d.numInSeries) - 0.5
					,valueRange = (d.posInSeries / d.numInSeries * 0.8)
					,x = d.counter + me.callOffset() + startPoint + valueRange
					,y = d.freq;
	    		return 'translate(0, 0) rotate(-20 ' + me.xScale(x) + ' '+ me.yScale(y) + ')';
	    	})
	    	.style('font-size', function(d) { return me.fontScale(d.freq) + 'px'; })
	    	.style('fill-opacity', function(d) { return me.opacityScale(d.freq); })
	        .text(function(d) { return d.wordString; })
	        .on('mouseover', function(d) { 
	 	        d3.select(this).style('cursor', 'pointer').style('font-size', function(d) { return (me.fontScale(d.freq) * me.maxFont / me.fontScale(d.freq)) + 'px'; });
	 	        var paramsBundle = me.buildParamsBundle(d);
	 	        me.manageOverlaySlippery(paramsBundle);
	        })
	        .on('mouseout', function(d) { 
	        	d3.select(this).style('cursor', 'auto').style('font-size', function(d) { return me.fontScale(d.freq) + 'px'; });
	        	var paramsBundle = me.buildParamsBundle(d);
	        	me.manageOverlaySlippery(paramsBundle);
	        })
	        .on('click', function(d) {
	        	var paramsBundle = me.buildParamsBundle(d);
	        	me.manageOverlaySticky(paramsBundle);
			})
	  	  .append('title')
	    	.text(function(d) { return d.wordString; });
    }
    
    ,redrawChart: function() {
    	this.chart.selectAll('g[class=section]')
			.remove();
			
		this.drawChart();
    }
    
    ,drawVerticalSlider: function() {
//    	var h = this.container.getHeight(),
//			w = this.container.getWidth();
//    	
//    	var totalTopOffset = (this.tPadding * 2) + this.sliderHeight
//        	,lengthVer = h - (totalTopOffset + this.bPadding);
//        
//	    //create vertical minimap rectangle and slider
//	    var sliderPosScale = d3.scaleLinear()
//			.domain([this.absMaxFreq, this.minFreq])
//			.range([totalTopOffset, lengthVer]);
//	    
//	    var rectVer = this.chart.append('rect')
//	  	    .attr('class', 'minimap')
//	  	    .attr('x', w - (this.rPadding * 0.66))
//	  	    .attr('y', totalTopOffset)
//	  	    .attr('rx', 3.33)
//	  	    .attr('width', 6.66)
//	  	    .attr('height', lengthVer)
//	  	    .style('fill','aliceblue')
//	  	    .style('stroke','black')
//	  	    .style('stroke-width','1')
//	  	    .style('fill-opacity','0.75');
//	    	
//	    var sliderVer = this.chart.append('rect')
//			.attr('class', 'minimap')
//	  	    .attr('x', w - (this.rPadding * 0.66))
//	  	    .attr('y', totalTopOffset)
//	  	    .attr('rx', 3.33)
//	  	    .attr('width', 6.66)
//	  	    .attr('height', lengthVer * ((this.absMaxFreq * this.valFraction) - this.minFreq) / this.absMaxFreq)
//	  	    .style('fill','CornflowerBlue')
//	  	    .style('stroke','black')
//	  	    .style('stroke-width','1');
    }
    
    ,redrawVerticalSlider: function() {
    	this.chart.selectAll('rect[class=minimap]')
			.remove();
			
		this.drawVerticalSlider();
    }
    
    ,drawSlider: function() {
    	var h = this.container.getHeight(),
			w = this.container.getWidth();
	    
		//Create navigation bar
		var lengthHor = w - (this.rPadding + this.lPadding)
			,offsetVis = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / 2) * ( 1 / (this.numDataPoints - 1)))
			,offsetVisStart = this.lPadding
			,offsetVisEnd = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / (this.numDataPoints - 1)));
		
		var lineX = this.chart.append('line')
			.attr('class', 'slider axis')
			.attr('x1', this.lPadding)
			.attr('x2', this.container.getWidth() - this.rPadding)
			.attr('y1', this.tPadding + this.sliderHeight)
			.attr('y2', this.tPadding + this.sliderHeight)
			.style('shape-rendering', 'crispEdges')
			.style('stroke','black')
	  	    .style('stroke-width','1');
					
		var lineY = this.chart.append('line')
			.attr('class', 'slider axis')
			.attr('x1', this.lPadding)
			.attr('x2', this.lPadding)
			.attr('y1', this.tPadding + this.sliderHeight)
			.attr('y2', this.tPadding)
			.style('shape-rendering', 'crispEdges')
			.style('stroke','black')
	  	    .style('stroke-width','1');
		
	    var sliderHorStart = this.chart.append('line')
	  	    .attr('class', 'slider')
	  	    .attr('id', 'before')
	  	    .attr('x1', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisStart)
	  	    .attr('x2', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisStart)
	  	    .attr('y1', this.tPadding + this.sliderHeight)
	  	    .attr('y2', this.tPadding)
	  	    .style('stroke', 'black')
	  	    .style('stroke-width', '1');
	    
	    var sliderHorEnd = this.chart.append('line')
	  	    .attr('class', 'slider')
	  	    .attr('id', 'after')
	  	    .attr('x1', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisEnd)
	  	    .attr('x2', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisEnd)
	  	    .attr('y1', this.tPadding + this.sliderHeight)
	  	    .attr('y2', this.tPadding)
	  	    .style('stroke', 'black')
	  	    .style('stroke-width', '1');
	  	    	  	    
	   var greyBoxBefore = this.chart.append('rect')
  	    	.attr('class', 'slider')
  	    	.attr('id', 'boxBefore')
  	    	.attr('x', this.lPadding)
  	    	.attr('y', this.tPadding)
  	    	.attr('height', this.sliderHeight)
  	    	.attr('width', lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1))
  	    	.style('fill', 'silver')
  	    	.style('fill-opacity', 0.25)
	    	.style('cursor', 'move');
	    		    
	    var greyBoxAfter = this.chart.append('rect')
	    	.attr('class', 'slider')
	    	.attr('id', 'boxAfter')
	    	.attr('x', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisEnd)
	    	.attr('y', this.tPadding)
	    	.attr('height', this.sliderHeight)
	    	.attr('width', lengthHor * (this.numDataPoints - this.numVisPoints - this.shiftCount + this.callOffset()) / (this.numDataPoints - 1))
	    	.style('fill', 'silver')
	    	.style('fill-opacity', 0.25)
	    	.style('cursor', 'move');
	    
	    var me = this;
    	var drag = d3.drag()
        .on('drag', function(d) {
        	if(!me.isTransitioning) {
        		this.drag = true;
        		
	        	var w = me.parent.getWidth()
	        		,displaceX = parseInt(d3.event.dx)
	        		,checkBefore
	        		,checkAfter
	        		,pos = 0;
	        		
	        	//add up the slider movements as they occur	
        		me.sliderDragSum += d3.event.dx;
	        	
	        	me.chart.selectAll('#before')
	        		.attr('x1', function () { 
	        			checkBefore = parseInt(this.getAttribute('x1'));
	        			pos = parseInt(this.getAttribute('x1')) + displaceX;
	        			return parseInt(this.getAttribute('x1'));
	        		});
	        	
	        	me.chart.selectAll('#after')
	        		.attr('x1', function () { 
	        			checkAfter = parseInt(this.getAttribute('x1'));
	        			return parseInt(this.getAttribute('x1'));
	        		});
	        	
	        	if(checkBefore + displaceX < me.lPadding || checkAfter + displaceX > w - me.rPadding) {
	        		displaceX = 0;
	        	}
	        	
	        	me.chart.select('#boxBefore')
	        		.attr('width', function () { return parseInt(this.getAttribute('width')) + displaceX; });
	        	
	        	me.chart.select('#boxAfter')
	        		.attr('x', function () { return parseInt(this.getAttribute('x')) + displaceX; })
        			.attr('width', function () { return Math.max(0, parseInt(this.getAttribute('width')) - displaceX); });
	        		
	        	me.chart.selectAll('#before')
	        		.attr('x1', function () { return parseInt(this.getAttribute('x1')) + displaceX; })
	        		.attr('x2', function () { return parseInt(this.getAttribute('x2')) + displaceX; });
	        	
	        	me.chart.selectAll('#after')
        			.attr('x1', function () { return parseInt(this.getAttribute('x1')) + displaceX; })
        			.attr('x2', function () { return parseInt(this.getAttribute('x2')) + displaceX; });
        	}
        })
        .on('end', function(d) {
        	if(this.drag){
        		this.drag = false;
        		
        		var inverseSliderScale = d3.scaleLinear()
			    	.domain([0, me.container.getWidth() - (me.lPadding + me.rPadding)])
			    	.range([0, me.numDataPoints]);
			    	
				//calculate the position that everything should transition to
	        	var moveByThis = inverseSliderScale(me.sliderDragSum),
	        		moveShiftCount,
	        		oldShiftCount = me.shiftCount;
	        		
	    		if(moveByThis > 0) moveShiftCount = Math.floor(moveByThis);
	    		if(moveByThis < 0) moveShiftCount = Math.ceil(moveByThis);
	    		
	    		//update shiftCount re-animate 
	    		me.shiftCount += moveShiftCount;
	    		if(me.shiftCount < 0) me.shiftCount = 0;
	    		if(me.shiftCount > me.numDataPoints - 1) me.shiftCount = me.numDataPoints - 1;
	    		
	    		if(me.shiftCount !== oldShiftCount) {
	    			me.sliderDragSum = 0;
	    			
	        		me.parent.setApiParams({position: me.shiftCount});
					me.prepareData();
					
					me.redraw();
	        	}
        	}
        });
	    
	    greyBoxBefore.call(drag);
	    greyBoxAfter.call(drag);
    }
    
    ,removeSlider: function(removeTermLines) {
    	this.chart.selectAll('rect[class=slider]')
    		.remove();
	
    	this.chart.selectAll('line[class~=slider]')
	    	.remove();
    	
    	if (removeTermLines) {
    		this.chart.selectAll('g[class=slider]')
	    		.remove();
    	}
    }
    
    ,redrawSlider: function() {
    	this.removeSlider();
    	this.drawSlider();
    }
	
	,animateVis: function() {
		var me = this;
		
		//prepare the data for the visualization
		//shiftCount = 0, means the displayData begins with the same value as nestedData
		var mode = this.parent.getApiParam('mode');
		
	    //svg element constants
		var h = this.container.getHeight(),
			w = this.container.getWidth();

		var duration = this.getDuration();
		
		//if transitionCall === 'draw': draw the function for the first time		
		//if not: shift displayData to a different subset of allData
		//then display the newly shifted data	
		if(this.transitionCall === 'left' || this.transitionCall ==='right'){
			this.xAxisEl.transition()
	            .duration(duration)
	            .ease(d3.easeLinear)
	            .call(this.xAxis);
	            
	        this.styleXAxis();
	        
	        this.drawChart();
	    
        	//if call is shift move the dataPoints	
        	this.chart.selectAll('.frequencies').transition()
        		.duration(duration)
	            .ease(d3.easeLinear)
	            .selectAll('text')
	            .attr('x', function (d) {
	            	var startPoint = (0.5 / d.numInSeries) - 0.5,
						valueRange = (d.posInSeries / d.numInSeries * 0.8),
						x = d.counter + startPoint + valueRange; 
					return me.xScale(x);
				})
				.attr('transform', function (d) {
		    		var startPoint = (0.5 / d.numInSeries) - 0.5
						,valueRange = (d.posInSeries / d.numInSeries * 0.8)
						,x = d.counter + startPoint + valueRange
						,y = d.freq;
		    		return 'translate(0, 0) rotate(-20 ' + me.xScale(x) + ' '+ me.yScale(y) + ')';
				});
	    	   
        	//Create navigation bar
			var lengthHor = w - (this.rPadding + this.lPadding)
				,offsetVis = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / 2) * ( 1 / (this.numDataPoints - 1)))
				,offsetVisStart = this.lPadding
				,offsetVisEnd = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / (this.numDataPoints - 1)));
				
        	this.chart.select('#before').transition()
				.duration(duration)
				.ease(d3.easeLinear)
			 	.attr('x1', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisStart)
			 	.attr('x2', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisStart)
		  	    .attr('y1', this.tPadding + this.getSliderHeight())
		  	    .attr('y2', this.tPadding)
		  	    .on('end', function () {
		  	    	if (me.parent.isMasked()) {
		  	    		me.parent.unmask();
		  	    	}
		  	    	if(me.continueTransition) { 
		  	    		setTimeout(function () {
		  	    			me.callTransition();
		  	    		},50); 
		  	    	} else { 
		  	    		//manage transition movements and controls
		  	    		me.isTransitioning = false;
		  				me.manageMvtButtons();
		  	    	}
		  	    });
        	
	  	   this.chart.select('#after').transition()
				.duration(duration)
				.ease(d3.easeLinear)
			 	.attr('x1', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisEnd)
			 	.attr('x2', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisEnd)
		  	    .attr('y1', this.tPadding + this.getSliderHeight())
		  	    .attr('y2', this.tPadding);
		    
	  	   this.chart.select('#boxBefore').transition()
				.duration(duration)
				.ease(d3.easeLinear)
	  	    	.attr('x', this.lPadding)
	  	    	.attr('y', this.tPadding)
	  	    	.attr('height', this.getSliderHeight())
	  	    	.attr('width', lengthHor * (this.shiftCount) / (this.numDataPoints - 1));
	    
	  	    this.chart.select('#boxAfter').transition()
				.duration(duration)
				.ease(d3.easeLinear)
	  	    	.attr('x', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisEnd)
	  	    	.attr('y', this.tPadding)
	  	    	.attr('height', this.getSliderHeight())
	  	    	.attr('width', lengthHor * (this.numDataPoints - this.numVisPoints - this.shiftCount) / (this.numDataPoints - 1));
        }
        
        //animates the chart overlay
		this.redrawChartOverlay();
	}
	
	,callTransition: function () {
		if(this.transitionCall === 'left') this.toggleLeftCheck();
        if(this.transitionCall === 'right') this.toggleRightCheck();
	}
		
	//build the params bundle to pass to manageOverlaySticky
	,buildParamsBundle: function (info) { 
		//console.log('fn: builParamsBundle')
		var type = info.wordString,
			params = {},
			paramsBundle = {},
			docId;

		if ( this.parent.getApiParam('mode') === 'document') { // set position
			docId = info.docId;
			var totalTokens = this.parent.getCorpus().getDocument(docId).get('totalTokens') - 1;
			params.tokenIdStart = parseInt(this.category * totalTokens / this.numDataPoints);
			params.docIdType = docId + ':' + type;
		} else {
		}
				
		paramsBundle = { params: params, type: type };
		
		return paramsBundle;
	}
	
	,manageOverlaySlippery: function (paramsBundle) {

		//console.log('fn: manageOverlaySlippery')
		var string = paramsBundle.type
			,selector = this.removeFilteredCharacters(paramsBundle.type) 
			,checkOn = 'on'
			,index;
		
//		this.continueTransition = true;
//
//		this.transitionCall = 'draw';
		
		//check if the word that was selected was already sticky
		//if so checkOn = off and nothing happens
		var len = this.overlayQueue.length;
		while(--len >= 0){
			if(selector === this.overlayQueue[len].selector){ 
		    	checkOn = 'off';
		    	index = len;
			}
		}
		
		//make sure the selected word wasn't just a sticky word that is being deselected
		//thus happens to be scrolled over
		if(selector === this.lastSticky){
			checkOn = 'off';
			this.lastSticky = null;
		}
		
		if(checkOn === 'on') {
			//select a slippery word
			if(selector !== this.lastSlippery) {
				var pathHolder = this.prepareFullPath(string);
				var lineObject = {
					word: string, 
					selector: selector, 
					params: paramsBundle, 
					fullPath: pathHolder.path,
					pathMin: pathHolder.min,
					pathMax: pathHolder.max,
					colour: 'red'
				};	
				if(this.lastSlippery !== null) {
					//exceptional case where lastSlippery was not properly removed
					this.chartOverlayOff(this.lastSlippery);
					if (this.isSliderVisible) {
						this.sliderOverlayOff(this.lastSlippery);
					}
					this.lastSlippery = null;
					
					//select new slippery word
					//change its colour
					this.chartOverlayOn(lineObject);
					if (this.isSliderVisible) {
						this.sliderOverlayOn(lineObject);
					}
					this.lastSlippery = selector;
				}
				else {
					//normal case select slippery word
					//change its colour
					this.chartOverlayOn(lineObject);
					if (this.isSliderVisible) {
						this.sliderOverlayOn(lineObject);
					}
					this.lastSlippery = selector;
				}
			}
			else{
				//normal case deselect a slippery word
				this.chartOverlayOff(selector);
				if (this.isSliderVisible) {
					this.sliderOverlayOff(this.lastSlippery);
				}
				this.lastSlippery = null;
			}
		}
		else {
			//else do nothing 
			//this means, don't select a word that is already sticky
		}
	}

	,manageOverlaySticky: function (paramsBundle) {
//		console.log('fn: manageOverlaySticky')
		var me = this;
		
		var term = paramsBundle.type;
		
		this.transitionCall = 'draw';
		
		if (!this.isTermSelected(term)) {
			this.doTermSelect(term, true);
		} else {
			this.doTermDeselect(term, true);
		}
	},
	
	getTermIndex: function(term) {
		var index = -1;
		var selector = selector = this.removeFilteredCharacters(term);
		var len = this.overlayQueue.length;
		while(--len >= 0){
			if(selector === this.overlayQueue[len].selector){ 
				index = len;
			}
		}
		return index;
	},
	
	isTermSelected: function(term) {
		return this.getTermIndex(term) !== -1;
	},
	
	doTermSelect: function(term, legendAdd) {
		var selector = selector = this.removeFilteredCharacters(term);
		//finish updating API array of selected words
		var apiArray = this.parent.getApiParam('selectedWords');
		apiArray.push(term);
		this.parent.setApiParams({selectedWords: apiArray});
		
		//draw the sticky path
		var color = this.parent.getApplication().getColorForTerm(term, true);
		
		if (legendAdd === true) {
			var legend = this.parent.query('[xtype=legend]')[0];
			legend.getStore().add({name: term, mark: color});
		} else {
			var legend = this.parent.query('[xtype=legend]')[0];
			var record = legend.getStore().findRecord('name', term);
			if (record !== null) {
				record.set('mark', color);
				legend.refresh();
			}
		}
		
		var pathHolder = this.prepareFullPath(term);
		var lineObject = {
			word: term, 
			selector: selector,
			params: {params: {}, type: term},
			fullPath: pathHolder.path,
			pathMin: pathHolder.min,
			pathMax: pathHolder.max,
			colour: color
		};
		
		//if this was selected a slippery before click event remove line from navigation bar
		if(selector === this.lastSlippery){
			if (this.isSliderVisible) {
				this.sliderOverlayOff(selector);
			}
			this.lastSlippery = null;
		}
		
		//make sure there is no path already present
		this.chart.select('g[class=frequency-line-' + selector.replace(/'/g, "\\'") + ']').remove();

		this.overlayQueue.push(lineObject);
		this.chartOverlayOn(lineObject);
		if (this.isSliderVisible) {
			this.sliderOverlayOn(lineObject);
		}
	},
	
	doTermDeselect: function(term, legendRemove) {
		var selector = this.removeFilteredCharacters(term);
		var index = this.getTermIndex(term);
		
		if (legendRemove === true) {
			var legend = this.parent.query('[xtype=legend]')[0];
			var index = legend.getStore().findExact('name', term);
			legend.getStore().removeAt(index);
		}
		
		var updateApi = this.parent.getApiParam('selectedWords');
		for(var i = 0, len = updateApi.length; i < len; i++) {
			if(updateApi[i] === selector) {
				updateApi.splice(i, 1);
				this.parent.setApiParams({selectedWords: updateApi});
			}
		}
		this.chartOverlayOff(selector);
    	this.overlayQueue.splice(index, 1);
    	if (this.isSliderVisible) {
    		this.sliderOverlayOff(selector);
    	}
		this.lastSticky = selector;
	}
	
	,prepareFullPath: function (string) {
		var linePosArray = [],
			pathMin = this.absMaxFreq,
			pathMax = this.absMinFreq;
		
		for(var k = 0, len = this.allData.length; k < len; k++){
			foundB = 0;
			for(var i = 0, lenA = this.allData[k].allDataInternal.length; i < lenA; i++) {
				for(var j = 0, lenB = this.allData[k].allDataInternal[i].frequencyArray.length; j < lenB; j++){
					if(this.allData[k].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal1 = this.allData[k].allDataInternal[i].frequencyArray[j].freq;
						linePosArray.push({x: k, y: yVal1});
						if(yVal1 < pathMin) pathMin = yVal1;
						if(yVal1 > pathMax) pathMax = yVal1;
						foundB = 1;
					}
				}
			}
			if(foundB === 0){
				var yVal2 = this.minFreq;
				linePosArray.push({x: k, y: yVal2});
				if(yVal2 < pathMin) pathMin = yVal2;
				if(yVal2 > pathMax) pathMax = yVal2;
			}
		}
		return {path: linePosArray, min: pathMin, max: pathMax};
	}
	
	,updateFullPath: function () {
//		console.log("fn: updateFullPath")
		var lenA = this.overlayQueue.length;
		while(lenA-- > 0){
			var pathHolder = this.prepareFullPath(this.overlayQueue[lenA].word);
			this.overlayQueue[lenA].fullPath = pathHolder.path;
			this.overlayQueue[lenA].pathMin = pathHolder.min;
			this.overlayQueue[lenA].pathMax = pathHolder.max;
		}
//		console.log(this.overlayQueue)
	}
	
	,buildSliderPath: function (pathArray) {
		var me = this;
		var line = d3.line()
		    .x(function(d) { return me.xSliderScale(d.x); })
		    .y(function(d) { return me.ySliderScale(d.y); })
		    .curve(d3.curveNatural);
		return line(pathArray);
	}
	
	,sliderOverlayOn: function (objectToSelect) {
		//console.log('fn: sliderOverlayOn')		
		this.transitionSliderOverlay(objectToSelect);
		
		//draw path
		this.chart.append('g')
			.attr('class', 'slider')
			.attr('id', 'slider-line-' + objectToSelect.word)
			.append('path')
			.attr("d", this.buildSliderPath(objectToSelect.fullPath))
			.style('stroke', objectToSelect.colour)
			.style('stroke-width', 2)
			.style('fill', 'none');
			
		//redraw slider
		this.redrawSlider();
	}
	
	,sliderOverlayOff: function (selector) {
	    this.chart.selectAll('g[id=slider-line-' + selector.replace(/'/g, "\\'") + ']')
	    	.remove();
	    
	    //update slider overlay axis
		this.transitionSliderOverlay();
	}
	
	,redrawSliderOverlay: function() {	
		//console.log('redrawSliderOverlay')
		for(var l = 0; l < this.overlayQueue.length; l++){
			this.sliderOverlayOff(this.overlayQueue[l].selector);
			this.sliderOverlayOn(this.overlayQueue[l]);
		}
	}
	
	,transitionSliderOverlay: function(objectToSelect) {
		//console.log('transitionSliderOverlay')
		objectToSelect = objectToSelect || 0;
		
		//update slider overlay axis
		this.updateYSliderScale(objectToSelect);
		
		//transition all other paths
		var lenA = this.overlayQueue.length;
		while(lenA-- > 0){
			this.chart.selectAll('g#slider-line-' + this.overlayQueue[lenA].selector.replace(/'/g, "\\'"))
				.select('path')
				.transition().duration(300)
				.ease(d3.easeLinear)
				.attr("d", this.buildSliderPath(this.overlayQueue[lenA].fullPath));
		}
	}
	
	,preparePath: function (string) {
		//console.log('fn: prepareData')
		
		var linePosArray = [];
		
		//peek at the next frequency point and the preceding one to end the line on the edge of the graph
		var foundA
			,foundB
			,foundC;
		
		//add two positions offscreen to the left for smooth transitions 
		for(var k = 0; k < 3 && this.shiftCount - k > 0; k++) {
			foundA = 0;
			for(var i = 0; i < this.allData[this.shiftCount - (1 + k)].allDataInternal.length; i++) {
				for(var j = 0; j < this.allData[this.shiftCount - (1 + k)].allDataInternal[i].frequencyArray.length; j++){
					if(this.allData[this.shiftCount - (1 + k)].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal3 = this.yScale(this.allData[this.shiftCount - (1 + k)].allDataInternal[i].frequencyArray[j].freq);
						linePosArray.unshift({x: this.shiftCount - (1 + k), y: yVal3});
						foundA = 1;
					}
				}
			}
			if(foundA === 0){
				var yVal4 = this.yScale(this.minFreq);
				linePosArray.unshift({x: this.shiftCount - (1 + k), y: yVal4});
			}
		}
		
		//fill in the middle values
		for(var k = this.shiftCount, len = this.numVisPoints + this.shiftCount; k < len; k++){
			foundB = 0;
			for(var i = 0, lenA = this.allData[k].allDataInternal.length; i < lenA; i++) {
				for(var j = 0, lenB = this.allData[k].allDataInternal[i].frequencyArray.length; j < lenB; j++){
					if(this.allData[k].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal1 = this.yScale(this.allData[k].allDataInternal[i].frequencyArray[j].freq);
						linePosArray.push({x: k, y: yVal1});
						foundB = 1;
					}
				}
			}
			if(foundB === 0){
				var yVal2 = this.yScale(this.minFreq);
				linePosArray.push({x: k, y: yVal2});
			}
		}
		
		//add two positions offscreen to the right for smooth transitions 
		for(var k = 0; k < 3 && this.numVisPoints + this.shiftCount + k < this.numDataPoints; k++){
			foundC = 0;
			for(var i = 0; i < this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal.length; i++) {
				for(var j = 0; j < this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal[i].frequencyArray.length; j++){
					if(this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal1 = this.yScale(this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal[i].frequencyArray[j].freq);
						linePosArray.push({x: this.numVisPoints + this.shiftCount + k, y: yVal1});
						foundC = 1;
					}
				}
			}
			if(foundC === 0){
				var yVal2 = this.yScale(this.minFreq);
				linePosArray.push({x: this.numVisPoints + this.shiftCount + k, y: yVal2});
			}
		}
		return linePosArray;
	}
	
	//draws the line graph overlay of the frequency info
	,chartOverlayOn: function(objectToSelect) {
//		console.log('fn: chartOverlayOn')
		
		var me = this;
					
		//change selected word colour
		this.chart.selectAll('g[class=section]')
			.selectAll('g[class=frequencies]')
			.selectAll('text[class=' + objectToSelect.selector.replace(/'/g,"\\'") + ']')
			.style('fill', objectToSelect.colour)
			.style('fill-opacity', 1);
	    	
	    //if transitionCall === 'draw': draw the function for the first time		
		//if not: shift displayData to a different subset of allData
		//then display the newly shifted data
		
		var linePosArray = this.preparePath(objectToSelect.word);
		
		var pos;
		
		//draw path
		var line = d3.line()
		    .x(function(d) { 
		    	pos = d.x;
		    	return me.xScale(d.x + me.callOffset()); })
		    .y(function(d) { return d.y; })
		    .curve(d3.curveNatural);
		
		var path = this.chart.select('.overlay')
			.append('g')
			.attr('class', 'frequency-line-' + objectToSelect.selector)
			.append('path')
			.attr("d", line(linePosArray))
			.style('stroke', objectToSelect.colour)
			.style('stroke-width', 2)
			.style('fill', 'none');
					
		var posDif = (this.xScale(pos) - this.xScale(pos + this.callOffset()));
		
		if(this.transitionCall === 'left' || this.transitionCall ==='right') {
			path.transition()
				.duration(me.getDuration())
				.ease(d3.easeLinear)
			    .attr("transform", "translate(" + posDif + ")");
		}
	}
	
	,chartOverlayOff: function(selector){
		var me = this;
		
		this.chart.selectAll('text.' + selector.replace(/'/g, "\\'"))
	    	.style('fill', 'black')
	    	.style('fill-opacity', function(d) { return me.opacityScale(d.freq); });
	    
	    this.chart.select('g.frequency-line-' + selector.replace(/'/g, "\\'"))
	    	.remove();
	}
	
	//reselect all the sticky words
	//a screen movement has changed the words positions
	,redrawChartOverlay: function () {
		//console.log('fn: redrawChartOverlay')
		for(var i = 0; i < this.overlayQueue.length; i++){
			this.chartOverlayOff(this.overlayQueue[i].selector);
			this.chartOverlayOn(this.overlayQueue[i]);
		}
	}
	
	//
	//SCALE FUNCTIONS
	//
	
	//all these scales need to be updated if this.absMaxFreq or this.valFraction changes
	,manageAllYScales: function() {
		this.manageFontScale();
		this.manageOpacityScale();
		this.manageYScale();
		this.manageYSliderScale();
	}
	
	,manageFontScale: function() {
		//console.log('fn: fontScale')
		 this.fontScale.domain([this.minFreq, this.absMaxFreq * this.valFraction])
	    	.range([10, this.maxFont]);
	}
	
	/*,maxFontScale : function (value) {
		var scale = d3.scaleLinear()
			.domain([600,2000])
			.range([15,60]);
		return scale(value);
	}*/
	
	,manageOpacityScale: function() {
		this.opacityScale.domain([0, this.absMaxFreq * this.valFraction])
    		.range([0.4, 0.8]);
	}
	
	,manageYScale: function () {
		if(this.parent.getApiParam('yAxisScale') == 'linear') this.yScale = d3.scaleLinear();
		if(this.parent.getApiParam('yAxisScale') == 'log') this.yScale = d3.scaleLog();
		
		this.yScale.domain([this.minFreq, this.absMaxFreq * this.valFraction * 1.25])
				.rangeRound([this.container.getHeight() - this.bPadding, (this.tPadding) + this.getSliderHeight()]);
	}
	
	,manageYSliderScale: function() {
		var top = this.tPadding
			,bottom = this.tPadding + this.getSliderHeight();
		
		if(this.parent.getApiParam('yAxisScale') == 'linear') this.ySliderScale = d3.scaleLinear();
		if(this.parent.getApiParam('yAxisScale') == 'log') this.ySliderScale = d3.scaleLog();
		
		this.ySliderScale.domain([this.minFreq, this.absMaxFreq])
				.rangeRound([bottom, top]);
	}
	
	,updateYSliderScale: function(updateWithObject) {
		updateWithObject = updateWithObject || 0;
		var selectedMin = this.minFreq, //setting this to this.absMinFreq effectively deactivates it, to make it work use this.absMaxFreq
			selectedMax = 0;
	    	
	    //go through overlayQueue check for min / max
		var len = this.overlayQueue.length;
		while(len-- > 0){
			if(this.overlayQueue[len].pathMin < selectedMin) selectedMin = this.overlayQueue[len].pathMin;
			if(this.overlayQueue[len].pathMax > selectedMax) selectedMax = this.overlayQueue[len].pathMax;
		}
		if(updateWithObject != 0 && updateWithObject.pathMin < selectedMin) selectedMin = updateWithObject.pathMin;
		if(updateWithObject != 0 && updateWithObject.pathMax > selectedMax) selectedMax = updateWithObject.pathMax;
		
		this.ySliderScale.domain([selectedMin, selectedMax]);
	}
	
	,manageAllXScales: function() {
		this.manageXScale();
		this.manageXSliderScale();
	}
	
	,manageXScale: function() {
		this.xScale.domain([this.shiftCount - 0.5, this.numVisPoints + this.shiftCount - 0.5])
	    	.range([this.lPadding, this.container.getWidth() - this.rPadding]);
	}
	
	,manageXSliderScale: function() {
		this.xSliderScale.domain([0, this.numDataPoints - 1])
	    	.range([this.lPadding, this.container.getWidth() - this.rPadding]);
	}

	,getSliderHeight: function() {
		return this.isSliderVisible ? this.sliderHeight+this.sliderBPadding : 0;
	}
	
	,setSliderHeight: function() {
		this.sliderHeight = Math.max(10, this.container.getHeight()*this.sliderHeightRatio);
	}
	
	,hideSlider: function() {
		this.isSliderVisible = false;
		this.removeSlider(true);
		this.doResize();
	}
	
	,showSlider: function() {
		this.isSliderVisible = true;
		this.doResize();
	}
	
	
	//
	//MISC. FUNCTIONS
	//

	
	,setTitleLength: function () {
		//console.log('fn:setTitleLength')
		var me = this, 
			item;
		this.titlesArray = [];
		
		var scale = d3.scaleLinear()
			.domain([350,1250])
			.range([10,40]);
		
		var corpus = this.parent.getCorpus();
		for (var i = 0, len = corpus.getDocumentsCount(); i < len; i++) {
			var item = corpus.getDocument(i);
			var shortTitle = item.getShortTitle();			
			if(shortTitle.length <= scale(me.container.getWidth())) {
				me.titlesArray.push(shortTitle); 
			} else {
				var shorterTitle = shortTitle.substring(0,scale(me.container.getWidth()) - 3);
				me.titlesArray.push(shorterTitle + '...'); 
			}
		}
	}
	
	,callOffset: function () {
//		console.log('fn: callOffset')
		var callOffset;
		if(this.transitionCall === 'draw' || this.transitionCall === 'redraw') { 
			callOffset = 0; 
		}
		if(this.transitionCall === 'left') { 
			callOffset = -1;
		}
		if(this.transitionCall === 'right') { 
			callOffset = 1;
		}
		return callOffset;
	}
	
	,removeFilteredCharacters: function (string) {
		//console.log('fn: removeFilteredCharacters')
		return string || '';
		
		if (string !== undefined) {
			return string.replace("'","apostrophe-")
				.replace("#","pound-")
				.replace("&","ampersand-")
				.replace("@","atsign-")
				.replace("!","exclamation-")
				.replace("0","num-o")
				.replace("1","num-a")
				.replace("2","num-b")
				.replace("3","num-c")
				.replace("4","num-d")
				.replace("5","num-e")		
				.replace("6","num-f")
				.replace("7","num-g")
				.replace("8","num-h")
				.replace("9","num-i")
				.replace(/[^a-zA-Z]+/g,'-'); //then anything else...
		} else {
			return '';
		}
	},
	
	getDuration: function() {
		return this.numDataPoints*(100-this.parent.getSpeed())
	}
	
};
Ext.define('Voyant.util.Assignable', {
    transferable: ['assign'],
    /**
     * This is a convenience method for assigning a variable name to this promised object once it's ready.
     * 
     * This method is chainable, so you can call other promise-aware corpus functions.
     * 
     * 		new Corpus("Hello World!").assign("helloworld").show();
     * 
     * This is somewhat equivalent to the nastier:
     * 
     *  	var helloworld;
     *  	new Corpus("Hello World!").then(function(corpus) {
     *  		helloworld = corpus;
     *  		helloworld.show();
     *  	})
     *  
     * Note that when using `assign` in spyral, any references to the name variable should occur in separate, subsequent code blocks. 
     * 
     * 		new Corpus("Hello Voyant!").assign("corpus");
     * 
     * Then use the named variable in a subsequent code block:
     * 
     * 	  corpus.show();
     * 
     *  @param {String} name The variable name to assign to this corpus.
     */
    assign: function(name) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			if (Ext.isString(name)) {
				window[name] = this;
			} else {
				Voyant.application.showError("The 'assign' method expects a string argument. ("+typeof name+") "+name)
			}
			return this;
		}
	}
})
Ext.define('Voyant.util.Api', {
	constructor: function(config) {
		var apis = [];
		if (!this.isApplication) {
			var app = this.getApplication ? this.getApplication() : Voyant.application;
			
			// try to load from first-level mixins
			if (this.mixins) {
				for (key in this.mixins) {
					var clz = Ext.ClassManager.get(key);
					if (clz && clz.api) {
						apis.splice(0, 0, clz.api)
					}
				}
			}
			this.addParentApi(apis, Ext.ClassManager.getClass(app)); // gather class params
			if (app.getApiParams) {
				apis.push(app.getApiParams()); // now add instance params, last
			}
		}

		this.addParentApi(apis, Ext.ClassManager.getClass(this)); // add params from this class and parents

		this.api = {};
		apis.forEach(function(a) {
			for (key in a) {
				this.api[key] = {initial: a[key], value: a[key]} // overwrite previous entries
			}
		}, this)
		
    	var queryParams = Ext.Object.fromQueryString(document.location.search);
		var xtype = this.getXType ? this.getXType() : undefined;
    	for (var key in queryParams) {
    		if (this.api[key]) {
    			this.setApiParam(key, queryParams[key]);
    		} else if (xtype && key.indexOf(".")>0) {
    			var k = key.substring(key.indexOf(".")+1);
    			if (k && k in this.api) {
    				this.setApiParam(k, queryParams[key])
    			}
    		}
    	}
    	
		if (config && Ext.isObject(config.api)) {
	    	for (var key in config.api) {
	    		if (this.api[key]) {
	    			this.setApiParam(key, config.api[key]);
	    		}
	    	}
	    	delete config.api; // remove so it doesn't overwrite default api
		}
		
    	// handle "type"  parameter specially for backwards compatibility
    	if (queryParams["type"] && ("query" in this.api) && !this.getApiParam('query')) {
    		this.setApiParam("query", queryParams['type']);
    	}
    	
	},
	addParentApi: function(apis, clz) {
		if (clz.api) {apis.splice(0,0, clz.api)} // add to front
		if (clz.superclass) {this.addParentApi(apis, clz.superclass.self)}
	},
	getApiParam: function(key, defaultValue) {
		return this.api[key]!==undefined ? this.api[key].value : defaultValue
	},
	getApiParams: function(keys, keepEmpty) {
		keys = keys || Object.keys(this.api);
		var api = {};
		if (Ext.isString(keys)) {keys=[keys]}
		keys.forEach(function(key) {
			var val = this.getApiParam(key);
			if (keepEmpty || !Ext.isEmpty(val)) {api[key]=val;}

		}, this);
		return api;
	},
	
	getModifiedApiParams: function() {
		var api = {};
		for (var key in this.api) {
			if (this.api[key].initial!=this.api[key].value) {
				api[key]=this.api[key].value
			}
		}
		return api
	},
	
	setApiParams: function(config) {
		for (var key in config) {this.setApiParam(key, config[key])}
	},
	
	setApiParam: function(key, value) {
		if (this.api && this.api[key]) {this.api[key].value=value;}
	}
});
Ext.define('Voyant.util.Localization', {
	statics: {
		DEFAULT_LANGUAGE: 'en',
		LANGUAGE: 'en',
		i18n: {
		}
		
	},
	
    languageStore: Ext.create('Ext.data.ArrayStore', {
        fields: ['code', 'language'],
        data : [
                ['en', 'English']
        ]
    }),
	
	getLanguage: function(code) {
		var record = this.languageStore.findRecord(code.length==2 ? 'code' : 'language', code);
		if (record) {return record.get(code.length==2 ? 'language' : 'code');}
	},
	
	localize: function(key, config) {
		return this._localizeObject(this, key, config);
	},
	
	_localizeObject: function(object, key, config) {

		var val = this._localizeClass(Ext.ClassManager.getClass(object), key, config);
		if (val) {return val;}
		if (object.mixins) { // look at mixins first
			for (mixin in object.mixins) {
				var val = this._localizeClass(Ext.ClassManager.getClass(object.mixins[mixin]), key, config);
				if (val) {return val;}
			}
		}
		if (object.superclass) { // then superclasses
			val =  this._localizeObject(object.superclass, key, config);
			if (val) {return val;}
		}
		return config && config['default']!=undefined ? config['default'] : '['+key+']';
	},
	
	_localizeClass: function(clazz, key, config) {
		if (clazz && clazz.i18n && clazz.i18n[key]) {
			var use = false;
			if (clazz.i18n[key]) {
				use = clazz.i18n[key];
			}
			/*
			if (config && config.lang && clazz.i18n[key][config.lang]) {
				use = clazz.i18n[key][config.lang];
			}
			else if (clazz.i18n[key][Voyant.util.Localization.LANGUAGE]) {
				use = clazz.i18n[key][Voyant.util.Localization.LANGUAGE];
			}
			else if (clazz.i18n[key][Voyant.util.Localization.DEFAULT_LANGUAGE]) {
				use = clazz.i18n[key][Voyant.util.Localization.DEFAULT_LANGUAGE];
			}
			*/
			if (use) {
				if (use.isTemplate) { // template
					return use.apply(config);
				}
				return use; // string
			}
			return config && config['default']!=undefined ? config['default'] : '['+key+']'; // no language key found, so just return the key
		}
		return false
	},
	
	getLanguageToolMenu: function() {
		var me = this;
		return {
			type: 'language',
			tooltip: this.localize("languageTitle"),
			xtype: 'toolmenu',
	        glyph: 'xf1ab@FontAwesome',
			handler: me.showLanguageOptions,
			scope: me
		} 
	},

	
	showLanguageOptions: function() {
		var me = this;
		var langs = ["ar","bs","cz","en","fr","he","hr","it","ja","pt","sr"].map(function(lang) {
			return {text: this.localize(lang), value: lang}
		}, this);
		langs.sort(function(a,b) {
			return a.text.localeCompare(b.text);
		});
		langs.splice(0,0,{text: this.localize('autoRecommended'), value: ''})
		
		new Ext.window.Window({
			title: this.localize("languageTitle"),
			modal: true,
			items: {
				xtype: 'form',
				items: [{
					xtype: 'combo',
					name: 'lang',
					value: this.getApiParam("lang") || "",
	    	        queryMode: 'local',
	    	        editable: false,
	    	        fieldLabel: this.localize('chooseLanguage'),
	    	        width: 450,
	    	        labelAlign: 'right',
	    	        labelWidth: 150,
	    	        displayField: 'text',
	    	        valueField: 'value',
					store: {
						fields: ['text', 'value'],
						data: langs
					}
				}/*,{
					xtype: 'combo',
					name: 'rtl',
					value: '',
	    	        queryMode: 'local',
	    	        editable: false,
	    	        fieldLabel: this.localize('rtlLabel'),
	    	        labelAlign: 'right',
	    	        displayField: 'text',
	    	        valueField: 'value',
					store: {
						fields: ['text', 'value'],
						data: [{
							text: this.localize('auto'),
							value: ''
						},{
							text: this.localize('yes'),
							value: 'true'
						},{
							text: this.localize('no'),
							value: 'false'
						}]
					}
				}*/],
				buttons: [{
	            	text: this.localize("cancelTitle"),
		            ui: 'default-toolbar',
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize("confirmTitle"),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var form = btn.up('form');
	        			if (form.isDirty()) {
	        				var app = me.getApplication();
	        				var params = app.getModifiedApiParams();
	        				if (app.getCorpus()) {
	        					params.corpus = app.getCorpus().getAliasOrId();
	        				} else {
	        					delete params.panels; // we probably don't need this
	        				}
	        				delete params.lang;
//	        				delete params.rtl;
	        				var values = form.getValues();
	        				if (values.lang) {params.lang = values.lang;}
//	        				if (values.rtl) {params.rtl = values.lang;}
	        				location.assign("./?"+Ext.Object.toQueryString(params))
	        			}
	        			btn.up('window').close();
	        		},
	        		scope: me
	            }]
			},
			bodyPadding: 5
		}).show()
	}
	
});

Ext.define('Voyant.util.Deferrable', {
	deferredStack : [],

	releaseAllDeferred : function() {
		this.deferredStack = [];
	},

	getDeferredCount : function() {
		return this.deferredStack.length;
	},
	
	getDeferred: function(transferable) {

//		var deferred = jQuery.Deferred();
		var deferred = new Ext.Deferred();
		
		var pomise = deferred
		// transfer methods to the promise
//		var promise = this.getPromiseFromDeferred(deferred);

		if (transferable && transferable.transfer) {
			transferable.transfer(transferable, deferred.promise)
		}

		if (!deferred.promise.show && window.show) {deferred.promise.show=show}
		
		// make sure that this object can chain an assignment
		if (!deferred.promise.assign) {
			Ext.apply(deferred.promise, {assign: new Voyant.util.Assignable().assign});
		}

		this.deferredStack.push(deferred);
		
		var me = this;
		deferred.promise.always(function() {
			me.deferredStack.pop();
		});
		return deferred;
	},
	
	getPromiseFromDeferred: function(dfd) {
		return typeof dfd.promise === "object" ? dfd.promise : dfd.promise();
	},
	
	getDeferredNestedPromise: function(promise, args, transferable) {
		var callee = arguments.callee.caller; // TODO: is callee.caller in terms of nested functions?
		var dfd = Voyant.application.getDeferred(transferable);
		promise.then(function(promised) {
			dfd.resolve(callee.apply(promised, args))
		})/*.fail(function() {
			dfd.reject.apply(this, arguments)
		})*/;
		return dfd.promise;
	}
});

Ext.define("Voyant.util.DetailedError", {
	extend: "Ext.Error",
	mixins: ['Voyant.util.Localization'],
	config: {
		msg: undefined,
		error: undefined,
		details: undefined
	},
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
		this.setMsg(config.msg);
		this.setError(config.error);
		this.setDetails(config.details);
		this.callParent(arguments);
//		debugger
//		this.show();
	},
	
	show: function(config) {
		if (window.showError) {showError.call(this);}
		else {this.showMsg(config)}
	},
	
	showMsg: function(config) {
		config = config || {};
		Ext.applyIf(config, {
			message: this.getMsg()+"<p class='error'>\n"+this.getError()+" "+
				"<a href='#' onclick=\"window.open('').document.write(unescape('<pre>"+escape(this.getDetails())+"</pre>')); return false;\">more</a></p>",
			title: this.localize("error"),
		    buttons: Ext.Msg.OK,
		    icon: Ext.MessageBox.ERROR,
		    autoScroll: true
		});
		Ext.Msg.show(config);
	}
})

Ext.define("Voyant.util.ResponseError", {
	extend: "Voyant.util.DetailedError",
	config: {
		response: undefined
	},
	constructor: function(config) {
		this.setResponse(config.response);
		Ext.applyIf(config, {
			msg: config.response.statusText, // hopefully already set by creator
			error: ("responseText" in config.response) ? config.response.responseText.split(/(\r\n|\r|\n)/).shift() : "", // show first line of response
			details: ("responseText" in config.response) ? config.response.responseText : ""
		})
		this.callParent(arguments);
	}
	
})

Ext.define('Voyant.util.SparkLine', {
	/**
	 * Gets a Google spark line.
	 * 
	 * @param {Array} values An array of numerical values.
	 * @param {Integer} stretch The width to stretch the spark line towards (currently unused).
	 * @return {String} The image(s) of the spark line.
	 * @private
	 */
	getSparkLine : function(values, stretch) {
		if (values.length < 2) {
			return '';
		}
		var min = Number.MAX_VALUE;
		var max = Number.MIN_VALUE;
		var hasDecimal = false;
		for ( var i = 0; i < values.length; i++) {
			if (values[i] < min) {
				min = values[i];
			}
			if (values[i] > max) {
				max = values[i];
			}
			if (!hasDecimal
					&& values[i].toString().indexOf('.') > -1) {
				hasDecimal = true;
			}
		}
		var dif = (max - min).toString();
		var multiplier = 1;
		var divider = 1;

		var newvalues = [];
		if (hasDecimal) {
			var multiplier = 100;
			var ind = dif.indexOf(".") + 1;
			for ( var i = ind; i < dif.length; i++) {
				if (dif.charAt(i) == '0') {
					multiplier *= 10;
				} else {
					break;
				}
			}
			for ( var i = 0; i < values.length; i++) {
				newvalues[i] = parseInt(values[i] * multiplier);
			}
			max = parseInt(max * multiplier);
			min = parseInt(min * multiplier);

		} else {
			var divider = 1;
			for ( var i = dif.length - 1; i > -1; i--) {
				if (dif.charAt(i) == '0') {
					divider *= 10;
				} else {
					break;
				}
			}
			if (divider != 1) {
				for ( var i = 0; i < values.length; i++) {
					newvalues[i] = values[i] / divider;
				}
				max /= divider;
				min /= divider;
			} else {
				newvalues = values;
			}
		}

		var valLen = (max.toString().length > min.toString().length ? max
				.toString().length
				: min.toString().length) + 1;
		var valuesPerImage = Math.floor(1800 / valLen);
		var baseUrl = 'http://chart.apis.google.com/chart?cht=ls&amp;chco=0077CC&amp;chls=1,0,0&amp;chds='+ min + ',' + max;
		var images = Math.ceil(values.length / valuesPerImage);
		var counter = 0;
		var response = '';
		var wid;
		if (values.length < 5) {
			wid = 5;
		} else if (values.length < 10) {
			wid = 4;
		} else if (values.length < 20) {
			wid = 3;
		} else if (values.length < 50) {
			wid = 2;
		} else {
			wid = 1;
		}

		/*
		 * if (stretch) { wid =
		 * Math.ceil(stretch/values.length); if (wid>5) {wid=5;} }
		 */

		for ( var i = 0; i < images; i++) {
			var vals = newvalues.slice(counter,
					counter += valuesPerImage);
			response += "<img style='margin: 0; padding: 0;' border='0' src='"
					+ baseUrl
					+ '&amp;chs='
					+ (wid * vals.length)
					+ 'x15&amp;chd=t:'
					+ vals.join(',') + "' alt='' class='chart-";
			if (images == 1) {
				response += 'full';
			} else {
				if (i > 0 && i + 1 < images) {
					response + 'middle';
				} else if (i == 0) {
					response += 'left';
				} else {
					response += 'right';
				}
			}
			response += "' />";
		}
		return response;
	}
});
Ext.define('Voyant.util.Toolable', {
	requires: ['Voyant.util.Localization','Voyant.util.Api'],
	statics: {
		i18n: {
		},
		api: {
			suppressTools: false
		}
	},
	constructor: function(config) {
		config = config || {};
		if (this.getApiParam && this.getApiParam("suppressTools")=="true") {return;}
		if ("header" in config && config.header===false) {return;}
		var me = this;
		var moreTools = undefined;
		var parent = this.up('component');
		if (config.moreTools) {
			moreTools = [];
			config.moreTools.forEach(function(xtype) {
				 if (xtype && xtype!=this.xtype) {
					moreTools.push(this.getMenuItemFromXtype(xtype));
				 }

			}, this)
		}
		else if (parent && parent.getInitialConfig('moreTools')) {
			moreTools = [];
			 parent.getInitialConfig('moreTools').forEach(function(xtype) {
				 if (xtype && xtype!=this.xtype) {
					moreTools.push(this.getMenuItemFromXtype(xtype));
				 }

			}, this)
		}
		if (moreTools && this.getApplication().getMoreTools) {
			moreTools.push({xtype: 'menuseparator'});
		}
		if (this.getApplication().getMoreTools) {
			moreTools = moreTools || [];
			var app = this.getApplication();
			var tools = app.getMoreTools();
			tools.forEach(function(category) {
				var categories = [];
				category.items.forEach(function(xtype) {
					categories.push(this.getMenuItemFromXtype(xtype))
				}, this)
				moreTools.push({
					text: app.localize(category.i18n),
					glyph: category.glyph,
					menu: {items: categories}
				})
			}, this);
		}			

		var exportItems = undefined;
		var toolsMap = {
//				maximize: {
//					glyph: 'xf08e@FontAwesome',
//					fn: this.maximizeToolClick
//				},
				save: {
					glyph: 'xf08e@FontAwesome',
					fn: this.exportToolClick,
					items: exportItems
				},
				plus: moreTools ? {
					glyph: 'xf17a@FontAwesome',
					items: moreTools
				} : undefined,
				gear: this.showOptionsClick || this.getOptions ? {
					glyph: 'xf205@FontAwesome',
					fn: this.showOptionsClick ? this.showOptionsClick : function(panel) {
						if (panel.isXType("voyanttabpanel")) {panel = panel.getActiveTab()}
						// we're here because the panel hasn't overridden the click function
						Ext.create('Ext.window.Window', {
							title: panel.localize("optionsTitle"),
							modal: true,
			            	panel: panel,
							items: {
								xtype: 'form',
								items: panel.getOptions(),
								listeners: {
									afterrender: function(form) {
										var api = panel.getApiParams(form.getForm().getFields().collect('name'));
										form.getForm().setValues(api);
									}
								},
								buttons: [{
					            	text: panel.localize("reset"),
									glyph: 'xf0e2@FontAwesome',
					            	flex: 1,
					            	panel: panel,
						            ui: 'default-toolbar',
					        		handler: function(btn) {
					        			if (this.mixins && this.mixins["Voyant.util.Api"]) {
					        				this.mixins["Voyant.util.Api"].constructor.apply(this);
					        				if (this.getCorpus && this.getCorpus()) {
					        					this.fireEvent("loadedCorpus", this, this.getCorpus())
					        				}
					        			}
					        			btn.up('window').close();
					        		},
					        		scope: panel
								
								},{xtype: 'tbfill'}, {
					            	text: panel.localize("cancelTitle"),
						            ui: 'default-toolbar',
					                glyph: 'xf00d@FontAwesome',
					        		flex: 1,
					        		handler: function(btn) {
					        			btn.up('window').close();
					        		}
								},{
					            	text: panel.localize("confirmTitle"),
									glyph: 'xf00c@FontAwesome',
					            	flex: 1,
					            	panel: panel,
					        		handler: function(btn) {
					        			function doGlobalUpdate(key, value) {
					        				// set the api value for the app
					        				if (app.setApiParam) {
					        					app.setApiParam(key, value);
					        				}
					        				
					        				// tell the panels, including this one
					        				var panels = app.getViewport().query("panel,chart");
					        				for (var i=0; i<panels.length; i++) {
					        					if (panels[i].setApiParam) {
					        						panels[i].setApiParam(key, value);
					        					}
					        				}
					        				globalUpdate = true;
					        			}
					        			
					        			var values = btn.up('form').getValues();
					        			
					        			// set api values (all of them, not just global ones)
					        			this.setApiParams(values);

					        			var app = this.getApplication();
					        			var corpus = app.getCorpus();
					        			
					        			var globalUpdate = false;
					        			if (values['stopList'] != undefined && values['stopListGlobal'] != undefined && values.stopListGlobal) {
					        				doGlobalUpdate('stopList', values['stopList']);
					        			}
					        			if (values['palette'] != undefined) {
					        				doGlobalUpdate('palette', values['palette']);
					        			}
					        			
					        			if (globalUpdate) {
					        				// trigger a reloading of the app
					        				if (corpus) {
					        					app.dispatchEvent("loadedCorpus", this, corpus);
					        				} else {
					        					app.dispatchEvent("apiParamsUpdated", this, values);
					        				}
					        			}
					        			// fire this even if we have global params since the app dispatch won't reach this tool
					        			if (corpus) {this.fireEvent("loadedCorpus", this, corpus);}
				        				else {this.fireEvent("apiParamsUpdated", this, values);}

					        			btn.up('window').close();
					        		},
					        		scope: panel
					            }]
							},
							bodyPadding: 5
						}).show()
					}
				} : undefined,
				help: {
					glyph: 'xf128@FontAwesome',
					fn: this.helpToolClick
				}
		}
		var tools = [];
		
		// check to see if there are tool objects configured
		if (config.includeTools) {
			for (var tool in config.includeTools) {
				if (typeof config.includeTools[tool] == "object") {
					tools.push(config.includeTools[tool])
				}
			}
		}
		
		
		for (var tool in toolsMap) {
			if (config.includeTools && !config.includeTools[tool] || !toolsMap[tool]) {continue;}
			tools.push({
				type: tool,
				tooltip: this.localize(tool+"Tip"),
				callback: toolsMap[tool].fn,
				xtype: 'toolmenu',
				glyph: toolsMap[tool].glyph,
				items: toolsMap[tool].items
			})
		}
		
		Ext.apply(this, {
			tools: tools
		})
		this.on("afterrender", function() {
			var header = this.getHeader();
			if (header && Ext.os.deviceType=="Desktop" && !this.isXType("corpuscreator") && !this.isXType('notebook')) {
				var el = header.getEl();
				el.on("mouseover", function() {
					this.getHeader().getTools().forEach(function(tool) {
						tool.show();
					})
				}, this);
				el.on("mouseout", function() {
					this.getHeader().getTools().forEach(function(tool) {
						var type = tool.config.type || tool.type; // auto-added tools don't have config.type, e.g. collapse
						if (type && type!='help' && type.indexOf('collapse')==-1) {tool.hide();}
					})
				}, this);
				header.getTools().forEach(function(tool,i) {
					if (tool.config.type!='help') {tool.hide();}
				});
			}
		}, this)
	},
	getMenuItemFromXtype: function(xtype) {
		var xt = xtype;
		var config = this.getApplication().getToolConfigFromToolXtype(xtype);
		if (config && config.tooltip) {
			delete config.tooltip // don't use this for now since it causes problems in the menu
		}
		return Ext.apply(Ext.clone(config), {
			xtype: 'menuitem',
			text: config.title,
			textAlign: 'left',
			handler: function() {this.replacePanel(config.xtype)},
			scope: this
		})
	},
	maximizeToolClick: function(panel) {
		var name = Ext.getClass(panel).getName();
		var parts = name.split(".");
		url = panel.getBaseUrl()+"tool/"+parts[parts.length-1]+"/";
		params = panel.getModifiedApiParams();
		if (!params.corpus && panel.getCorpus && panel.getCorpus()) {
			params.corpus = panel.getCorpus().getId();
		}
		if (params) {url += "?"+Ext.Object.toQueryString(params);}
		panel.openUrl(url);
	},
	exportToolClick: function(panel) {
		if (panel.isXType('voyanttabpanel')) {panel = panel.getActiveTab()}
		var items = window.location.hostname=='beta.voyant-tools.org' ? [{html: "<p class='keyword' style='text-align: center; font-weight: bold; padding: 4px;'>Please note that this is the beta server and you should not count on corpora persisting (for bookmarks, embedding, etc.)."}] : [];
		items.push({
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'url',
	       		boxLabel: "<a href='"+panel.getExportUrl.call(panel)+"' target='_blank'>"+panel.localize('exportViewUrl')+"</a>",
	       		checked: true,
	       		listeners: {
	       			afterrender: function() {
	       				this.boxLabelEl.on("click", function() {
	       					this.up('window').close()
	       				}, this)
	       			}
	       		}
		},{
	       xtype: 'fieldset',
	       collapsible: true,
	       collapsed: true,
	       title: panel.localize('exportViewFieldset'),
	       items: [{
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'embed',
	       		boxLabel: panel.localize('exportViewHtmlEmbed')
	       	},{
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'biblio',
	       		boxLabel: panel.localize('exportViewBiblio')
	       	}]
		})
		if (panel.isXType('grid')) {
			var exportitems = [{
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'gridCurrentHtml',
	       		boxLabel: panel.localize('exportGridCurrentHtml')
    	   },{
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'gridCurrentTsv',
	       		boxLabel: panel.localize('exportGridCurrentTsv')
    	  	}];
			if (!panel.getExportGridAll || panel.getExportGridAll()!=false) {
				exportitems.push({
		       		xtype: 'radio',
		       		name: 'export',
		       		inputValue: 'gridAllJson',
		       		boxLabel: panel.localize('exportGridAllJson')
	    	   },{
		       		xtype: 'radio',
		       		name: 'export',
		       		inputValue: 'gridAllTsv',
		       		boxLabel: panel.localize('exportGridAllTsv')
	    	   })
			}
			items.push({
		       xtype: 'fieldset',
		       collapsible: true,
		       collapsed: true,
		       title: panel.localize('exportGridCurrent'),
	    	   items: exportitems
			})
		}
		if ((!panel.getExportVisualization || panel.getExportVisualization()) && panel.isXType("grid")==false && (panel.down("chart") || panel.getTargetEl().dom.querySelector("canvas") || panel.getTargetEl().dom.querySelector("svg"))) {
			var formats = [{
				xtype: 'radio',
				name: 'export',
				inputValue: 'png',
				boxLabel: panel.localize('exportPng')
			},{
				xtype: 'slider',
				width: 200,
				value: 1,
				minValue: .5,
				maxValue: 10,
				increment: .5,
				labelAlign: 'right',
				decimalPrecision: 1,
				itemId: 'scale',
				fieldLabel: new Ext.Template(panel.localize("scaleLabel")).apply([1]),
				listeners: {
					change: function(slider, newVal) {
						this.setFieldLabel(new Ext.Template(panel.localize("scaleLabel")).apply([newVal]))
					},
					changecomplete: function(slider) {
						slider.previousSibling().setValue(true); // make sure PNG is selected
					}
				}
			}];
			if (panel.getTargetEl().dom.querySelector("svg")) {
				formats.push({
					xtype: 'radio',
					name: 'export',
					inputValue: 'svg',
					boxLabel: panel.localize('exportSvg')
				})
			}
			items.push({
			       xtype: 'fieldset',
			       collapsible: true,
			       collapsed: true,
			       title: panel.localize('exportVizTitle'),
		    	   items: formats
	    	});
		}
		Ext.create('Ext.window.Window', {
			title: panel.localize("exportTitle"),
			modal: true,
			items: {
				xtype: 'form',
				items: items,
				buttons: [{
	            	text: panel.localize("exportTitle"),
					glyph: 'xf08e@FontAwesome',
	            	flex: 1,
	            	panel: panel,
	        		handler: function(btn) {
	        			var form = btn.up('form');
	        			var fn = 'export'+Ext.String.capitalize(form.getValues()['export']);
	        			if (Ext.isFunction(panel[fn])) {
	        				panel[fn].call(panel, panel, form)
	        			}
	        			else {
	        				Ext.Msg.show({
	        				    title: panel.localize('exportError'),
	        				    message: panel.localize('exportNoFunction'),
	        				    buttons: Ext.Msg.OK,
	        				    icon: Ext.Msg.ERROR
	        				});
	        			}
	        			btn.up('window').close();
	        		},
	        		scope: panel
	            }, {
	            	text: panel.localize("cancelTitle"),
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				}]
			},
			bodyPadding: 5
		}).show()
	},
	exportSvg: function(img) {
		var svg = this.getTargetEl().dom.querySelector("svg");
		if (svg) {
			var html = d3.select(svg)
				.attr("version", 1.1)
				.attr("xmlns", "http://www.w3.org/2000/svg")
				.node().parentNode.innerHTML
			Ext.Msg.show({
			    title: this.localize('exportSvgTitle'),
			    message: '<img src="'+'data:image/svg+xml;base64,'+ btoa(unescape(encodeURIComponent(html)))+'" style="float: right; max-width: 200px; max-height: 200px; border: thin dotted #ccc;"/>'+this.localize('exportSvgMessage'),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.INFO,
			    prompt: true,
		        multiline: true,
		        value: html
			});		
		}
	},
	exportPngData: function(img) {
		Ext.Msg.show({
		    title: this.localize('exportPngTitle'),
		    message: '<img class="thumb" src="'+img+'" style="float: right; max-width: 200px; max-height: 200px; border: thin dotted #ccc;"/>'+this.localize('exportPngMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: '<img src="'+img+'" />'
		});
	},
	exportPng: function(panel, form) {
		var scale = 1;
		if (form) {
			form.mask(panel.localize('loading'));

			var slider = form.queryById("scale");
			if (slider && slider.getValue) {
				scale = slider.getValue();
			}
		}
		
var canvasSurface = this.down('draw') || this.down('chart');
		if (canvasSurface && (canvasSurface.isChart || canvasSurface.isCanvas)) {

			// first part taken from EXTJ Draw.getImage()
			// http://docs.sencha.com/extjs/6.2.0/classic/src/Container.js-2.html#Ext.draw.Container-method-getImage
			// reproduced here because we want to scale the image in the canvas, not the final image
			var size = canvasSurface.innerElement.getSize(),
            		surfaces = Array.prototype.slice.call(canvasSurface.items.items),
            		zIndexes = canvasSurface.surfaceZIndexes,
            		image, imageElement,
            		i, j, surface, zIndex;
 
	        // Sort the surfaces by zIndex using insertion sort. 
	        for (j = 1; j < surfaces.length; j++) {
	            surface = surfaces[j];
	            zIndex = zIndexes[surface.type];
	            i = j - 1;
	            while (i >= 0 && zIndexes[surfaces[i].type] > zIndex) {
	                surfaces[i + 1] = surfaces[i];
	                i--;
	            }
	            surfaces[i + 1] = surface;
	        }
	        
	        // next part taken from EXTJS Canvas Flatten
	        // http://docs.sencha.com/extjs/6.2.0/classic/src/Canvas.js-1.html#line897
	        // reproduced here because we want to scale the image when drawing to the new canvas
	        
	        var targetCanvas = document.createElement('canvas'),
            className = Ext.getClassName(surfaces[0]),
            ratio = surfaces[0].devicePixelRatio * scale,
            ctx = targetCanvas.getContext('2d'),
            surface, canvas, rect, i, j, xy;

	        targetCanvas.width = Math.ceil(size.width * ratio);
	        targetCanvas.height = Math.ceil(size.height * ratio);
	
	        
	        for (i = 0; i < surfaces.length; i++) {
	            surface = surfaces[i];
	            if (Ext.getClassName(surface) !== className) {
	                continue;
	            }
	            rect = surface.getRect();
	            surfaceSize = surface.el.getSize();
	            for (j = 0; j < surface.canvases.length; j++) {
	                canvas = surface.canvases[j];
	                xy = canvas.getOffsetsTo(canvas.getParent());
	                ctx.drawImage(canvas.dom, (rect[0] + xy[0]) * ratio, (rect[1] + xy[1]) * ratio, surfaceSize.width*ratio,surfaceSize.height*ratio);
	            }
	        }
	        if (form && form.isVisible()) {form.unmask();}
	        
	        // now we're ready
			return this.exportPngData(targetCanvas.toDataURL());
		}
		
//		var chart = this.down('chart'); // first try finding a chart
//		if (chart) {
//			return this.exportPngData(this.down('chart').getImage().data);
//		}
//
		var targetEl = this.getTargetEl().dom,
			canvas = targetEl.querySelector("canvas"); // next try finding a canvas
		if (canvas) {
			if (scale==1) {
				var data = canvas.toDataURL("image/png");
		        if (form && form.isVisible()) {form.unmask();}
				return this.exportPngData(data);
			}
	        var targetCanvas = document.createElement('canvas'),
            ctx = targetCanvas.getContext('2d');
	        targetCanvas.width = Math.ceil(canvas.width * scale);
	        targetCanvas.height = Math.ceil(canvas.height * scale);

			  var image = new Image;
			  image.src = canvas.toDataURL("image/png");
			  image.panel = this;
			  image.onload = function() {
				  ctx.drawImage(image, 0, 0, targetCanvas.width, targetCanvas.height);
				  img = targetCanvas.toDataURL("image/png");
			        if (form && form.isVisible()) {form.unmask();}
				  this.panel.exportPngData.call(this.panel, img);
			  };	
			  return;
		}
		
		var svg = targetEl.querySelector("svg"); // finally try finding an SVG
		if (svg) {
			var width = targetEl.offsetWidth*scale,
				height = targetEl.offsetHeight*scale
			var clone = svg.cloneNode(true); // we don't want to scale, etc. the original
			clone.setAttribute("version", 1.1)
			clone.setAttribute("xmlns", "http://www.w3.org/2000/svg")
			clone.setAttribute("transform", "scale("+scale+")")
			clone.setAttribute("width", width)
			clone.setAttribute("height", height)
			
			var html = clone.outerHTML,
			  img = 'data:image/svg+xml;base64,'+ btoa(unescape(encodeURIComponent(html)));

			  var canvas = Ext.DomHelper.createDom({tag:'canvas',width: width,height:height}),
			  context = canvas.getContext("2d"), me=this;
			  
			  var image = new Image;
			  image.src = img;
			  image.panel = this;
			  image.onload = function() {
				  context.drawImage(image, 0, 0);
				  img = canvas.toDataURL("image/png");
		        if (form && form.isVisible()) {form.unmask();}
				  return this.panel.exportPngData.call(this.panel, img);
			  };
		}
	},
	exportUrl: function() {
		this.openUrl(this.getExportUrl());
	},
	exportEmbed: function() {
		var asTool = this.isXType('voyantheader')==false;
		console.warn(this.xtype, asTool)
		Ext.Msg.show({
		    title: this.localize('exportViewEmbedTitle'),
		    message: this.localize('exportViewEmbedMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: "<!--	Exported from Voyant Tools (voyant-tools.org).\n"+
	        	"The iframe src attribute below uses a relative protocol to better function with both\n"+
	        	"http and https sites, but if you're embedding this into a local web page (file protocol)\n"+
	        	"you should add an explicit protocol (https if you're using voyant-tools.org, otherwise\n"+
	        	"it depends on this server.\n"+
	        	"Feel free to change the height and width values or other styling below: -->\n"+
	        	"<iframe style='width: "+(asTool ? this.getWidth()+"px" : "100%")+"; height: "+(asTool ? this.getHeight()+"px" : "800px")+";' src='"+this.getExportUrl(asTool)+"'></iframe>"
		});
	},
	exportBiblio: function() {
		var date = new Date();
		Ext.Msg.show({
		    title: this.localize('exportBiblioTitle'),
		    message: '<fieldset><legend>MLA</legend>'+
	    	'Sinclair, Stfan and Geoffrey Rockwell. '+(this.isXType('voyantheader') ? '' : '"'+this.localize('title')+'." ')+
	    	'<i>Voyant Tools</i>. '+Ext.Date.format(date,'Y')+'. Web. '+Ext.Date.format(date,'j M Y')+'. &lt;http://voyant-tools.org&gt;.</fieldset>'+
	    	'<br >'+
	    	'<fieldset><legend>Chicago</legend>'+
	    	'Stfan Sinclair and Geoffrey Rockwell, '+(this.isXType('voyantheader') ? '' : '"'+this.localize('title')+'", ')+
	    	'<i>Voyant Tools</i>, accessed '+Ext.Date.format(date,'F j, Y')+', http://voyant-tools.org.</fieldset>'+
	    	'<br >'+
	    	'<fieldset><legend>APA</legend>'+
	    	'Sinclair, S. &amp; G. Rockwell. ('+Ext.Date.format(date,'Y')+"). "+(this.isXType('voyantheader') ? '' : this.localize('title')+'. ')+
	    	'<i>Voyant Tools</i>. Retrieved '+Ext.Date.format(date,'F j, Y')+', from http://voyant-tools.org</fieldset>',
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO
		});
	},
	exportGridCurrentJson: function(grid, form) {
		var store = grid.getStore();
		var fields = store.getFields();
		var value = "<table>\n\t<thead>\n\t\t<tr>\n";
		var visibleColumns = grid.getColumnManager().headerCt.getVisibleGridColumns();
		values = [];

		function jsonCollector(row) {
			var val = {};
			visibleColumns.forEach(function (column) {
				val[column.text] = row.get(column.dataIndex);
			});
			values.push(val);
		}

		if (store.buffered) {
			store.data.forEach(jsonCollector);
		} else {
			store.each(jsonCollector);
		}

		Ext.Msg.show({
		    title: this.localize('exportDataTitle'),
		    message: this.localize('exportDataJsonMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: Ext.encode(values)
		});
	},
	exportGridCurrentTsv: function(grid, form) {
		var store = grid.getStore();
		var fields = store.getFields();
		var visibleColumns = grid.getColumnManager().headerCt.getVisibleGridColumns();
		var fields = [];
		visibleColumns.forEach(function(column) {
			fields.push(column.text);
		})
		var value = fields.join("\t")+"\n";

		function tsvCollector(row) {
			cells = [];
			visibleColumns.forEach(function (column) {
				var val = row.get(column.dataIndex);
				if (Ext.isString(val)) {
					val = val.replace(/\s+/g, ' '); // get rid of multiple whitespace (including newlines and tabs)
				}
				cells.push(val)
			});
			value += cells.join("\t") + "\n";
		}

		if (store.buffered) {
			store.data.forEach(tsvCollector);
		} else {
			store.each(tsvCollector);
		}

		Ext.Msg.show({
		    title: this.localize('exportDataTitle'),
		    message: this.localize('exportDataTsvMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: value
		});
	},
	exportGridCurrentHtml: function(grid, form) {
		var store = grid.getStore();
		var fields = store.getFields();
		var value = "<table>\n\t<thead>\n\t\t<tr>\n";
		var visibleColumns = grid.getColumnManager().headerCt.getVisibleGridColumns();
		visibleColumns.forEach(function(column) {
			value+="\t\t\t<td>"+column.text+"</td>\n";
		});

		value+="\t\t</tr>\n\t</thead>\n\t<tbody>\n";

		function htmlCollector(row) {
			value += "\t\t<tr>\n";
			visibleColumns.forEach(function (column) {
				var val = row.get(column.dataIndex);
				if (Ext.isString(val)) {
					val = val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&lg;');
				}
				value += "\t\t\t<td>" + val + "</td>\n";
			});
			value += "\t\t</tr>\n";
		}

		if (store.buffered) {
			store.data.forEach(htmlCollector);
		} else {
			store.each(htmlCollector);
		}

		value+="\t</tbody>\n</table>";
		Ext.Msg.show({
		    title: this.localize('exportDataTitle'),
		    message: this.localize('exportDataHtmlMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: value
		});
	},
	exportGridAllJson: function(grid, form) {
		Ext.Msg.confirm(this.localize('exportAllTitle'), this.localize('exportAllJsonWarning'), function(btn) {
			if (btn=='yes') {
				var params = {limit: 0, start: 0};
				Ext.applyIf(params, grid.getStore().getProxy().getExtraParams());
				this.openUrl(this.getTromboneUrl()+"?"+Ext.Object.toQueryString(params));
			}
		}, this)
	},
	exportGridAllTsv: function(grid, form) {
		Ext.Msg.confirm(this.localize('exportAllTitle'), this.localize('exportAllTsvWarning'), function(btn) {
			if (btn=='yes') {
				var params = {limit: 0, start: 0, template: this.getXType()+"2tsv"};
				Ext.applyIf(params, grid.getStore().getProxy().getExtraParams());
				this.openUrl(this.getTromboneUrl()+"?"+Ext.Object.toQueryString(params));
			}
		}, this)
	},
	getExportUrl: function(asTool) {
		// start with the application api
		var api = this.getApplication().getModifiedApiParams();
		var toolForUrl = Ext.getClassName(this).split(".").pop();
		if (this.isXType('voyantheader')==false) {
			delete api.panels; // not needed for individual tools
			// add (and overwrite if need be) this tool's api
			Ext.apply(api, this.getModifiedApiParams());
			if (!asTool) {api.view=toolForUrl;}
		}
		if (!api.corpus) {
			api.corpus = this.getApplication().getCorpus().getAliasOrId();
		}
		return this.getApplication().getBaseUrl()+(asTool ? "tool/"+toolForUrl+"/" : "")+'?'+Ext.Object.toQueryString(api);
	},
	helpToolClick: function(panel) {
		if (panel.isXType('voyanttabpanel')) {panel = panel.getActiveTab()}
		var help = panel.localize('help', {"default": false}) || panel.localize('helpTip');
		if (help==panel._localizeClass(Ext.ClassManager.get("Voyant.util.Toolable"), "helpTip")) {
			panel.openUrl( panel.getBaseUrl()+"docs/#!/guide/" + panel.getXType());
		}
		else {
			Ext.Msg.alert(panel.localize('title'), help +"<p><a href='"+panel.getBaseUrl()+
					"docs/"+ (panel.isXType('voyantheader') ? '' : "#!/guide/"+panel.getXType()) +"' target='voyantdocs'>"+panel.localize("moreHelp")+"</a></p>")
		}
	},
	replacePanel: function(xtype) {
		var corpus = this.getApplication().getCorpus();
		var config = this.getInitialConfig();
		var parent;
		if (this.isXType('voyantheader') && this.getApplication().getViewComponent) {
			parent = this.getApplication().getViewComponent();
			parent.removeAll(true);
			var newTool = parent.add({xtype: xtype});
			if (corpus) {
				this.getApplication().dispatchEvent("loadedCorpus", parent, corpus);
			}
			
			var queryParams = Ext.Object.fromQueryString(document.location.search);
			var url = this.getApplication().getBaseUrl();
			url += '?corpus='+corpus.getAliasOrId();
			url += '&view='+xtype;
			for (var key in queryParams) {
				if (key !== 'corpus' && key !== 'view') {
					url += '&'+key+'='+queryParams[key];
				}
			}
			window.history.pushState({
				corpus: corpus.getAliasOrId(),
				view: xtype
			}, '', url);
		}
		else {
			parent = this.isXType('voyantheader') && this.getApplication().getViewComponent ? this.getApplication().getViewComponent() : this.up("component");
			parent.remove(this, true);
			var newTool = parent.add({xtype: xtype});
			if (parent.isXType("voyanttabpanel")) {
				parent.setActiveTab(newTool)
			}
			if (corpus) {
				newTool.fireEvent("loadedCorpus", newTool, corpus)
			}
		}
		this.getApplication().dispatchEvent('panelChange', this)
	}
});

// from http://www.sencha.com/forum/showthread.php?281658-add-dropdown-menu-to-panel-tool&p=1054579&viewfull=1#post1054579
// and http://www.sencha.com/forum/showthread.php?281953-Glyphs-in-panel-tool&p=1068934&viewfull=1#post1068934

Ext.define('Voyant.util.ToolMenu', {
    extend: 'Ext.panel.Tool',
    alias: 'widget.toolmenu',
    renderTpl: ['<div class="x-menu-tool-hover">' + '</div>'+
            '<tpl if="glyph">' + 
            '<span id="{id}-toolEl" class="{baseCls}-glyph {childElCls}" role="presentation" style="font-family: {glyphFontFamily}; '+
            	'<tpl if="Ext.os.name==\'iOS\'">'+ // FIXME: this is an awful hack..
            		'margin-right: 15px; '+
            	'</tpl>'+
            '">&#{glyph}</span>' + 
            '<tpl else>' + 
            '<img id="{id}-toolEl" src="{blank}" class="{baseCls}-img {baseCls}-{type}' + '{childElCls}" role="presentation"/>' + 
            '</tpl>'],
    privates: {
        onClick: function() {
        	
            var me = this,
            returnValue = me.callParent(arguments);


            if (returnValue && me.items) {
                if (!me.toolMenu) {
                    me.toolMenu = new Ext.menu.Menu({
                        items: me.items
                    });
                }
                me.toolMenu.showAt(0, 0);
                me.toolMenu.showAt(me.getX() + me.getWidth() - me.toolMenu.getWidth(), me.getY() + me.getHeight() + 10);
            }


            return returnValue;
        },
        onDestroy: function() {
            Ext.destroyMembers(this, 'toolMenu'); //destructor
            this.callParent();
        }
    },   
	initComponent: function() {
	    var me = this;
	    me.callParent(arguments);
	
	    var glyph, glyphParts, glyphFontFamily;
	    glyph = me.glyph || 'xf12e@FontAwesome';
	
	    if (glyph) {
	        if (typeof glyph === 'string') {
	            glyphParts = glyph.split('@');
	            glyph = glyphParts[0];
	            glyphFontFamily = glyphParts[1];
	        } else if (typeof glyph === 'object' && glyph.glyphConfig) {
	            glyphParts = glyph.glyphConfig.split('@');
	            glyph = glyphParts[0];
	            glyphFontFamily = glyphParts[1];
	        }
	
	
	        Ext.applyIf(me.renderData, {
	            baseCls: me.baseCls,
	            blank: Ext.BLANK_IMAGE_URL,
	            type: me.type,
	            glyph: glyph,
	            glyphFontFamily: glyphFontFamily
	        });
	    }
	}

});

Ext.define("Voyant.util.Transferable", {
	transferable: ['transfer'],
	transfer: function(source, destination) {
		if (source.transferable) {
			for (var i=0;i<source.transferable.length;i++) {
				var member = source.transferable[i];
				destination[member] = Ext.bind(source[member], destination);
			}
		}
		if (source.mixins) {
			for (mixin in source.mixins) {
				this.transfer(source.mixins[mixin], destination)
			}
		}
	}
})
Ext.define("Voyant.util.Variants", {
	extend: 'Ext.Base',
	constructor: function(variants) {
		this.variants = variants;
		this.map = {};
		this.variants.forEach(function(variant, index) {
			variant.forEach(function(v) {
				this.map[v]=index;
			}, this)
		}, this)
	},
	getVariants: function(terms) {
		var variants = [];
		if (Ext.isString(terms)) {terms = [terms]}
		if (Ext.isArray(terms)) {
			terms.forEach(function(term) {
				if (this.map[term]!=undefined) {
					variants.push.apply(variants, this.variants[this.map[term]]);
				}
			}, this)
		}
		return variants
	}
})
Ext.define("Voyant.util.Downloadable", {
	mixins: ['Voyant.util.Localization'],
	statics: {
		i18n: {
		},
		api: {
			documentFormat: undefined,
			documentFilename: undefined
		}
	},

	downloadFromCorpusId: function(corpusId) {
		var panel = this;
		Ext.create('Ext.window.Window', {
			title: this.localize('exportTitle'),
			modal: true,
			items: {
				xtype: 'form',
				items: {xtype: 'downloadoptions'},
				listeners: {
					afterrender: function(form) {
						// make sure defaults are set based on panel's API
						form.getForm().setValues(panel.getApiParams(['documentFilename','documentFormat']));
						
					}
				},
				buttons: [{
	            	text: this.localize("cancelButton"),
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
		            ui: 'default-toolbar',
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize('downloadButton'),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var values = btn.up('form').getValues();
	        			panel.setApiParams(values);
	        			panel.openDownloadCorpus(corpusId);
	        			btn.up('window').close();
	        		},
	        		scope: this
	            }]
			},
			bodyPadding: 5
		}).show()
	},
	
    openDownloadCorpus: function(corpusId) {
		var url = this.getTromboneUrl()+"?corpus="+corpusId+"&tool=corpus.CorpusExporter&outputFormat=zip"+
			"&zipFilename=DownloadedVoyantCorpus-"+corpusId+".zip"+
			(this.getApiParam("documentFormat") ? "&documentFormat="+this.getApiParam("documentFormat") : '')+
			(this.getApiParam("documentFilename") ? "&documentFilename="+this.getApiParam("documentFilename") : '')
		this.openUrl(url)
    }
})
Ext.define('Voyant.util.Storage', {
	MAX_LENGTH: 950000, // keep it under 1 megabyte
	
	storeResource: function(id, data) {
		var dataString = Ext.encode(data);
		
		if (dataString.length > this.MAX_LENGTH) {
			// split into chunks
			var dfd = new Ext.Deferred();
			
			var numChunks = Math.ceil(dataString.length / this.MAX_LENGTH);
			
			var chunkIds = [];
			for (var i = 0; i < numChunks; i++) {
				chunkIds.push(id+'-chunk'+i);
			}
			this._doStore(id+'-hasChunks', Ext.encode(chunkIds)).then(function() {
				var chunkCount = 0;
				var currIndex = 0;
				for (var i = 0; i < numChunks; i++) {
					var chunkString = dataString.substr(currIndex, this.MAX_LENGTH);
					
					this._doStore(chunkIds[i], chunkString).then(function() {
						chunkCount++;
						if (chunkCount == numChunks) {
							dfd.resolve();
						}
					}, function() {
						dfd.reject();
					}, null, this);
					
					currIndex += this.MAX_LENGTH;
				}
			}, function() {
				dfd.reject();
			}, null, this);
			
			return dfd.promise;
		} else {
			return this._doStore(id, dataString);
		}
	},
	
	_doStore: function(id, dataString) {
		var dfd = new Ext.Deferred();
		Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                resourceId: id,
                storeResource: dataString
            }
        }).then(function(response) {
            dfd.resolve();
        }, function(response) {
            dfd.reject();
        });
		
		return dfd.promise;
	},
	
	getStoredResource: function(id) {
		var dfd = new Ext.Deferred();
		
		Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                verifyResourceId: id+'-hasChunks'
            }
        }).then(function(response) {
        	var json = Ext.decode(response.responseText);
        	if (json && json.storedResource && json.storedResource.id && json.storedResource.id != '') {
            	// chunks
            	this._doGetStored(json.storedResource.id, false).then(function(chunkIds) {
            		var fullData = '';
                    var dataChunks = {};
	            	for (var i = 0; i < chunkIds.length; i++) {
	            		this._doGetStored(chunkIds[i], true).then(function(response) {
	            			var chunkId = response[0];
	            			var value = response[1];
	            			dataChunks[chunkId] = value;
	            			
	            			var done = true;
	            			for (var j = chunkIds.length-1; j >= 0; j--) {
	            				if (dataChunks[chunkIds[j]] === undefined) {
	            					done = false;
	            					break;
	            				}
	            			}
	            			
	            			if (done) {
	            				for (var j = 0; j < chunkIds.length; j++) {
	            					fullData += dataChunks[chunkIds[j]];
	            				}
	            				dfd.resolve(Ext.decode(fullData));
	            			}
	            		}, function() {
	                        dfd.reject();
	                    }, null, this);
	            	}
            	}, function() {
            		dfd.reject();
            	}, null, this);
        	} else {
            	// no chunks
				this._doGetStored(id, false).then(function(value) {
					dfd.resolve(value);
				}, function() {
					dfd.reject();
				}, null, this);
        	}
        }, function() {
        	dfd.reject();
        }, null, this);
		
		return dfd.promise;
	},
	
	_doGetStored: function(id, isChunk) {
		var dfd = new Ext.Deferred();
		
		Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                retrieveResourceId: id,
                failQuietly: true
            }
        }).then(function(response) {
        	var json = Ext.decode(response.responseText);
        	var id = json.storedResource.id;
        	var value = json.storedResource.resource;
        	if (value.length == 0) {
        		dfd.reject();
        	} else {
	        	if (isChunk != true) {
	        		value = Ext.decode(value);
	        		dfd.resolve(value);
	        	} else {
	        		dfd.resolve([id, value]);
	        	}
        	}
        }, function() {
        	dfd.reject();
        }, null, this);
		
		return dfd.promise;
	}
});

Ext.define('Voyant.util.CategoriesManager', {
	
	config: {
		categories: undefined,
		features: undefined,
		featureDefaults: undefined
	},
	
	constructor: function(config) {
		this.setCategories({});
		this.setFeatures({});
		this.setFeatureDefaults({});
		
		config = config || {};
		if (config.categories !== undefined) {
			for (var key in config.categories) {
				var terms = config.categories[key];
				this.addTerms(key, terms);
			}
		}
	},
	
	getCategoryTerms: function(name) {
		return this.getCategories()[name];
	},
	
	addCategory: function(name) {
		if (this.getCategories()[name] === undefined) {
			this.getCategories()[name] = [];
		}
	},
	renameCategory: function(oldName, newName) {
		var terms = this.getCategoryTerms(oldName);
		this.addTerms(newName, terms);
		for (var feature in this.getFeatures()) {
			var value = this.getFeatures()[feature][oldName];
			this.setCategoryFeature(newName, feature, value);
		}
		this.removeCategory(oldName);
		
	},
	removeCategory: function(name) {
		delete this.getCategories()[name];
		for (var feature in this.getFeatures()) {
			delete this.getFeatures()[feature][name];
		}
	},
	
	addTerm: function(category, term) {
		this.addTerms(category, [term]);
	},
	addTerms: function(category, terms) {
		if (!Ext.isArray(terms)) {
			terms = [terms];
		}
		if (this.getCategories()[category] === undefined) {
			this.addCategory(category);
		}
		for (var i = 0; i < terms.length; i++) {
			var term = terms[i];
			if (this.getCategories()[category].indexOf(term) === -1) {
				this.getCategories()[category].push(term);
			}
		}
	},
	removeTerm: function(category, term) {
		this.removeTerms(category, [term]);
	},
	removeTerms: function(category, terms) {
		if (!Ext.isArray(terms)) {
			terms = [terms];
		}
		if (this.getCategories()[category] !== undefined) {
			for (var i = 0; i < terms.length; i++) {
				var term = terms[i];
				var index = this.getCategories()[category].indexOf(term);
				if (index !== -1) {
					this.getCategories()[category].splice(index, 1);
				}
			}
		}
	},
	
	getCategoryForTerm: function(term) {
		for (var category in this.getCategories()) {
			if (this.getCategories()[category].indexOf(term) != -1) {
				return category;
			}
		}
		return undefined;
	},
	getFeatureForTerm: function(feature, term) {
		return this.getCategoryFeature(this.getCategoryForTerm(term), feature);
	},
	
	addFeature: function(name, defaultValue) {
		if (this.getFeatures()[name] === undefined) {
			this.getFeatures()[name] = {};
		}
		if (defaultValue !== undefined) {
			this.getFeatureDefaults()[name] = defaultValue;
		}
	},
	removeFeature: function(name) {
		delete this.getFeatures()[name];
		delete this.getFeatureDefaults()[name];
	},
	setCategoryFeature: function(categoryName, featureName, featureValue) {
		if (this.getFeatures()[featureName] === undefined) {
			this.addFeature(featureName);
		}
		this.getFeatures()[featureName][categoryName] = featureValue;
	},
	getCategoryFeature: function(categoryName, featureName) {
		var value = undefined;
		if (this.getFeatures()[featureName] !== undefined) {
			value = this.getFeatures()[featureName][categoryName];
			if (value === undefined) {
				value = this.getFeatureDefaults()[featureName];
				if (Ext.isFunction(value)) {
					value = value();
				}
			}
		}
		return value;
	},
	
	setColorTermAssociations: function() {
        for (var category in this.getCategories()) {
            var color = this.getCategoryFeature(category, 'color');
            if (color !== undefined) {
                var rgb = this.hexToRgb(color);
                var terms = this.getCategoryTerms(category);
                for (var i = 0; i < terms.length; i++) {
                    this.colorTermAssociations.replace(terms[i], rgb);
                }
            }
        }
    },
	
	getCategoryExportData: function() {
		return {
			categories: this.getCategories(),
			features: this.getFeatures()
		};
	},
	
	loadCategoryData: function(id) {
        var dfd = new Ext.Deferred();
        
        Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                retrieveResourceId: id,
                failQuietly: true
            }
        }).then(function(response) {
            var json = Ext.decode(response.responseText);
            var id = json.storedResource.id;
            var value = json.storedResource.resource;
            if (value.length == 0) {
                dfd.reject();
            } else {
                value = Ext.decode(value);
                
                this.setCategories(value.categories);
                this.setFeatures(value.features);
                
                dfd.resolve(value);
            }
        }, function() {
            dfd.reject();
        }, null, this);
        
        return dfd.promise;
    },
    
    saveCategoryData: function(data) {
        data = data || this.getCategoryExportData();
        
        var dfd = new Ext.Deferred();
        
        var dataString = Ext.encode(data);
        Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                storeResource: dataString
            }
        }).then(function(response) {
            var json = Ext.util.JSON.decode(response.responseText);
            var id = json.storedResource.id;
            dfd.resolve(id);
        }, function(response) {
            dfd.reject();
        });
        
        return dfd.promise;
    }
});

/*
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Ext.define("Voyant.util.DiacriticsRemover", {
    diacriticsMap: {},
    
    constructor: function() {
        var defaultDiacriticsRemovalMap = [
            {'base':'A', 'letters':'\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F'},
            {'base':'AA','letters':'\uA732'},
            {'base':'AE','letters':'\u00C6\u01FC\u01E2'},
            {'base':'AO','letters':'\uA734'},
            {'base':'AU','letters':'\uA736'},
            {'base':'AV','letters':'\uA738\uA73A'},
            {'base':'AY','letters':'\uA73C'},
            {'base':'B', 'letters':'\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181'},
            {'base':'C', 'letters':'\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E'},
            {'base':'D', 'letters':'\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779\u00D0'},
            {'base':'DZ','letters':'\u01F1\u01C4'},
            {'base':'Dz','letters':'\u01F2\u01C5'},
            {'base':'E', 'letters':'\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E'},
            {'base':'F', 'letters':'\u0046\u24BB\uFF26\u1E1E\u0191\uA77B'},
            {'base':'G', 'letters':'\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E'},
            {'base':'H', 'letters':'\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D'},
            {'base':'I', 'letters':'\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197'},
            {'base':'J', 'letters':'\u004A\u24BF\uFF2A\u0134\u0248'},
            {'base':'K', 'letters':'\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2'},
            {'base':'L', 'letters':'\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780'},
            {'base':'LJ','letters':'\u01C7'},
            {'base':'Lj','letters':'\u01C8'},
            {'base':'M', 'letters':'\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C'},
            {'base':'N', 'letters':'\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4'},
            {'base':'NJ','letters':'\u01CA'},
            {'base':'Nj','letters':'\u01CB'},
            {'base':'O', 'letters':'\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C'},
            {'base':'OI','letters':'\u01A2'},
            {'base':'OO','letters':'\uA74E'},
            {'base':'OU','letters':'\u0222'},
            {'base':'OE','letters':'\u008C\u0152'},
            {'base':'oe','letters':'\u009C\u0153'},
            {'base':'P', 'letters':'\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754'},
            {'base':'Q', 'letters':'\u0051\u24C6\uFF31\uA756\uA758\u024A'},
            {'base':'R', 'letters':'\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782'},
            {'base':'S', 'letters':'\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784'},
            {'base':'T', 'letters':'\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786'},
            {'base':'TZ','letters':'\uA728'},
            {'base':'U', 'letters':'\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244'},
            {'base':'V', 'letters':'\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245'},
            {'base':'VY','letters':'\uA760'},
            {'base':'W', 'letters':'\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72'},
            {'base':'X', 'letters':'\u0058\u24CD\uFF38\u1E8A\u1E8C'},
            {'base':'Y', 'letters':'\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE'},
            {'base':'Z', 'letters':'\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762'},
            {'base':'a', 'letters':'\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250'},
            {'base':'aa','letters':'\uA733'},
            {'base':'ae','letters':'\u00E6\u01FD\u01E3'},
            {'base':'ao','letters':'\uA735'},
            {'base':'au','letters':'\uA737'},
            {'base':'av','letters':'\uA739\uA73B'},
            {'base':'ay','letters':'\uA73D'},
            {'base':'b', 'letters':'\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253'},
            {'base':'c', 'letters':'\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184'},
            {'base':'d', 'letters':'\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A'},
            {'base':'dz','letters':'\u01F3\u01C6'},
            {'base':'e', 'letters':'\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD'},
            {'base':'f', 'letters':'\u0066\u24D5\uFF46\u1E1F\u0192\uA77C'},
            {'base':'g', 'letters':'\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F'},
            {'base':'h', 'letters':'\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265'},
            {'base':'hv','letters':'\u0195'},
            {'base':'i', 'letters':'\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131'},
            {'base':'j', 'letters':'\u006A\u24D9\uFF4A\u0135\u01F0\u0249'},
            {'base':'k', 'letters':'\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3'},
            {'base':'l', 'letters':'\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747'},
            {'base':'lj','letters':'\u01C9'},
            {'base':'m', 'letters':'\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F'},
            {'base':'n', 'letters':'\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5'},
            {'base':'nj','letters':'\u01CC'},
            {'base':'o', 'letters':'\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275'},
            {'base':'oi','letters':'\u01A3'},
            {'base':'ou','letters':'\u0223'},
            {'base':'oo','letters':'\uA74F'},
            {'base':'p','letters':'\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755'},
            {'base':'q','letters':'\u0071\u24E0\uFF51\u024B\uA757\uA759'},
            {'base':'r','letters':'\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783'},
            {'base':'s','letters':'\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B'},
            {'base':'t','letters':'\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787'},
            {'base':'tz','letters':'\uA729'},
            {'base':'u','letters': '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289'},
            {'base':'v','letters':'\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C'},
            {'base':'vy','letters':'\uA761'},
            {'base':'w','letters':'\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73'},
            {'base':'x','letters':'\u0078\u24E7\uFF58\u1E8B\u1E8D'},
            {'base':'y','letters':'\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF'},
            {'base':'z','letters':'\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763'}
        ];
        
        this.diacriticsMap = {};
        for (var i=0; i < defaultDiacriticsRemovalMap .length; i++){
            var letters = defaultDiacriticsRemovalMap [i].letters;
            for (var j=0; j < letters.length ; j++){
                this.diacriticsMap[letters[j]] = defaultDiacriticsRemovalMap [i].base;
            }
        }
    },
    
    // "what?" version ... http://jsperf.com/diacritics/12
    removeDiacritics: function(str) {
        return str.replace(/[^\u0000-\u007E]/g, function(a){
            return this.diacriticsMap[a] || a; 
        }.bind(this));
    }

});
Ext.define("Voyant.notebook.util.Show", {
	transferable: ['show'],
	
    /**
	 * Shows a one-line summary of this object. For example, for a corpus:
	 * 
	 * 	new Corpus("Hello World!").show(true);
	 * 
	 * @param {boolean} [withID] Includes the corpus ID in parentheses at the end, if true.
	 */
	show: function(len) { // this is for instances
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			show.call(this, this.getString ? this.getString(len) : this.toString(), !this.getString && Ext.isNumber(len) ? len : undefined);
		}
	},
	statics: {
		show: function(contents, len) {
			var arg = contents;
			if (this.then) {
				this.then(function(val) {
					show.call(val, val, arg);
				})
			} else {
				if (Ext.isArray(contents)) {
					var allContents = "";
					contents.forEach(function(content) {
						allContents += content.getString ? content.getString() : content.toString();
					});
					contents = allContents;
				} else if (Ext.isString(this) || this instanceof String) {
					if (Ext.isNumber(contents)) {len = contents;}
					contents = this;
				}
				contents = contents.getString ? contents.getString() : contents.toString();
				if (len && Ext.isNumber(len)) {contents = contents.substring(0,len)}
				if (Voyant.notebook.util.Show.SINGLE_LINE_MODE==false) {contents="<div class='"+Voyant.notebook.util.Show.MODE+"'>"+contents+"</div>";}
				Voyant.notebook.util.Show.TARGET.insertHtml('beforeEnd',contents);
			}
		},
		showError: function(error, more) {
			var mode = Voyant.notebook.util.Show.MODE;
			Voyant.notebook.util.Show.MODE='error';
			
			if (this instanceof Voyant.util.ResponseError) {
				error = this;
			}
			if (error instanceof Voyant.util.ResponseError) {
				if (console) {console.error(error.getResponse())}
				more = error.getResponse().responseText
				error = error.getMsg();
			}
			
			else {

				if (error.stack && !more) {more=error.stack}
				if (more && Ext.isString(more)===false) {more=more.toString()}
				
			}

			if (console) {console.error(error)}
			if (more) {
				if (console) {console.error(more);}
				error="<h3>"+error.toString()+"</h3><pre>"+Ext.String.htmlEncode(more)+'</pre>';
			}
			show(error);
			Voyant.notebook.util.Show.MODE = mode;
		},
		TARGET : null,
		MODE: 'info',
		SINGLE_LINE_MODE : false
	}
});

String.prototype.show = Voyant.notebook.util.Show.show;
var show = Voyant.notebook.util.Show.show;
var showError = Voyant.notebook.util.Show.showError;

Ext.define("Voyant.notebook.util.Embed", {
	transferable: ['embed'],
	embed: function() { // this is for instances
		embed.apply(this, arguments);
	},
	constructor: function(config) {
		var me = this;
	},
	statics: {
		i18n: {},
		api: {
			embeddedParameters: undefined,
			embeddedConfig: undefined
		},
		embed: function(cmp, config) {
			if (this.then) {
				this.then(function(embedded) {
					embed.call(embedded, cmp, config)
				})
			} else if (Ext.isArray(cmp)) {
				Voyant.notebook.util.Show.SINGLE_LINE_MODE=true;
				show("<table><tr>");
				cmp.forEach(function(embeddable) {
					show("<td>");
					if (Ext.isArray(embeddable)) {
						if (embeddable[0].embeddable) {
							embeddable[0].embed.apply(embeddable[0], embeddable.slice(1))
						} else {
							embed.apply(this, embeddable)
						}
					} else {
						embed.apply(this, embeddable);
					}
					show("</td>")
					
				})
//				for (var i=0; i<arguments.length; i++) {
//					var unit = arguments[i];
//					show("<td>")
//					unit[0].embed.call(unit[0], unit[1], unit[2]);
//					show("</td>")
//				}
				show("</tr></table>")
				Voyant.notebook.util.Show.SINGLE_LINE_MODE=false;
				return
			} else {
				// use the default (first) embeddable panel if no panel is specified
				if (this.embeddable && (!cmp || Ext.isObject(cmp))) {
					// if the first argument is an object, use it as config instead
					if (Ext.isObject(cmp)) {config = cmp;}
					cmp = this.embeddable[0];
				}
				if (Ext.isString(cmp)) {
					cmp = Ext.ClassManager.getByAlias('widget.'+cmp.toLowerCase()) || Ext.ClassManager.get(cmp);
				}
				var isEmbedded = false;
				if (Ext.isFunction(cmp)) {
					var name = cmp.getName();
					if (this.embeddable && Ext.Array.each(this.embeddable, function(item) {
							if (item==name) {
								config = config || {};
								var embeddedParams = {};
								
								for (key in Ext.ClassManager.get(Ext.getClassName(cmp)).api) {
									if (key in config) {
										embeddedParams[key] = config[key]
									}
								}
								if (!embeddedParams.corpus) {
									if (Ext.getClassName(this)=='Voyant.data.model.Corpus') {
										embeddedParams.corpus = this.getId();
									} else if (this.getCorpus) {
										var corpus = this.getCorpus();
										if (corpus) {
											embeddedParams.corpus = this.getCorpus().getId();
										}
									}
								}
								Ext.applyIf(config, {
									style: 'width: '+(config.width || '90%') + (Ext.isNumber(config.width) ? 'px' : '')+
										'; height: '+(config.height  || '400px') + (Ext.isNumber(config.height) ? 'px' : '')
								});
								delete config.width;
								delete config.height;
								
								var corpus = embeddedParams.corpus;
								delete embeddedParams.corpus;
								
		    	    	    	Ext.applyIf(embeddedParams, Voyant.application.getModifiedApiParams());
								
		    	    	    	
								var embeddedConfigParamEncodded = Ext.encode(embeddedParams);
								var embeddedConfigParam = encodeURIComponent(embeddedConfigParamEncodded);

								var iframeId = Ext.id();
								var url = Voyant.application.getBaseUrlFull()+"tool/"+name.substring(name.lastIndexOf(".")+1)+'/?';
								if (true || embeddedConfigParam.length>1800) {
									show('<iframe style="'+config.style+'" id="'+iframeId+'" name="'+iframeId+'"></iframe>');
									var dfd = Voyant.application.getDeferred(this);
					    	    	Ext.Ajax.request({
					    	    	    url: Voyant.application.getTromboneUrl(),
					    	    	    params: {
					    	        		tool: 'resource.StoredResource',
					    	        		storeResource: embeddedConfigParam
					    	    	    }
					    	    	}).then(function(response) {
				    	    	    	var json = Ext.util.JSON.decode(response.responseText);
				    	    	    	var params = {
				    	    	    		minimal: true,
				    	    	    		embeddedApiId: json.storedResource.id
				    	    	    	}
				    	    	    	if (corpus) {
				    	    	    		params.corpus = corpus;
				    	    	    	}
				    	    	    	Ext.applyIf(params, Voyant.application.getModifiedApiParams());
				    	    	    	document.getElementById(iframeId).setAttribute("src",url+Ext.Object.toQueryString(params));
										dfd.resolve();
					    	    	}).otherwise(function(response) {
					    	    		showError(response);
					    	    		dfd.reject();
					    	    	})
								} else {
									show('<iframe src="'+url+embeddedConfigParam+'" style="'+config.style+'" id="'+iframeId+'" name="'+iframeId+'"></iframe>');
								}
								isEmbedded = true;
								return false;
							}
						}, this)===true) {
						Voyant.notebook.util.Embed.showWidgetNotRecognized.call(this);
					}
					if (!isEmbedded) {
						var embedded = Ext.create(cmp, config);
						embedded.embed(config);
						isEmbedded = true;
					}
				}
				if (!isEmbedded) {
					
					Voyant.notebook.util.Embed.showWidgetNotRecognized.call(this);
				}
			}
		},
		showWidgetNotRecognized: function() {
			var msg = Voyant.notebook.util.Embed.i18n.widgetNotRecognized;
			if (this.embeddable) {
				msg += Voyant.notebook.util.Embed.i18n.tryWidget+'<ul>'+this.embeddable.map(function(cmp) {
					var widget = cmp.substring(cmp.lastIndexOf(".")+1).toLowerCase()
					return "\"<a href='../../docs/#!/guide/"+widget+"' target='voyantdocs'>"+widget+"</a>\""
				}).join(", ")+"</ul>"
			}
			showError(msg)
		}

	}
})

embed = Voyant.notebook.util.Embed.embed
Ext.define('Voyant.data.model.AnalysisToken', {
    extend: 'Ext.data.Model',
    idProperty: 'term',
    fields: [
         {name: 'term'},
         {name: 'rawFreq', type: 'int'},
         {name: 'relativeFreq', type: 'number'},
         {name: 'cluster', type: 'int'},
         {name: 'clusterCenter', type: 'boolean'},
         {name: 'vector'}
    ]
});
Ext.define('Voyant.data.model.Context', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'docIndex', 'type': 'int'},
             {name: 'position', 'type': 'int'},
             {name: 'docId'},
             {name: 'left'},
             {name: 'keyword'},
             {name: 'term'},
             {name: 'right'}
        ],

        getDocIndex: function() {return this.get("docIndex")},
        getLeft: function() {return this.get("left")},
        getMiddle: function() {return this.get("middle")},
        getHighlightedMiddle: function() {return "<span class='keyword'>"+this.getMiddle()+"</span>"},
        getRight: function() {return this.get("right")},
        getPosition: function() {return this.get("position")},
        getHighlightedContext: function() {return this.getLeft()+this.getHighlightedMiddle()+this.getRight();}
	
});
Ext.define('Voyant.data.model.CorpusFacet', {
    extend: 'Ext.data.Model',
    idProperty: 'label',
    fields: [
             {name: 'facet'},
             {name: 'label'},
             {name: 'inDocumentsCount', type: 'int'}
    ],
    getLabel: function() {
    	return this.get('label')
    },
    getFacet: function() {
    	return this.get('facet')
    },
	getInDocumentsCount: function() {
		return this.get('inDocumentsCount')
	}
});
Ext.define('Voyant.data.model.CorpusCollocate', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'term'},
             {name: 'rawFreq', type: 'int'},
             {name: 'contextTerm'},
             {name: 'contextTermRawFreq', type: 'int'}
    ],
    
    getTerm: function() {return this.getKeyword()},
    getRawFreq: function() {return this.getKeywordRawFreq()},
    getKeyword: function() {return this.get('term');},
    getKeywordRawFreq: function() {return this.get('rawFreq');},
    getContextTerm: function() {return this.get('contextTerm');},
    getContextTermRawFreq: function() {return this.get('contextTermRawFreq');}
});
/**
 * Corpus Term
 */
Ext.define('Voyant.data.model.CorpusTerm', {
    extend: 'Ext.data.Model',
    idProperty: 'term', // should be unique
    fields: [
             {name: 'id'},
             {name: 'rawFreq', type: 'int'},
             {name: 'inDocumentsCount', type: 'int'},
             {name: 'relativeFreq', type: 'float'},
             {name: 'relativePeakedness', type: 'float'},
             {name: 'relativeSkewness', type: 'float'},
             {name: 'comparisonRelativeFreqDifference', type: 'float'},
             {name: 'distributions'},
             {name: 'typeTokenRatio-lexical', type: 'float', calculate:  function(data) {
        	 	return data['typesCount-lexical']/data['tokensCount-lexical'];
             }}
    ],
    
    /**
     * Get the term.
     * @returns {String} Returns the term.
     */
    getTerm: function() {
    	return this.get('term');
    },
    
    /**
     * Get the term's raw frequency.
     * @returns {Number} Returns the term's frequency.
     */
	getRawFreq: function() {
		return parseInt(this.get('rawFreq'));
	},
	
	getInDocumentsCount: function() {
		return parseInt(this.get('inDocumentsCount'));
	},
	
	getDistributions: function() {
		return this.get('distributions');
	},
	
	/**
	 * Show a one line summary of this term.
	 */
	show: function(config) {
		show(this.getString(config))
	},
	
	getString: function() {
		return this.getTerm()+": "+this.getRawFreq();
	}
});
Ext.define('Voyant.data.model.CorpusNgram', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'term'},
             {name: 'length', type: 'int'},
             {name: 'rawFreq', type: 'int'},
             {name: 'distributions'}
        ],
    getTerm: function() {return this.get('term');}
});
Ext.define('Voyant.data.model.Dimension', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'percentage', type: 'number'}
    ]
});
Ext.define('Voyant.data.model.Document', {
    extend: 'Ext.data.Model',
    //requires: ['Voyant.data.store.DocumentTerms'],
    fields: [
             {name: 'corpus'},
             {name: 'id'},
             {name: 'index', type: 'int'},
             {name: 'tokensCount-lexical', type: 'int'},
             {name: 'typesCount-lexical', type: 'int'},
             {name: 'typeTokenRatio-lexical', type: 'float', calculate:  function(data) {
        	 	return data['typesCount-lexical']/data['tokensCount-lexical'];
             }},
             {name: 'lastTokenStartOffset-lexical', type: 'int'},
             {name: 'title'},
             {name: 'language', convert: function(data) {return Ext.isEmpty(data) ? '' : data;}},
             {name: 'sentencesCount', type: 'int'},
             {name: 'averageWordsPerSentence', type: 'float', calculate:  function(data) {
        	 	return data['sentencesCount'] ? data['tokensCount-lexical'] / data['sentencesCount'] : 0;
			 }},
			 {name: 'css', type: 'string'}
    ],
    
    getLexicalTokensCount: function() {
    	return this.get('tokensCount-lexical')
    },
    
    getLexicalTypeTokenRatio: function() {
    	return this.get('typeTokenRatio-lexical')
    },
    
    loadDocumentTerms: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			config = config || {};
			if (Ext.isNumber(config)) {
				config = {limit: config};
			}
			Ext.applyIf(config, {
				limit: 0
			})
			var documentTerms = this.getDocumentTerms();
			documentTerms.load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(documentTerms)
					} else {
						dfd.reject(operation)
					}
				}
			})
			return dfd.promise
		}
    	
    },
    
    loadTokens: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			config = config || {};
			if (Ext.isNumber(config)) {
				config = {limit: config};
			}
			Ext.applyIf(config, {
				limit: 0
			})
			var tokens = this.getTokens({});
			tokens.load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(tokens)
					} else {
						dfd.reject(operation)
					}
				}
			})
			return dfd.promise
		}
    	
    },
    
    getTokens: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
	    	config = config || {};
	    	Ext.applyIf(config, {
	    		proxy: {}
	    	});
	    	Ext.applyIf(config.proxy, {
	    		extraParams: {}
	    	})
	    	Ext.applyIf(config.proxy.extraParams, {
	    		docIndex: this.get('index')
	    	})
	    	Ext.apply(config, {
	    		docId: this.get('id')
	    	});
	    	return this.get('corpus').getTokens(config);
		}
    },

    getDocumentTerms: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
	    	config = config || {};
	    	Ext.applyIf(config, {
	    		proxy: {}
	    	});
	    	Ext.applyIf(config.proxy, {
	    		extraParams: {}
	    	})
	    	Ext.applyIf(config.proxy.extraParams, {
	    		docIndex: this.get('index')
	    	})
	    	if (config.corpus) {
	    		return config.corpus.getDocumentTerms(config);
	    	}
	    	return this.get('corpus').getDocumentTerms(config); // FIXME: when does this happen?
		}
    },
    
    getIndex: function() {
    	return this.get('index');
    },
    
    getId: function() {
    	return this.get('id');
    },
    
    getFullLabel: function() {
    	var author = this.getAuthor();
    	return this.getTitle() + (author ? "("+author+")" : ''); // TODO: complete full label
    },
    
    getTitle: function() {
    	var title = this.get('title');
    	if (title === undefined) title = '';
    	title = Ext.isArray(title) ? title.join("; ") : title;
    	title = title.trim().replace(/\s+/g, ' '); // remove excess whitespace
    	return title;
    },
    
    getTruncated: function(string, max) {
  		if (string.length > max) {
				// maybe a file or URL?
				var slash = string.lastIndexOf("/");
				if (slash>-1) {
					string = string.substr(slash+1);
				}
				
				if (string.length>max) {
					var space = string.indexOf(" ", max-5);
					if (space < 0 || space > max) {
						space = max;
					}
					string = string.substring(0, space) + "";
				}
		}
  		return string;
    	
    },
    
    getShortTitle: function() {
     	var title = this.getTitle();
     	title = title.replace(/\.(html?|txt|xml|docx?|pdf|rtf|\/)$/,'');
     	title = title.replace(/^(the|a|le|l'|un|une)\s/,'');
     	return this.getTruncated(title, 25);
    },
    
    getTinyTitle: function() {
    	return this.getTruncated(this.getShortTitle(), 10);
    },
    
    getShortLabel: function() {
    	var author = this.getAuthor(25);
    	return (parseInt(this.getIndex())+1) + ') <i>' + this.getShortTitle() + "</i>" +(author ? " ("+author+")" : '')
    },
    
    getTinyLabel: function() {
    	return (parseInt(this.getIndex())+1) + ') ' + this.getTinyTitle();
    },
    
    getAuthor: function(max) {
    	var author = this.get('author') || "";
    	author = Ext.isArray(author) ? author.join("; ") : author;
    	author = author.trim().replace(/\s+/g, ' ');
    	return max ? this.getTruncated(author, max) : author;
    },
    
    getCorpusId: function() {
    	return this.get('corpus').getAliasOrId();
    },
    
    isPlainText: function() {
    	if (this.get("extra.Content-Type") && new RegExp("plain","i").test(this.get("extra.Content-Type"))) {
    		return true
    	}
    	return false;
    },
    
    getAverageWordsPerSentence: function() {
    	return this.get("averageWordsPerSentence");
    },
    
    show: function() {
    	show(this.getFullLabel())
    },
    
    getCorpus: function() {
    	return this.get('corpus');
    },
    
    
    getText: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
	    	config = config || {};
	    	Ext.apply(config, {
        		tool: 'corpus.DocumentTokens',
        		corpus: this.getCorpusId()
	    	})
	    	this.getTokens(config).then(function(tokens) {
	    		dfd.resolve(tokens);
	    	});
	    	return dfd.promise
		}
    },
    
    getPlainText: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
	    	config = config || {};
	    	Ext.apply(config, {
    			outputFormat: "text",
    			template: "docTokens2text",
    			noOthers: true
	    	});
			return this.getText();
		}
    	
    },
    
    getLemmasArray: function(config) {
    	config = config || {};
    	config.docId = this.getId();
		return this.getCorpus().getLemmasArray(config);
//		if (this.then) {
//			return Voyant.application.getDeferredNestedPromise(this, arguments);
//		} else {
//	    	config = config || {};
//	    	Ext.apply(config, {
//    			docId: this.getId()
//	    	});
//			return this.getCorpus().getLemmasArray(config);
//		}
    },
    
    getEntities: function(config) {
    	config = config || {};
    	Ext.applyIf(config, {
    		proxy: {}
    	});
    	Ext.applyIf(config.proxy, {
    		extraParams: {}
    	})
    	Ext.applyIf(config.proxy.extraParams, {
    		docIndex: this.get('index')
    	})
		return Ext.create("Voyant.data.store.DocumentEntities", Ext.apply(config, {corpus: this.getCorpus(), docId: this.getId()}));
    },
    
    loadEntities: function(config) {
		var me = this;
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			this.getEntities().load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(records)
					} else {
						dfd.reject(operation.error.response);
					}
				}
			})
			return dfd.promise
		}
	},
	
	getCSS: function() {
		return this.get('css')
	}
    
});
Ext.define('Voyant.data.model.DocumentEntity', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'term'},
             {name: 'docIndex', 'type': 'int'},
             {name: 'rawFreq', type: 'int'},
             {name: 'type'},
             {name: 'positions'}
        ],
    getTerm: function() {return this.get('term');},
    getDocIndex: function() {return this.get('docIndex')},
    getRawFreq: function() {return this.get('rawFreq')},
    getPositions: function() {return this.get('positions')}
});
Ext.define('Voyant.data.model.DocumentQueryMatch', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'count', 'type': 'int'},
             {name: 'query'},
             {name: 'distributions'}
        ],
    getCount: function() {return this.get('count')},
    getDistributions: function() {return this.get("distributions")},
    getDocIds: function() {return this.get("docIds")}
});
Ext.define('Voyant.data.model.DocumentTerm', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'term'},
             {name: 'docIndex', 'type': 'int'},
             {name: 'docId'},
             {name: 'rawFreq', type: 'int'},
             {name: 'relativeFreq', type: 'float'},
             {name: 'tfidf', type: 'float'},
             {name: 'zscore', type: 'float'},
             {name: 'zscoreRatio', type: 'float'},
             {name: 'distributions'}
        ],
    getTerm: function() {return this.get('term');},
    getDocIndex: function() {return this.get('docIndex')},
    getRawFreq: function() {return this.get('rawFreq')},
    getRelativeFreq: function() {return this.get('relativeFreq')},
    getDistributions: function() {return this.get('distributions')}
});
Ext.define('Voyant.data.model.PrincipalComponent', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'eigenValue', type: 'number'},
        {name: 'eigenVectors'}
    ]
});
/**
 * Related Term
 */
Ext.define('Voyant.data.model.RelatedTerm', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'source'},
             {name: 'target'},
             {name: 'rawFreq', type: 'int'}
    ],
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getSource: function() {
    	return this.get('source');
    },
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getTarget: function() {
    	return this.get('target');
    },
    
	/**
	 * Show a one line summary of this term.
	 */
	show: function(config) {
		show(this.getString(config))
	},
	
	getString: function() {
		return this.getSource()+"-"+this.getTarget();
	}
});
Ext.define('Voyant.data.model.StatisticalAnalysis', {
    extend: 'Ext.data.Model',
    requires: ['Voyant.data.model.PrincipalComponent', 'Voyant.data.model.Dimension', 'Voyant.data.model.AnalysisToken'],
    fields: [
         {name: 'id'}
//         ,{name: 'dimensions', reference: 'Voyant.data.model.Dimension'}
//         ,{name: 'tokens', reference: 'Voyant.data.model.AnalysisToken'}
    ]
    
	// alternative access methods to "reference" or "hasMany"
	,getPrincipalComponents: function() {
		var pcs = [];
		this.data.principalComponents.forEach(function(pc) {
			pcs.push(Ext.create('Voyant.data.model.PrincipalComponent', pc));
		});
		return pcs;
	}
	,getDimensions: function() {
		var dimensions = [];
		this.data.dimensions.forEach(function(dim) {
			dimensions.push(Ext.create('Voyant.data.model.Dimension', {percentage: dim}));
		});
		return dimensions;
	}
	,getTokens: function() {
		var tokens = [];
		this.data.tokens.forEach(function(tok) {
			tokens.push(Ext.create('Voyant.data.model.AnalysisToken', tok));
		});
		return tokens;
	}


//    ,hasMany: [{
//    	name: 'dimensions', model: 'Voyant.data.model.Dimension'
//    },{
//    	name: 'tokens', model: 'Voyant.data.model.AnalysisToken'
//    }]
});
Ext.define('Voyant.data.model.Token', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'docId'},
             {name: 'docIndex', type: 'int'},
             {name: 'token'},
             {name: 'rawFreq'},
             {name: 'tokenType'},
             {name: 'position', type: 'int'},
             {name: 'startOffset', type: 'int'},
             {name: 'endOffset', type: 'int'}
        ],
    statics: {
    	getInfoFromElement: function(arg) {
    		if (arg && arg.getId) {
    			var parts = arg.getId().split("_");
    			return {
    				docIndex: parseInt(parts[1]),
    				position: parseInt(parts[2])
    			};
    		}
    	}
    },
	isWord: function() {
		return this.getTokenType()=='lexical'; // maybe something else later?
	},
	isStopword: function() {
		return this.get("stopword")=="true";
	},
	getTokenType: function() {
		return this.get("tokenType");
	},
	getId: function() {
		return ["",this.getDocIndex(),this.getPosition()].join("_");
	},
	getDocIndex: function() {
		return this.get("docIndex");
	},
	getDocId: function() {
		return this.get("docId");
	},
	getTerm: function() {
		return this.get("term");
	},
	getTermWithLineSpacing: function(isPlainText) {
		var term = this.getTerm().replace(/<\/?\w+\b.*?>/g, "<br /><br />").replace(/>\s+</g,"><").replace(/<br \/><br \/>(<br \/>)+/g,"<br \/><br \/>");
		if (isPlainText) {term = term.replace(/(\r\n|\r|\n)\s*/g,"<br />");};
		return term;
	},
	getPosition: function() {
		return this.get("position");
	},
	getDocumentRawFreq: function() {
		return this.get("rawFreq");
	}
});
/**
 * Related Term
 */
Ext.define('Voyant.data.model.TermCorrelation', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'source'},
             {name: 'target'},
             {name: 'correlation', type: 'float'},
             {name: 'significance', type: 'float'},
             {name: 'source-term', calculate: function(data) {return data.source.term}},
             {name: 'target-term', calculate: function(data) {return data.target.term}},
             {name: 'source-distributions', calculate: function(data) {return data.source.distributions}},
             {name: 'target-distributions', calculate: function(data) {return data.target.distributions}}
    ],
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getSource: function() {
    	return this.get('source');
    },
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getTarget: function() {
    	return this.get('target');
    },
    
	/**
	 * Show a one line summary of this term.
	 */
	show: function(config) {
		show(this.getString(config))
	},
	
	getString: function() {
		return this.getSource()+"-"+this.getTarget();
	}
});
Ext.define('Voyant.data.store.VoyantStore', {
	mixins: ['Voyant.util.Localization','Voyant.notebook.util.Embed'],
	config: {
		corpus: undefined,
		parentPanel: undefined
	},
	constructor: function(config, extras) {
		var me = this;
		config = config || {};
		Ext.applyIf(config, {
			remoteSort: true,
			autoLoad: false,
//			listeners: {
//				beforeload: function(store, operation) {
//					var parent = this.getParentPanel();
//					if (parent !== undefined) {
//						var params = parent.getApiParams();
//						operation = operation ? (operation===1 ? {} : operation) : {};
//						operation.params = operation.params || {};
//						for (var key in params) {
//							operation.params[key] = params[key];
//						}
//					}
//				}
//			},
//			scope: this,
			// define buffered configuration even if ignored when this isn't a buffered store
			pagePurgeCount : 0, // don't purge any data
			pageSize : 100, // each request is more intenstive, so do fewer of them then default
			leadingBufferZone : 200 // stay two pages ahead
		});
		config.proxy = config.proxy || {};
		Ext.applyIf(config.proxy, {
			type: 'ajax',
			url: Voyant.application.getTromboneUrl(),
			actionMethods: {read: 'POST'},
			reader: {
				type: 'json',
				rootProperty: extras['proxy.reader.rootProperty'],
				totalProperty: extras['proxy.reader.totalProperty'],
				metaProperty: extras['proxy.reader.metaProperty'] || 'metaData'
			},
			simpleSortMode: true,
			listeners: {
				exception: function(proxy, request, operation) {
					if (me.parentPanel && me.parentPanel.showError) {
						// FIXME: this should probably send the request, not the operation
						me.parentPanel.showError(operation)
					}
				}
			}
		})
		config.proxy.extraParams = config.proxy.extraParams || {};
		Ext.applyIf(config.proxy.extraParams, {
			tool: extras['proxy.extraParams.tool']
		});
		
		if (config.parentPanel !== undefined) {
			Ext.applyIf(config.proxy.extraParams, {
				forTool: config.parentPanel.xtype
			});
			this.setParentPanel(config.parentPanel);
			config.parentPanel.on("loadedCorpus", function(src, corpus) {
				this.setCorpus(corpus);
			}, this);
			config.listeners = config.listeners || {};
			config.listeners.beforeload = {
					fn: function(store, operation) {
						var parent = this.getParentPanel(), proxy = store.getProxy();
						if (parent !== undefined) {

							var params = parent.getApiParams();
							operation = operation ? (operation===1 ? {} : operation) : {};
							operation.params = operation.params || {};
							
							// unset any previously set extra params (only applies with proxy and buffered store)
							if (proxy && this.isBufferedStore) {
								Ext.Array.from(this.previouslySetExtraParams).forEach(function(key) {
									proxy.setExtraParam(key, undefined);
								});
								this.previouslySetExtraParams = [];
							}
							for (var key in params) {
								
								/* TODO NOT SURE ABOUT THIS
								// don't sent stopList when there's a query
								if (key=="stopList" && "query" in params && params.query) {continue;}
								*/
								
								if (proxy && this.isBufferedStore) { // also set proxy for automatic buffering calls
									this.previouslySetExtraParams.push(key);
									proxy.setExtraParam(key, params[key]);
								}
								operation.params[key] = params[key];
							}
						}
					},
					scope: this
			}
		}
		
		Ext.apply(this, config);
	},
	setCorpus: function(corpus) {
		if (corpus && this.getProxy && this.getProxy()) {
			this.getProxy().setExtraParam('corpus', Ext.isString(corpus) ? corpus : corpus.getId());
		}
		this.callParent(arguments);
	},
	getString: function(config) {
		var count = this.getCount();
		return "This store contains "+this.getCount()+" items"+(count>0 ? " with these fields: "+this.getAt(0).getFields().map(function(field) {return field.getName()}).join(", ") : "")+"."
	},
	
	embed: function(cmp, config) {
		if (!config && Ext.isObject(cmp)) {
			config = cmp;
			cmp = this.embeddable[0];
		}
		config = config || {};
		
		var data = [];
		this.each(function(record) {
			data.push(record.data);
		}, this);
		
		Ext.apply(config, {
			storeJson: JSON.stringify({
				storeClass: Ext.getClassName(this),
				storeData: data
			})
		});
		
		embed.call(this, cmp, config);
	}
	
});
Ext.define('Voyant.data.store.CAAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
	embeddable: ['Voyant.panel.ScatterPlot'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CA',
			'proxy.reader.rootProperty': 'correspondenceAnalysis',
			'proxy.reader.totalProperty': 'correspondenceAnalysis.totalTerms'
		}])
		config.proxy.extraParams.withDistributions = true;
	}
});

Ext.define('Voyant.data.store.CAAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CAAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.ContextsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.Context',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentContexts',
			'proxy.reader.rootProperty': 'documentContexts.contexts',
			'proxy.reader.totalProperty': 'documentContexts.total'
		}])
	}
});

Ext.define('Voyant.data.store.Contexts', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.ContextsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.ContextsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.ContextsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.ContextsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.ContextsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.CorpusCollocatesMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.CorpusCollocate',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusCollocates',
			'proxy.reader.rootProperty': 'corpusCollocates.collocates',
			'proxy.reader.totalProperty': 'corpusCollocates.total'
		}])
	}
});

Ext.define('Voyant.data.store.CorpusCollocates', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusCollocatesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusCollocatesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusCollocatesBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusCollocatesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusCollocatesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.CorpusFacetsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: Voyant.data.model.CorpusFacet,
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusFacets',
			'proxy.reader.rootProperty': 'corpusFacets.facets',
			'proxy.reader.totalProperty': 'corpusFacets.total'
		}])
	}
});

Ext.define('Voyant.data.store.CorpusFacets', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusFacetsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusFacetsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusFacetsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusFacetsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusFacetsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusTermsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: Voyant.data.model.CorpusTerm,
//    statics: {
//    	i18n: {
//    		getString: "This store has {0} terms with a total of {1} occurrences."
//    	}
//    },
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusTerms',
			'proxy.reader.rootProperty': 'corpusTerms.terms',
			'proxy.reader.totalProperty': 'corpusTerms.total'
		}])
	},

	show: function(config) {
		show(this.getString(config))
	}

});

/**
 * Corpus Terms store.
 */
Ext.define('Voyant.data.store.CorpusTerms', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusTermsMixin'],
    model: Voyant.data.model.CorpusTerm,
	
	/**
	 * @method each
	 * Iterate over each {@link Voyant.data.model.CorpusTerm corpus term} in this store.
	 * 
	 * 	new Corpus("Hello Voyant!").loadCorpusTerms().then(function(corpusTerms) {
	 * 		corpusTerms.each(function(corpusTerm) {
	 * 			corpusTerm.show();
	 * 		});
	 * 	});
	 * 
	 * @param {function} function The function to call for each corpus term.
	 */
	
	/**
	 * @method show
	 * Shows a one line summary of the corpus terms.
	 * 
	 * 	new Corpus("Hello Voyant!").loadCorpusTerms().then(function(corpusTerms) {
	 * 		corpusTerms.show();
	 * 	});
	 */
	
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
	
});

Ext.define('Voyant.data.store.CorpusTermsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusTermsMixin'],
    model: Voyant.data.model.CorpusTerm,
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentQueryMatchesMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.DocumentQueryMatch',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentsFinder',
			'proxy.reader.rootProperty': 'documentsFinder.queries',
			'proxy.reader.totalProperty': undefined,
			'proxy.reader.metaProperty': 'documentsFinder.corpus'
		}])
	}
});

Ext.define('Voyant.data.store.DocumentQueryMatches', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentQueryMatchesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentQueryMatchesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentQueryMatchesBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentQueryMatchesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentQueryMatchesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentTermsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.DocumentTerm',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentTerms',
			'proxy.reader.rootProperty': 'documentTerms.terms',
			'proxy.reader.totalProperty': 'documentTerms.total'
		}])
	}
});

Ext.define('Voyant.data.store.DocumentTerms', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentTermsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentEntitiesMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.DocumentEntity',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentEntities',
			'proxy.reader.rootProperty': 'documentEntities.entities',
			'proxy.reader.totalProperty': 'documentEntities.total'
		}])
	}
});

Ext.define('Voyant.data.store.DocumentEntities', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentEntitiesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentEntitiesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentEntitiesBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentEntitiesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentEntitiesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.Document',
    statics: {
    	i18n: {
    	}
    },
	sorters: {
        property: 'index',
        direction: 'ASC'
	},
	remoteSort: true,
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentsMetadata',
			'proxy.reader.rootProperty': 'documentsMetadata.documents',
			'proxy.reader.totalProperty': 'documentsMetadata.total'
		}])
	},
	listeners: {
		 load: function(store, records, successful, opts) {
			 if (successful) {
				 var corpus = store.getCorpus();
				 records.forEach(function(record) {
					 record.set('corpus', corpus);
				 });
			 }
		 }
	},
	getDocument: function(config) {
		return Ext.isNumber(config) ? this.getAt(config) : this.getById(config);
	}
	
});

Ext.define('Voyant.data.store.Documents', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentsMixin'],
    model: 'Voyant.data.model.Document',
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentsMixin'],
    model: 'Voyant.data.model.Document',
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.PCAAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
	embeddable: ['Voyant.panel.ScatterPlot'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.PCA',
			'proxy.reader.rootProperty': 'pcaAnalysis',
			'proxy.reader.totalProperty': 'pcaAnalysis.totalTerms'
		}])
		config.proxy.extraParams.withDistributions = true;
	}
});

Ext.define('Voyant.data.store.PCAAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.PCAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.PCAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.PCAAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.PCAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.PCAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.DocSimAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentSimilarity',
			'proxy.reader.rootProperty': 'documentSimilarity',
			'proxy.reader.totalProperty': 'documentSimilarity.total'
		}])
		config.proxy.extraParams.withDistributions = true;
	}
});

Ext.define('Voyant.data.store.DocSimAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocSimAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocSimAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocSimAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocSimAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocSimAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.CorpusNgramsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.CorpusNgram',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusNgrams',
			'proxy.reader.rootProperty': 'corpusNgrams.ngrams',
			'proxy.reader.totalProperty': 'corpusNgrams.total'
		}])
	}
});

Ext.define('Voyant.data.store.CorpusNgrams', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusNgramsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusNgramsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusNgramsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusNgramsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusNgramsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.RelatedTermsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.RelatedTerm',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.SemanticGraph',
			'proxy.reader.rootProperty': 'semanticGraph.edges',
			'proxy.reader.totalProperty': 'semanticGraph.total'
		}])
	}
});

Ext.define('Voyant.data.store.RelatedTerms', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.RelatedTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.RelatedTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.RelatedTermsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.RelatedTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.RelatedTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.TermCorrelationsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.TermCorrelation',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusTermCorrelations',
			'proxy.reader.rootProperty': 'termCorrelations.correlations',
			'proxy.reader.totalProperty': 'termCorrelations.total'
		}])
	}
});

Ext.define('Voyant.data.store.TermCorrelations', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.TermCorrelationsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TermCorrelationsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.TermCorrelationsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.TermCorrelationsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TermCorrelationsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.TokensMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.Token',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentTokens',
			'proxy.reader.rootProperty': 'documentTokens.tokens',
			'proxy.reader.totalProperty': 'documentTokens.total'
		}])
	}
});

Ext.define('Voyant.data.store.Tokens', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.TokensMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TokensMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.TokensBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.TokensMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TokensMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.TSNEAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
	embeddable: ['Voyant.panel.ScatterPlot'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.TSNE',
			'proxy.reader.rootProperty': 'tsneAnalysis',
			'proxy.reader.totalProperty': 'tsneAnalysis.totalTerms'
		}])
		config.proxy.extraParams.withDistributions = true;
		config.proxy.extraParams.noCache = 1;
	}
});

Ext.define('Voyant.data.store.TSNEAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.TSNEAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TSNEAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.TSNEAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.TSNEAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TSNEAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
/**
 * @class VoyantTable
 * A VoyantTable can facilitate working with tabular data structures, as well as
 * displaying results (especially with {@link #embed} and {@link show}). 
 * Here's a simple example showing the Zipf-Law distribution of the top 20 frequency terms.
 * 
 * 	new Corpus("austen").loadCorpusTerms(20).then(function(corpusTerms) {
 * 		var table = new VoyantTable({rowKey: 0}); // use first column as row key
 * 		corpusTerms.each(function(corpusTerm) {
 *			table.addRow([corpusTerm.getTerm(), corpusTerm.getRawFreq()]);
 * 		});
 * 		table.embed("voyantchart"); // graph table as line chart
 * 	});
 */
Ext.define('Voyant.data.table.Table', {
	alternateClassName: ["VoyantTable"],
	mixins: ['Voyant.notebook.util.Embed','Voyant.notebook.util.Show'],
	embeddable: ['Voyant.widget.VoyantTableTransform','Voyant.widget.VoyantChart','Voyant.widget.CodeEditor'],
	config: {
		
		/**
		 * @private
		 */
		rows: [],

		/**
		 * @private
		 */
		headers: [],

		/**
		 * @private
		 */
		rowsMap: {},
		
		/**
		 * @private
		 */
		headersMap: {},
		
		/**
		 * Specifies that a specific header should serve as row key.
		 * 
		 */
		rowKey: undefined,
		
		/**
		 * @private
		 */
		model: undefined
	},
	
	clone: function() {
		var table = new VoyantTable();
		table.setRows(Ext.clone(this.getRows()));
		table.setHeaders(Ext.clone(this.getHeaders()))
		table.setRowsMap(Ext.clone(this.getRowsMap()))
		table.setHeadersMap(Ext.clone(this.getHeadersMap()))
		table.setRowKey(Ext.clone(this.getRowKey()))
		return table;
	},

	constructor: function(config, opts) {

		config = config || {};
		if (config.fromBlock) {
			var data = Voyant.notebook.Notebook.getDataFromBlock(config.fromBlock);
			if (data) {
				data = data.trim();
				config.rows = [];
				data.split(/\n+/).forEach(function(line,i) {
					var cells = line.split("\t");
					if (i==0 && !config.noHeaders) {
						config.headers = cells
					} else {
						config.rows.push(cells)
					}
				})
				
			}
		} else if (config.count && Ext.isArray(config.count)) {
			// create counts
			var freqs = {};
			config.count.forEach(function(item) {freqs[item] = freqs[item] ? freqs[item]+1 : 1;});
			// sort counts
			var counts = [];
			for (var key in freqs) {counts.push([key, freqs[key]])}
			counts.sort(function(a,b) {return b[1] - a[1]});
			if (config.limit && counts.length>config.limit) {
				counts.splice(config.limit);
			}
			if (config.orientation && config.orientation=="horizontal") {
				config.headers = counts.map(function(item) {return item[0]});
				config.rows = [counts.map(function(item) {return item[1]})];
			} else {
				config.headers = config.headers ? config.headers : ["Item","Count"];
				config.rows = counts;
			}
		} else if (config.isStore || config.store) {
			var store = config.store ? config.store : config;
			if (opts && opts.headers) {
				config.headers = opts.headers;
			} else {
				// store.getModel() doesn't seem to work (for CorpusTerms at least)
				// so instead we'll try looking at the first record to get headers
				var record = store.getAt(0);
				if (record) { // don't know what to do if this fails?
					config.headers = record.getFields().map(function(field) {return field.getName()});
				}
			}
			
			// now we get rows
			config.rows = [];
			store.each(function(record) {
				var data = record.getData();
				var cells = config.headers.map(function(header) {return data[header]}); // only from headers
				config.rows.push(cells);
			}, this);
		}

		// not sure why config isn't working
		if (!config.rows && Ext.isArray(config)) {
			config.rows = config;
		}
		if (!this.getHeaders()) {
			if (!config.headers && !config.noHeaders && config.rows) {
				this.setHeaders(config.rows.shift())
			} else {
				this.setHeaders(Ext.Array.from(config.headers));
			}
		}
		this.setRows(Ext.Array.from(config.rows));
		this.setRowKey(config.rowKey ? config.rowKey : this.getHeaders()[0]);

		// if we have no headers, use the index as header
		if (this.getHeaders().length==0) {
			var firstRow = this.getRow(0, false);
			if (firstRow) {
				this.setHeaders(firstRow.map(function(cell, i) {return i}));
			}
		}
		
		var headersMap = {};
		this.getHeaders().forEach(function(header, i) {
			headersMap[header] = i;
		});
		this.setHeadersMap(headersMap);
		
		this.reMapRows();
		
		this.callParent();
	},
	addRow: function(row) {
		if (Ext.isArray(row))
		if (Ext.isObject(row)) {
			var len = this.getRows().length;
			for (var key in row) {
				this.updateCell(len, key, row[key])
			}
			
		} else if (Ext.isArray(row)) {
			this.getRows().push(row);
			var header = this.getColumnIndex(this.getRowKey());
			if (header!==undefined && row[header]!==undefined) {
				this.getRowsMap()[row[header]] = this.getRows().length-1;
			}
		}
	},
	eachRecord: function(fn, scope) {
		var item, i=0, len=this.getRows().length;
		for (; i<len; i++) {
            item = this.getRecord(i);
			if (fn.call(scope || item, item, i, len) === false) {
                break;
            }			
		}
	},
	eachRow: function(fn, asMap, scope) {
		var item, i=0, len=this.getRows().length;
		for (; i<len; i++) {
            item = this.getRow(i, asMap);
			if (fn.call(scope || item, item, i, len) === false) {
                break;
            }			
		}
	},
	getRow: function(index, asMap) {
		var r = this.getRowIndex(index);
		if (asMap) {
			var row = {};
			var headers = this.getHeaders();
			Ext.Array.from(this.getRows()[r]).forEach(function(item, i) {
				row[headers[i] || i] = item;
			}, this);
			return row;
		} else {
			return this.getRows()[r];
		}
	},
	getRecord: function(index) {
		if (this.model) {return new this.model(this.getRow(index, true))}
	},
	mapRows: function(fn, asMap, scope) {
		var rows = [];
		this.eachRow(function(row, i) {
//			if (Object.keys(row).length>0) {
				rows.push(fn.call(scope || this, row, i))
//			}
		}, asMap, this)
		return rows;
	},
	
	/**
	 * Update the cell value at the specified row and column.
	 * 
	 * This will create the row and column as needed. If there's an existing value in the cell,
	 * it will be added to the new value, unless the `replace` argument is set to true.
	 * 
	 * @param {Number/String} row The cell's row.
	 * @param {Number/String} column The cell's column.
	 * @param {Mixed} value The cell's value.
	 * @param {boolean} [replace] Replace the current value (if it exists), otherwise
	 * the value is added to any current value (which is the default behaviour).
	 */
	updateCell: function(row, column, value, replace) {
		var rows = this.getRows();
		var r = Ext.isNumber(row) ? row : this.getRowIndex(row);
		var c = this.getColumnIndex(column);
		if (rows[r]===undefined) {rows[r]=[]}
		if (rows[r][c]===undefined || replace) {rows[r][c]=value}
		else {rows[r][c]+=value}
		// add to rowsMap if this is the header
		if (this.getHeaders()[c]===this.getRowKey()) {
			this.getRowsMap()[column] = r;
		}
	},
	
	getRowIndex: function(key) {
		if (Ext.isNumber(key)) {return key;}
		if (Ext.isString(key)) {
			var rowsMap = this.getRowsMap();
			if (!(key in rowsMap)) {
				rowsMap[key] = this.getRows().length;
				this.getRows().push(new Array(this.getHeaders().length))
			}
			return rowsMap[key];
		}
	},
	
	getColumnIndex: function(column) {
		var headers = this.getHeaders();
		if (Ext.isNumber(column)) {
			if (headers[column]===undefined) {
				headers[column]=column;
				this.getRows().forEach(function(row) {
					row.splice(column, 0, undefined);
				});
			}
			return column;
		} else if (Ext.isString(column)) {
			if (!(column in this.getHeadersMap())) {
				// we don't have this column yet, so create it and expand rows
				this.getHeaders().push(column);
				this.getHeadersMap()[column] = this.getHeaders().length-1
				this.getRows().forEach(function(row) {
					row.push(undefined)
				});
			}
			return this.getHeadersMap()[column]
		}
	},
	
	getColumnHeader: function(column) {
		var c = this.getColumnIndex(column);
		return this.getHeaders()[c];
	},
	
	/**
	 * Compute the sum of the values in the column.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnSum: function(column) {
		return Ext.Array.sum(this.getColumnValues(column, true));
	},
	
	/**
	 * Compute the sum of the values in the column.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnMean: function(column) {
		return Ext.Array.mean(this.getColumnValues(column, true));
	},
	
	/**
	 * Get the largest value in the array.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnMax: function(column) {
		return Ext.Array.max(this.getColumnValues(column, true));
	},
	
	/**
	 * Get the smallest value in the array.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnMin: function(column) {
		return Ext.Array.min(this.getColumnValues(column, true));
	},
	
	getColumnValues: function(column, clean) {
		var c = this.getColumnIndex(column), vals = [];
		this.eachRow(function(row) {
			vals.push(row[c]);
		});
		if (clean) {return Ext.Array.clean(vals)}
		else {return vals;}
	},
	
	/**
	 * @private
	 */
	reMapRows: function() {
		var rowKey = this.getRowKey();
		var rowsMap = {}
		this.eachRow(function(row, i) {
			if (rowKey in row) {
				rowsMap[row[rowKey]] = i;
			}
		}, true);
		this.setRowsMap(rowsMap)
	},
	
	sortByColumn: function(columns) {
		var rows = this.getRows(),
			sortColumnsIndices = Ext.Array.from(columns).map(function(column) {
				if (Ext.isObject(column)) {
					for (key in column) {
						return {
							index: this.getColumnIndex(key),
							direction: column[key].indexOf("asc")>-1 ? 'asc' : 'desc'
						}
					}
				} else {
					return {
						index: this.getColumnIndex(column),
						direction: "desc"
					}
				}
			}, this);
		rows.sort(function(a, b) {
			for (var i=0, len=sortColumnsIndices.length; i<len; i++) {
				var header = sortColumnsIndices[i].index
				if (a[header]!=b[header]) {
					if (sortColumnsIndices[i].direction=='asc') {return a[header] > b[header] ? 1 : -1}
					else {return a[header] > b[header] ? -1 : 1}
				}
			}
		});
		this.reMapRows();
		return this;
	},
	
	loadCorrespondenceAnalysis: function(config) {
		return this._doAnalysisLoad('table.CA', 'Voyant.data.store.CAAnalysis', config);
	},
	
	loadPrincipalComponentAnalysis: function(config) {
		return this._doAnalysisLoad('table.PCA', 'Voyant.data.store.PCAAnalysis', config);
	},
	
	loadTSNEAnalysis: function(config) {
		return this._doAnalysisLoad('table.TSNE', 'Voyant.data.store.TSNEAnalysis', config);		
	},
	
	_doAnalysisLoad: function(tool, storeType, config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
	    	config = config || {};
			var dfd = Voyant.application.getDeferred(this);
			Ext.apply(config, {
		        columnHeaders: true,
		        rowHeaders: true,
		        tool: tool,
		        analysisInput: this.toTsv(),
		        inputFormat: 'tsv'
			});
			var store = Ext.create(storeType, {noCorpus: true});
			store.load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(store, records)
					} else {
						dfd.reject(operation.error.response);
					}
				}
			})
			return dfd.promise
		}
	},
	
	embed: function(cmp, config) {
		if (!config && Ext.isObject(cmp)) {
			config = cmp;
			cmp = this.embeddable[0];
		}
		config = config || {};
		
		var columnHeaders = Ext.Array.from(config.headers || this.getHeaders()).map(function(header) {return this.getColumnHeader(header);}, this);
		
		var json = {
				rowkey: this.getRowKey(),
				config: config,
				headers: columnHeaders
		};
		if ("headers" in config) {
			var columnIndices = Ext.Array.from(config.headers).map(function(header) {return this.getColumnIndex(header);}, this);
			var rows = [];
			this.getRows().forEach(function(row) {
				rows.push(columnIndices.map(function(i) {
					return row[i]
				}))
			})
			Ext.apply(json, {
				rows: rows
			})
		} else {
			Ext.apply(json, {
				rows: this.getRows()
			})
		}
		Ext.apply(config, {
			tableJson: JSON.stringify(json)
		});
		delete config.axes;
		delete config.series;
		
		embed.call(this, cmp, config);
		
	},
	
	toTsv: function(config) {
		var tsv = this.getHeaders().join("\t");
		this.getRows().forEach(function(row, i) {
			if (config && Ext.isNumber(config) && i>config) {return;}
			tsv += "\n"+row.map(function(cell) {
				return Ext.isString(cell) ? cell.replace(/(\n|\t)/g, "") : cell;
			}).join("\t");
		})
		return tsv;
	},
	
	getString: function(config) {
		config = config || {};
		var table = "<table class='voyant-table' style='"+(config.width ? ' width: '+config.width : '')+"' id='"+(config.id ? config.id : Ext.id())+"'>";
		var headers = this.getHeaders();
		if (headers.length) {
			table+="<thead><tr>";
			for (var i=0, len = headers.length; i<len; i++) {
				table+="<th>"+headers[i]+"</th>";
			}
			table+="</tr></thead>";
		}
		table+="<tbody>";
		for (var i=0, len = Ext.isNumber(config) ? config : this.getRows().length; i<len; i++) {
			var row = this.getRow(i);
			if (row && Ext.isArray(row)) {
				table+="<tr>";
				row.forEach(function(cell) {
					table+="<td>"+cell+"</td>";
				})
				table+="</tr>";
			}
		}
		table+="</tbody></table>";
		return table;
	}
});
/**
 * @class NetworkGraph
 * 
 * A NetworkGraph can facilitate working with network graph data structures, as well as
 * displaying results (especially with {@link #embed} and {@link show}). 
 * Here's a simple example showing the Zipf-Law distribution of the top 20 frequency terms.
 * 
 * 	new Corpus("austen").loadCorpusTerms(20).then(function(corpusTerms) {
 * 		var table = new VoyantTable({rowKey: 0}); // use first column as row key
 * 		corpusTerms.each(function(corpusTerm) {
 *			table.addRow([corpusTerm.getTerm(), corpusTerm.getRawFreq()]);
 * 		});
 * 		table.embed("voyantchart"); // graph table as line chart
 * 	});
 */
Ext.define('Voyant.data.util.NetworkGraph', {
	alternateClassName: ["NetworkGraph"],
	mixins: ['Voyant.notebook.util.Embed','Voyant.notebook.util.Show'],
	embeddable: ["Voyant.widget.VoyantNetworkGraph"],
	config: {
		
		/**
		 * @private
		 */
		edges: [],

		/**
		 * @private
		 */
		nodes: []

	},

	constructor: function(config, opts) {
		config = config || {};
		this.setEdges(Ext.Array.from(config.edges));
		this.setNodes(Ext.Array.from(config.nodes));
		this.callParent([config]);
	},
	addEdge: function(src, target, value) {
		this.getEdges().push(Ext.isObject(src) ? src : {source: src, target: target, value: value});
	},
	getNode: function(term) {
		return Ext.Array.binarySearch(this.getNodes(), term, undefined, undefined, function(lhs, rhs) {
			return (lhs.term < rhs.term) ? -1 : ((lhs.term > rhs.term) ? 1 : 0);
		})
	},
	embed: function(cmp, config) {
		if (!config && Ext.isObject(cmp)) {
			config = cmp;
			cmp = this.embeddable[0];
		}
		config = config || {};
		var json = {
				edges: this.getEdges(),
				nodes: this.getNodes(),
				config: config
		};
		if (config.limit && json.edges.length>config.limit) {
			json.edges = json.edges.slice(0, config.limit);
			var terms = {};
			json.edges.forEach(function(edge) {
				terms["_"+edge.source] = true;
				terms["_"+edge.target] = true;
			})
			var nodes = [];
			json.nodes.forEach(function(node) {
				if ("_"+node.term in terms) {
					nodes.push(node);
				}
			});
			json.nodes = nodes;
		}
		Ext.apply(config, {
			jsonData: JSON.stringify(json)
		})
		embed.call(this, cmp, config);
	},
	
	getString: function(config) {
		config = config || {};
		return this.getEdges().map(function(edge) {edge.source+"-"+edge.target}).join("; ");
	}
});
Ext.define('Voyant.data.util.Geonames', {
    mixins: ['Voyant.util.Localization'],
    statics: {
    		i18n: {
    		}
    },

	config: {
		data: {},
		queries: undefined,
		corpus: undefined,
		isIncrementalLoadingOccurrences: false,
		previousParams: {}
	},
	constructor: function(config, opts) {
		config = config || {};
		this.callParent([config]);
		this.setCorpus(config.corpus);
	},
	load: function(params, dfd) {
		this.setPreviousParams(params);
		dfd = dfd || Voyant.application.getDeferred(this);
		var me = this, localParams = {
			corpus: this.getCorpus().getAliasOrId(),
			queries: this.getQueries(),
			tool: 'corpus.Dreamscape',
			limit: 200
		};
		Ext.apply(localParams, params || {});
		
		if (!params.noOverwrite) {
			me.setData({});
		}

		Ext.Ajax.request({
			url: Voyant.application.getTromboneUrl(),
			params: localParams,
			scope: this
		}).then(function(response) {
			var data = Ext.JSON.decode(response.responseText);
			if (data && data.dreamscape && data.dreamscape.progress) {
				new Voyant.widget.ProgressMonitor({
					progress: data.dreamscape.progress,
					maxMillisSinceStart: 1000*60*60, // an hour (!)
					tool: 'corpus.Dreamscape',
					success: function() {
						me.load.call(me, params, dfd);
					},
					failure: function(responseOrProgress) {
						Voyant.application.showResponseError(me.localize("failedToFetchGeonames"), responseOrProgress);
					},
					scope: me
				});
			}
			if (data && data.dreamscape && !data.dreamscape.progress) {
				if (!params.noOverwrite) {
					me.setData(data.dreamscape);
				}
				dfd.resolve(data);
			}
		}, function(response) {
			Voyant.application.showResponseError(me.localize('failedToFetchGeonames'), response);
		});
		return dfd.promise;
	},
	getCitiesCount: function() {
		return Object.keys(this.getData().locations.locations).length;
	},
	getTotalCitiesCount: function() {
		return this.getData().locations.total;
	},
	hasMoreCities: function() {
		return this.getCitiesCount()<this.getTotalCitiesCount();
	},
	eachCity: function(fn, scope, max) {
		var locations = this.getData().locations.locations, orderedLocations = [];
		for (var id in locations) { // create a sortable list with id
			orderedLocations.push(Ext.apply(locations[id], {id: id}))
		}
		orderedLocations.sort(function(c1, c2) { // order by rawFreq (count)
			return c1.rawFreq == c2.rawFreq ? c1.label - c2.label : c2.rawFreq - c1.rawFreq;
		});
		if (max && orderedLocations.length>max) {orderedLocations = orderedLocations.slice(0,max)}
		orderedLocations.forEach(function(location) {fn.call(scope, location);});
	},
	getConnectionsCount: function() {
		return this.getData().connections.connections.length;
	},
	getTotalConnectionsCount: function() {
		return this.getData().connections.total;
	},
	eachConnection: function(fn, scope, max) {
		var connections = this.getData().connections.connections,
			locations = this.getData().locations.locations;
			orderedConnections = [];
		for (var i=0, len=connections.length; i<len; i++) {
			fn.call(scope, {
				source: Ext.apply({id: connections[i].source}, locations[connections[i].source]),
				target: Ext.apply({id: connections[i].target}, locations[connections[i].target]),
				rawFreq: connections[i].rawFreq
			});
			if (i>max) {break;}
		}
	},
	getConnectionOccurrence: function(index) {
		if (!this.getData().locations) {return undefined;}
		var connectionOccurrencesData = this.getData().connectionOccurrences,
			connectionOccurrences = connectionOccurrencesData.connectionOccurrences;
			locations = this.getData().locations.locations;
		if (!this.getIsIncrementalLoadingOccurrences() && connectionOccurrences.length<connectionOccurrencesData.total && index+100>connectionOccurrences.length) {
			this.setIsIncrementalLoadingOccurrences(true);
			var me = this;
			var params = {};
			Ext.apply(params, this.getPreviousParams);
			Ext.apply(params, {
				start: connectionOccurrences.length,
				noOverwrite: true,
				suppressLocations: true,
				suppressConnections: true
			});
			this.load(params).then(function(data) {
				me.setIsIncrementalLoadingOccurrences(false);
				me.getData().connectionOccurrences.connectionOccurrences = connectionOccurrences.concat(data.dreamscape.connectionOccurrences.connectionOccurrences);
			})
		}
		if (connectionOccurrences && connectionOccurrences[index]) {
			var occurrence = connectionOccurrences[index];
			occurrence.index = index;
			Ext.apply(occurrence.source, locations[occurrence.source.location]);
			Ext.apply(occurrence.target, locations[occurrence.target.location]);
			return occurrence;
		}
		return null;
	},
    getAllConnectionOccurrences: function(sourceId, targetId) {
    	debugger
        // TODO return all occurences of connection with given source and target, including those not loaded yet
        var occurences = [];
        for (var i = 0; i < this.getTotalConnectionsCount(); i++) {
            var occurence = this.getConnectionOccurrence(i);
            if (occurence && occurence.target.id == targetId && occurence.source.id == sourceId) {
                occurences.push(occurence);
            }
        }
        return occurences
    }
});
/**
 * @class Corpus
 * Corpus is possibly the most important class since in most cases you'll first create/load a corpus and then
 * interact with data derived from the corpus. In the simplest scenario you can create/load a corpus with a
 * corpus ID, a text string, a URL, or an array of text strings or URLs (see the {@link #constructor} and 
 * {@link #input} config for a bit more information).
 * 
 * 	new Corpus("austen"); // load an existing corpus
 * 
 * 	new Corpus("Hello Voyant!"); // load a corpus with the specified text string
 * 
 * 	new Corpus("http://hermeneuti.ca/"); // load a corpus with a URL
 * 
 * It's important to understand that the constructor actually returns a promise for a corpus, since the corpus
 * data is loaded asynchronously. All documented methods below handle the promise properly.
 * 
 * 	new Corpus("Hello Voyant!").show(); // the show method is called when the promise is filled
 * 
 * You can also handle the promise yourself using {@link Ext.promise.Promise#then then}.
 * 
 * 	new Corpus("Hello Voyant!").then(function(corpus) {
 * 		corpus.show(); // essentially the same as above (but more work:)
 * 	});
 * 
 * There are many parameters that can be specified when creating a corpus:
 * 
 * - **sources**: {@link #corpus}, {@link #input}
 * - **formats**:
 * 	- **Text**: {@link #inputRemoveFrom}, {@link #inputRemoveFromAfter}, {@link #inputRemoveUntil}, {@link #inputRemoveUntilAfter}
 * 	- **XML**: {@link #xmlAuthorXpath}, {@link #xmlCollectionXpath}, {@link #xmlContentXpath}, {@link #xmlExtraMetadataXpath}, {@link #xmlKeywordXpath}, {@link #xmlPubPlaceXpath}, {@link #xmlPublisherXpath}, {@link #xmlTitleXpath}
 * 	- **Tables**: {@link #tableAuthor}, {@link #tableContent}, {@link #tableDocuments}, {@link #tableNoHeadersRow}, {@link #tableTitle}
 * - **other**: {@link #inputFormat}, {@link #subTitle}, {@link #title}, {@link #tokenization}
 */
Ext.define('Voyant.data.model.Corpus', {
	alternateClassName: ["Corpus"],
    mixins: ['Voyant.notebook.util.Embed','Voyant.notebook.util.Show','Voyant.util.Transferable','Voyant.util.Localization','Voyant.util.Assignable'],
    transferable: ['loadCorpusTerms','loadTokens','getPlainText','getText','getWords','getString','getLemmasArray'],
//    transferable: ['getSize','getId','getDocument','getDocuments','getCorpusTerms','getDocumentsCount','getWordTokensCount','getWordTypesCount','getDocumentTerms'],
    embeddable: ['Voyant.panel.Summary','Voyant.panel.Cirrus','Voyant.panel.Documents','Voyant.panel.CorpusTerms','Voyant.panel.Reader','Voyant.panel.Trends','Voyant.panel.TermsRadio','Voyant.panel.DocumentTerms','Voyant.panel.TermsBerry','Voyant.panel.CollocatesGraph','Voyant.panel.Contexts','Voyant.panel.WordTree','Voyant.panel.Veliza','Voyant.panel.ScatterPlot','Voyant.panel.Topics'],
	requires: ['Voyant.util.ResponseError','Voyant.data.store.CorpusTerms','Voyant.data.store.Documents'/*,'Voyant.panel.Documents'*/],
    extend: 'Ext.data.Model',
    config: {
    	
    	/**
    	 * @cfg {String} corpus The ID of a previously created corpus.
    	 * 
    	 * A corpus ID can be used to try to retrieve a corpus that has been previously created.
    	 * Typically the corpus ID is used as a first string argument, with an optional second
    	 * argument for other parameters (especially those to recreate the corpus if needed).
    	 * 
    	 * 		new Corpus("goldbug");
    	 * 
    	 * 		new Corpus("goldbug", {
    	 *			// if corpus ID "goldbug" isn't found, use the input
    	 * 			input: "https://gist.githubusercontent.com/sgsinclair/84c9da05e9e142af30779cc91440e8c1/raw/goldbug.txt",
    	 * 			inputRemoveUntil: 'THE GOLD-BUG',
    	 * 			inputRemoveFrom: 'FOUR BEASTS IN ONE'
    	 * 		});
    	 */
    	
    	/**
    	 * @cfg {String/String[]} input Input sources for the corpus.
    	 * 
    	 * The input sources can be either normal text or URLs (starting with `http`).
    	 * 
    	 * Typically input sources are specified as a string or an array in the first argument, with an optional second argument for other parameters.
    	 * 
    	 * 		new Corpus("Hello Voyant!"); // one document with this string
    	 * 
    	 * 		new Corpus(["Hello Voyant!", "How are you?"]); // two documents with these strings
    	 * 
    	 * 		new Corpus("http://hermeneuti.ca/"); // one document from URL
    	 * 
    	 * 		new Corpus(["http://hermeneuti.ca/", "https://en.wikipedia.org/wiki/Voyant_Tools"]); // two documents from URLs
    	 * 
    	 * 		new Corpus("Hello Voyant!", "http://hermeneuti.ca/"]); // two documents, one from string and one from URL
    	 * 
    	 * 		new Corpus("https://gist.githubusercontent.com/sgsinclair/84c9da05e9e142af30779cc91440e8c1/raw/goldbug.txt", {
    	 * 			inputRemoveUntil: 'THE GOLD-BUG',
    	 * 			inputRemoveFrom: 'FOUR BEASTS IN ONE'
    	 * 		});
    	 * 
    	 * 		// use a corpus ID but also specify an input source if the corpus can't be found
    	 * 		new Corpus("goldbug", {
    	 * 			input: "https://gist.githubusercontent.com/sgsinclair/84c9da05e9e142af30779cc91440e8c1/raw/goldbug.txt",
    	 * 			inputRemoveUntil: 'THE GOLD-BUG',
    	 * 			inputRemoveFrom: 'FOUR BEASTS IN ONE'
    	 * 		});
    	 */
    	
    	/**
    	 * @cfg {String} inputFormat The input format of the corpus (the default is to auto-detect).
    	 * 
    	 * The auto-detect format is usually reliable and inputFormat should only be used if the default
    	 * behaviour isn't desired. Most of the relevant values are used for XML documents:
    	 * 
    	 * - **DTOC**: Dynamic Table of Contexts XML format
    	 * - **HTML**: Hypertext Markup Language
    	 * - **RSS**: Really Simple Syndication XML format
    	 * - **TEI**: Text Encoding Initiative XML format
    	 * - **TEICORPUS**: Text Encoding Initiative Corpus XML format
    	 * - **TEXT**: plain text
    	 * - **XML**: treat the document as XML (sometimes overridding auto-detect of XML vocabularies like RSS and TEI)
    	 * 
    	 * Other formats include **PDF**, **MSWORD**, **XLSX**, **RTF**, **ODT**, and **ZIP** (but again, these rarely need to be specified).
    	 */
    	
    	/**
    	 * @cfg {String} tableDocuments Determine what is a document in a table (the entire table, by row, by column); only used for table-based documents.
    	 * 
    	 * Possible values are:
    	 * 
    	 * - **undefined or blank** (default): the entire table is one document
    	 * - **rows**: each row of the table is a separate document
    	 * - **columns**: each column of the table is a separate document
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableContent Determine how to extract body content from the table; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableAuthor Determine how to extract the author from each document; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableTitle Determine how to extract the title from each document; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableContent Determine how to extract body content from the table; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableNoHeadersRow Determine if the table has a first row of headers; only used for table-based documents.
    	 * 
    	 * Provide a value of "true" if there is no header row, otherwise leave it blank or undefined (default).
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tokenization The tokenization strategy to use
    	 * 
    	 * This should usually be undefined, unless specific behaviour is required. These are the valid values:
    	 * 
    	 * - **undefined or blank**: use the default tokenization (which uses Unicode rules for word segmentation)
    	 * - **wordBoundaries**: use any Unicode character word boundaries for tokenization
    	 * - **whitespace**: tokenize by whitespace only (punctuation and other characters will be kept with words)
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tokenization).
    	 */
    	
    	/**
    	 * @cfg {String} xmlContentXpath The XPath expression that defines the location of document content (the body); only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><head>Hello world!</head><body>This is Voyant!</body></doc>", {
    	 * 			 xmlContentXpath: "//body"
    	 * 		}); // document would be: "This is Voyant!"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlTitleXpath The XPath expression that defines the location of each document's title; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><title>Hello world!</title><body>This is Voyant!</body></doc>", {
    	 * 			 xmlTitleXpath: "//title"
    	 * 		}); // title would be: "Hello world!"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */

    	/**
    	 * @cfg {String} xmlAuthorXpath The XPath expression that defines the location of each document's author; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><author>Stfan Sinclair</author><body>This is Voyant!</body></doc>", {
    	 * 			 xmlAuthorXpath: "//author"
    	 * 		}); // author would be: "Stfan Sinclair"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlPubPlaceXpath The XPath expression that defines the location of each document's publication place; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><pubPlace>Montreal</pubPlace><body>This is Voyant!</body></doc>", {
    	 * 			 xmlPubPlaceXpath: "//pubPlace"
    	 * 		}); // publication place would be: "Montreal"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */

    	/**
    	 * @cfg {String} xmlPublisherXpath The XPath expression that defines the location of each document's publisher; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><publisher>The Owl</publisher><body>This is Voyant!</body></doc>", {
    	 * 			 xmlPublisherXpath: "//publisher"
    	 * 		}); // publisher would be: "The Owl"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */

    	/**
    	 * @cfg {String} xmlKeywordXpath The XPath expression that defines the location of each document's keywords; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><keyword>text analysis</keyword><body>This is Voyant!</body></doc>", {
    	 * 			 xmlKeywordXpath: "//keyword"
    	 * 		}); // publisher would be: "text analysis"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlCollectionXpath The XPath expression that defines the location of each document's collection name; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><collection>documentation</collection><body>This is Voyant!</body></doc>", {
    	 * 			 xmlCollectionXpath: "//collection"
    	 * 		}); // publisher would be: "documentation"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlGroupByXpath The XPath expression that defines the location of each document's collection name; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><sp s='Juliet'>Hello!</sp><sp s='Romeo'>Hi!</sp><sp s='Juliet'>Bye!</sp></doc>", {
    	 * 			 xmlDocumentsXPath: '//sp',
    	 *           xmlGroupByXpath: "//@s"
    	 * 		}); // two docs: "Hello! Bye!" (Juliet) and "Hi!" (Romeo)
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlExtraMetadataXpath A value that defines the location of other metadata; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><tool>Voyant</tool><phase>1</phase><body>This is Voyant!</body></doc>", {
    	 * 			 xmlExtraMetadataXpath: "tool=//tool\nphase=//phase"
    	 * 		}); // tool would be "Voyant" and phase would be "1"
    	 * 
    	 * Note that `xmlExtraMetadataXpath` is a bit different from the other XPath expressions in that it's
    	 * possible to define multiple values (each on its own line) in the form of name=xpath.
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlExtractorTemplate Pass the XML document through the XSL template located at the specified URL before extraction (this is ignored in XML-based documents).
    	 * 
    	 * This is an advanced parameter that allows you to define a URL of an XSL template that can
    	 * be called *before* text extraction (in other words, the other XML-based parameters apply
    	 * after this template has been processed).
    	 */

    	/**
    	 * @cfg {String} inputRemoveUntil Omit text up until the start of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveUntil: "This"
    	 * 		}); // document would be: "This is Voyant!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} inputRemoveUntilAfter Omit text up until the end of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveUntilAfter: "world!"
    	 * 		}); // document would be: "This is Voyant!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} inputRemoveFrom Omit text from the start of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveFrom: "This"
    	 * 		}); // document would be: "Hello world!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} inputRemoveFromAfter Omit text from the end of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveFromAfter: "world!"
    	 * 		}); // document would be: "Hello world!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} subTitle A sub-title for the corpus.
    	 * 
    	 * This is currently not used, except in the Dynamic Table of Contexts skin. Still, it may be worth specifying a subtitle for later use.
    	 */
    	
    	/**
    	 * @cfg {String} title A title for the corpus.
    	 * 
    	 * This is currently not used, except in the Dynamic Table of Contexts skin. Still, it may be worth specifying a title for later use.
    	 */
    	 
    	 /**
    	 * @cfg {String} curatorTsv a simple TSV of paths and labels for the DToC interface
    	 *
    	 * The DToC skin allows curation of XML tags and attributes in order to constrain the entries shown in the interface or to provide friendlier labels. This assumes plain text unicode input with one definition per line where the simple XPath expression is separated by a tab from a label.
    	 *
    	 *   	 p    	 paragraph
    	 *   	 ref[@target*="religion"]    	 religion
    	 *
    	  * For more information see the DToC documentation on [Curating Tags](http://cwrc.ca/Documentation/public/index.html#DITA_Files-Various_Applications/DToC/CuratingTags.html)
    	 */
    	 
    	
    	
    	documentsStore: undefined
    },
    statics: {
    	i18n: {}
    },
    fields: [
         {name: 'documentsCount', type: 'int'},
         {name: 'lexicalTokensCount', type: 'int'},
         {name: 'lexicalTypesCount', type: 'int'},
         {name: 'createdTime', type: 'int'},
         {name: 'createdDate', type: 'date', dateFormat: 'c'},
         {name: 'title', type: 'string'},
         {name: 'subTitle', type: 'string'},
         {name: 'languagueCodes', type: 'string'}
    ],
    
	/**
     * Create a promise for a new Corpus with relevant data loaded.
     * 
     * The typical usage in Spyral is to call {@link #assign} in a first code block:
     * 
     * 		new Corpus("Hello Voyant!").assign("corpus");
     * 
     * Then use the named variable in a subsequent code block:
     * 
     * 	  corpus.show();
     * 
     * Alternatively, the returned promise can be chained with {@link Ext.promise.Promise#then then}
     * and a function argument that receives the Corpus as an argument.
     * 
     * 	var corpus;
     * 	new Corpus("Hello Voyant!").then(function(data) {
     * 		corpus = data;
     * 		corpus.show();
     * 	});
     * 
     * The following scenarios are possible for the config argument:
     * 
     * - a string that looks like a corpus ID (not a URL and no spaces): treated as a {@link #corpus} config
     * - a string that doesn't look like a corpus ID: treated as an {@link #input} config
     * - an array of strings: treated as an array of {@link #input} config values
     * - an object: treated a normal config object
     * 
     * As such, these two constructions do the same thing:
     * 
     * 	new Corpus("Hello World!");
     * 	new Corpus({input: "Hello World!"});
     * 
     * @param {String/String[]/Object} config The source document(s) as a text string, a URL, an array of text strings and URLs, or a config object.
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return a Corpus but a promise to return a Corpus when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * Corpus as an argument, as per the example above).
	 */
	constructor : function(source, config) {
		source = source || {};
		config = config || {};
				
		this.callParent([]); // only send config, not source
		
		var dfd = Voyant.application.getDeferred(this);
		
		if (Ext.isString(source)) { // a string could be a corpus ID or an input string (text or URL)
			if (/\s/.test(source)==false && source.indexOf(":")==-1) { // looks like a corpus ID
				Ext.apply(config, {
					corpus: source
				});
			} else { // looks like input (text or URL)
				Ext.apply(config, {
					input: source
				});
			}
		} else if (Ext.isArray(source)) { // assume we have an array of texts or URLs
			Ext.apply(config, {
				input: source
			});
		} else if (Ext.isObject(source)) { // copy the source to the config
			Ext.apply(config, source);
		} else {
			Voyant.application.showError(this.localize("badDataTypeCorpus")+": ("+ (typeof source)+") "+source);
			Ext.defer(function() {
				dfd.reject(this.localize("badDataTypeCorpus")+": ("+ (typeof source)+") "+source)
			}, 50, this);
			return dfd.promise;
		}
		
		if (Ext.isObject(config)) {
			
			if (!config.corpus && !config.input && !config.inlineData) {
				Voyant.application.showError(this.localize("noCorpusOrInput")+": "+config);
				Ext.defer(function() {
					dfd.reject(this.localize("noCorpusOrInput")+": "+config)
				}, 50, this);
				return dfd.promise;
			}
			
			Ext.apply(config, {tool: 'corpus.CorpusMetadata'})

			var me = this;
			var promise = Ext.Ajax.request({
				url: Voyant.application.getTromboneUrl(),
				params: config
			}).then(function(response) {
				me.set(Ext.JSON.decode(response.responseText).corpus.metadata);
				// removed calls to set title and subtitle which should now be in metadata
				if (config.title || config.subTitle) {
					me.set('title', config.title);
					me.set('subTitle', config.subTitle);
				} else {
					// (removed calls for title and subtitle which should now be part of metadata
				}
				
				return me;
			}, function(response){
				Voyant.application.showResponseError(me.localize('failedCreateCorpus'), response);
			}).then(function(corpus) {
				if (corpus.getDocumentsCount()==0) {
					Voyant.application.showError(me.localize("thisCorpus")+" "+me.localize("isEmpty")+".");
				}
				if (!('docsLimit' in config) || (config.docsLimit!==false && config.docsLimit>0)) {
					me.getDocuments().load({
						params: {
							limit: ('docsLimit' in config) ? config.docsLimit : me.getDocumentsCount()
						},
						callback: function(records, operation, success) {
							if (success) {
								me.setDocumentsStore(this);
								dfd.resolve(corpus)
							} else {
								dfd.reject(operation)
							}
						}
					})
				} else {
					dfd.resolve(corpus)
				}
			})
			return dfd.promise
		} else {
			Voyant.application.showError(this.localize("badDataTypeCorpus")+": ("+ (typeof config)+") "+config);
			Ext.defer(function() {
				dfd.reject(this.localize("badDataTypeCorpus")+": ("+ (typeof config)+") "+config)
			}, 50, this);
			return dfd.promise;
		}
	},
	
	getId: function() {
		// overrides the getId() function from the model to handle promises
    	return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('id');		
	},
	
	
	getAliasOrId: function() {
		// overrides the getId() function from the model to handle promises
    	return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : (this.get('alias') || this.get('id'));		
	},
	
	/**
     * Create a promise for {@link Voyant.data.store.CorpusTerms Corpus Terms}.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the {@link Voyant.data.store.CorpusTerms Corpus Terms} as an argument.
     * 
     * 	new Corpus("Hello Voyant!").loadCorpusTerms().then(function(corpusTerms) {
     * 		corpusTerms.show();
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of corpus terms to load (see {@link Voyant.data.store.CorpusTerms#limit})
     * - otherwise this is a regular config object
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return corpus terms but a promise to return a corpus terms when they're finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * corpus terms as an argument, as per the example above).
	 */
	loadCorpusTerms: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			config = config || {};
			if (Ext.isNumber(config)) {
				config = {limit: config};
			}
			Ext.applyIf(config, {
				limit: 0
			})
			var corpusTerms = this.getCorpusTerms();
			corpusTerms.load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(corpusTerms)
					} else {
						dfd.reject(operation)
					}
				}
			})
			return dfd.promise
		}
	},
	
	/**
     * Create a promise for {@link Voyant.data.store.Tokens Tokens}.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the {@link Voyant.data.store.Tokens Tokens} as an argument.
     * 
     * 	new Corpus("Hello Voyant!").loadTokens().then(function(tokens) {
     * 		tokens.show();
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of corpus terms to load (see {@link Voyant.data.store.CorpusTerms#limit})
     * - otherwise this is a regular config object
     * 	- **limit**: the maximum number of tokens to return (default is no limit)
     * 	- **perDocLimit**: the maximum number of tokens to return per document
     * 	- **start**: where to start (when pageing, default is 0)
     * 	- **noOthers**: determine if only word tokens are returned (default is false)
     * 	- **withPosLemmas**: try to populate pos (part-of-speech) tags and lemmas (only works in English for now)
     * 	- **docIndex**: a comma-separated list of integers of document indices
     * 	- **docId**: a comma-separated list of document IDs
     * 	- **stopList**: the ID of an existing stopList resource or an array of words to skip
     * 	- **whitelist**: the ID of an existing whitelist resource or an array of words to keep
     * 
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return tokens but a promise to return tokens when they're finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * tokens as an argument, as per the example above).
	 */
	loadTokens: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			config = config || {};
			if (Ext.isNumber(config)) {
				config = {limit: config};
			}
			Ext.applyIf(config, {
				limit: 0
			})
			var tokens = this.getTokens();
			tokens.load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(tokens)
					} else {
						dfd.reject(operation)
					}
				}
			})
			return dfd.promise
		}
	},
	
	getCorpusTerms: function(config) {
		return Ext.create("Voyant.data.store.CorpusTerms", Ext.apply(config || {}, {corpus: this}));
	},
	
	getTokens: function(config) {
		return Ext.create("Voyant.data.store.Tokens", Ext.apply(config || {}, {corpus: this}));
	},
	
	each: function(fn, scope) {
		this.getDocuments().each(function(doc, i) {
			fn.call(scope || doc, doc, i);
		})
	},
	
	map: function(fn, scope) {
		return this.getDocuments().getRange().map(function(doc, i) {
			return fn.call(scope || doc, doc, i)
		}, scope || this)
	},
	
	getCorpusCollocates: function(config) {
		return Ext.create("Voyant.data.store.CorpusCollocates", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocumentQueryMatches: function(config) {
		// not expected to be called before corpus is defined
		return Ext.create("Voyant.data.store.DocumentQueryMatches", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocumentTerms: function(config) {
		return Ext.create("Voyant.data.store.DocumentTerms", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocumentEntities: function(config) {
		return Ext.create("Voyant.data.store.DocumentEntities", Ext.apply(config || {}, {corpus: this}));
	},
	
	loadContexts: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			config = config || {};
			if (Ext.isNumber(config)) {
				config = {limit: config};
			}
			Ext.applyIf(config, {
				limit: 0
			})
			var contexts = this.getContexts();
			contexts.load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(contexts)
					} else {
						dfd.reject(operation)
					}
				}
			})
			return dfd.promise
		}
		
	},
	
	getContexts: function(config) {
		return Ext.create("Voyant.data.store.Contexts", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocuments: function(config) {
		return this.getDocumentsStore() ? this.getDocumentsStore() : Ext.create("Voyant.data.store.Documents", Ext.apply(config || {}, {corpus: this}));
		//this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.getDocumentsStore();
	},
	
	getDocument: function(config) {
		if (this.getDocumentsStore()) {
			if (config instanceof Voyant.data.model.Document) {
				return config;
			}
			else if (Ext.isNumeric(config)) {
				return this.getDocumentsStore().getAt(parseInt(config))
			}
			else if (Ext.isString(config)) {
				return this.getDocumentsStore().getById(config)
			}
		}
		return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.getDocumentsStore().getDocument(config);
	},
	
	getDocumentsCount: function() {
		return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('documentsCount');
	},
	
	getWordTokensCount: function() {
    	return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('lexicalTokensCount');
	},
	
	getWordTypesCount: function() {
    	return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('lexicalTypesCount');
	},
	
	getCreatedTime: function() {
    	return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('createdTime');		
	},
	
	requiresPassword: function() {
		var noPasswordAccess = this.getNoPasswordAccess();
		return noPasswordAccess=='NONE' || noPasswordAccess=='NONCONSUMPTIVE';
	},
	
	getNoPasswordAccess: function() {
		// overrides the getId() function from the model to handle promises
    	return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('noPasswordAccess');		
	},
	
	getTitle: function() {
		return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('title');		
	},
	
	getSubTitle: function() {
		return this.then ? Voyant.application.getDeferredNestedPromise(this, arguments) : this.get('subTitle');		
	},
	
	getRelatedWords : function(config) {
		return Ext.create("Voyant.data.store.RelatedTerms", Ext.apply(config || {}, {corpus: this}))
	},
	
	loadRelatedWords : function(config) {
		var me = this;
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			config = config || {};
			if (Ext.isNumber(config)) {
				config = {limit: config};
			}
			Ext.applyIf(config, {
				limit: 0
			})
			var relatedTerms = this.getRelatedWords();
			relatedTerms.load({
				params: config,
				callback: function(records, operation, success) {
					if (success) {
						dfd.resolve(records)
					} else {
						dfd.reject(operation.error.response);
					}
				}
			})
			return dfd.promise
		}
	},
		
	/**
     * Create a promise for a text representation of all the document bodies in the corpus.
     * 
     * This does NOT necessarily return the full original document, but rather the body or main
     * content, as extracted by Voyant. You can also request a {@link #plainText} version with
     * the tags stripped.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getText().then(function(text) {
     * 		show(text.replace(/</g, "&lt;")); // show the markup 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object that can contain the following:
     * 	 - `limit`: a limit on the total number of words (by default there's no limit)
     * 	 - `perDocLimit`: a limit on the number of words to fetch for each document (by default there's no limit)
     * 	 - `start`: start at this word index for each document
     * 	 - `stopList`: the ID of an existing stopList resource or an array of words to skip
     * 	 - `whitelist`: the ID of an existing whitelist resource or an array of words to keep
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return text but a promise to return text when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * text as an argument, as per the example above).
	 */
	getText: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments, this);
		} else {
			var dfd = Voyant.application.getDeferred(this);
	    	config = config || {};
	    	if (Ext.isNumber(config)) {
	    		config = {limit: config}
	    	} else if (Ext.isString(config)) {
	    		config = {limit: parseInt(config)}
	    	};
	    	Ext.applyIf(config, {
        		limit: 0,
    			outputFormat: "text",
    			template: "docTokens2text"
	    	});
	    	Ext.apply(config, {
        		tool: 'corpus.DocumentTokens',
        		corpus: this.getAliasOrId()
	    	});
        	Ext.Ajax.request({
        	    url: Voyant.application.getTromboneUrl(),
        	    params: config,
        	    success: function(response, opts) {
        	    	var text = response.responseText.trim();
        	    	if (config.transformCase) {
        	    		if (config.transformCase.indexOf("lower")>-1) {
        	    			text = text.toLowerCase();
        	    		} else if (config.transformCase.indexOf("upper")>-1) {
        	    			text = text.toUpperCase();
        	    		}
        	    	}
        	    	dfd.resolve(text);
        	    },
        	    failure: function(response, opts) {
        	    	dfd.reject(response);
        	    },
        	    scope: this
        	})
	    	return dfd.promise
		}
    },
    
	/**
     * Create a promise for a plain text representation of all the text in the corpus.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getPlainText().then(function(text) {
     * 		show(text.trim().replace(/\s+/g, " ").substr(-150)); // show the end 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object  see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return text but a promise to return text when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * text as an argument, as per the example above).
	 */
    getPlainText: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
	    	config = config || {};
	    	if (Ext.isNumber(config)) {
	    		config = {limit: config}
	    	} else if (Ext.isString(config)) {
	    		config = {limit: parseInt(config)}
	    	}
	    	Ext.apply(config, {
    			template: "docTokens2plainText"
	    	});
			return this.getText(config);
		}
    	
    },

	/**
     * Create a promise for a string containing just the words from the corpus.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getWords().then(function(words) {
     * 		show(words); // show the words 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object  see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return the words but a promise to return words when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * words as a string argument, as per the example above).
	 */
    getWords: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
	    	config = config || {};
	    	if (Ext.isNumber(config)) {
	    		config = {limit: config}
	    	} else if (Ext.isString(config)) {
	    		config = {limit: parseInt(config)}
	    	};
	    	Ext.applyIf(config, {
    			template: "docTokens2words"
	    	});
			return this.getText(config);
		}
    	
    },
	
	/**
     * Create a promise for a string containing just the words from the corpus.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getWords().then(function(words) {
     * 		show(words); // show the words 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object  see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return the words but a promise to return words when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * words as a string argument, as per the example above).
	 */
    getWordsArray: function(config) {
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
	    	this.getWords(config).then(function(text) {
				dfd.resolve(text.split(" "));
			})
			return dfd.promise
		}
    	
    },
    
	/**
     * Create a promise for an array of lemmas from the corpus (only works for English).
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the lemmas as an argument.
     * 
	 * 	new Corpus("Hello world, I like Spyral notebooks!", {language: "en"}).getLemmasArray().then(function(lemmas) {
			show(lemmas.join(", "))
	 *  });
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object  see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return the words but a promise to return words when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * words as a string argument, as per the example above).
	 */
    getLemmasArray: function(config) {
    	config = config || {};
		if (this.then) {
			return Voyant.application.getDeferredNestedPromise(this, arguments);
		} else {
			var dfd = Voyant.application.getDeferred(this);
			Ext.applyIf(config, {
				template: "docTokens2lemmas",
				withPosLemmas: true,
				noOthers: true
			})
	    	this.getWords(config).then(function(text) {
	    		var lemmas = text.split(" ").map(function(word) {return word.substring(0, word.indexOf("/"))})
				dfd.resolve(lemmas);
			})
			return dfd.promise
		}
    	
    },
    
    /**
	 * Shows a one-line summary of this corpus.
	 * 
	 * 	new Corpus("Hello World!").show(true);
	 * 
	 * @method show
	 * @param {boolean} [withID] Includes the corpus ID in parentheses at the end, if true.
	 */
	
	/**
	 * @method embed
	 * Embed the current corpus in the specified tool.
	 * 
	 * Because embed knows about promises, you don't need to handle promises when calling embed on a corpus.
	 * 
	 * 	new Corpus("Hello Voyant!").embed(); // use summary as a default
	 * 	new Corpus("Hello Voyant!").embed("corpusterms"); // specify corpus terms tool
	 * 	new Corpus("Hello Voyant!").embed("cirrus", {width: "300px"}); // with config
	 *  
	 * @param {String} [tool] Specify which tool to use for embedding this corpus.
	 * The following are recognized tool values: {@link Voyant.panel.Summary summary} (default), {@link Voyant.panel.Cirrus cirrus}, {@link Voyant.panel.Documents documents}, {@link Voyant.panel.CorpusTerms corpusterms}.
	 * @param {Object} [config] Additional configuration options to pass to the tool.
	 * In addition to the configuration options available from each tool listed in the tool param (see above), options include:
	 * 
	 * - **width**: a CSS width value for the embedded tool (e.g. "500px", "80em", "50%")
	 * - **height**: a CSS height value for the embedded tool (e.g. "300px", "10em", "30%")
	 */
    getString: function(config) {
		var size = this.getDocumentsCount();
		var message = this.localize('thisCorpus');
		if (size==0) {message += ' '+this.localize('isEmpty')+'.';}
		else {
			message+=' ';
			if (size>1) {
				message+=new Ext.XTemplate(this.localize('hasNdocuments')).apply({count: Ext.util.Format.number(size,"0,000")});
			}
			else {
				message+=this.localize('has1document');
			}
			message+=' '+new Ext.XTemplate(this.localize('widthNwordsAndNTypes')).apply({words: Ext.util.Format.number(this.getWordTokensCount(),"0,000"), types: Ext.util.Format.number(this.getWordTypesCount(),"0,000")})+'.'
			message+=" "+this.localize('created')+" ";
			var createdDate = this.get('createdDate');
			var now = new Date();
			if (Ext.Array.each([
		    				['year', Ext.Date.YEAR],
		    				['month', Ext.Date.MONTH],
		    				['day', Ext.Date.DAY],
		    				['hour', Ext.Date.HOUR],
		    				['minute', Ext.Date.MINUTE],
		    				['second', Ext.Date.SECOND]
		    	], function(time) {
        			if (Ext.Date.diff(createdDate, now, time[1])>(time[0]=='second' ? 1 : 0)) {
        				var count = Ext.Date.diff(createdDate, now, time[1]);
        				message+="<span class='info-tip' data-qtip='"+Ext.Date.format(createdDate, "Y-m-d, H:i:s")+"'>";
        				if (count==1) {message+=new Ext.XTemplate(this.localize(time[0]+'Ago')).apply({count: count, date: createdDate})}
        				else {message+=new Ext.XTemplate(this.localize(time[0]+'sAgo')).apply({count: count, date: createdDate})}
        				message+="</span>";
        				return false
        			}
				}, this
			)===true) { // if array returns true, none of the conditions matched, so say now
				message+=this.localize('now');
			}
			message+='.';
			
			message+='';
		}
		if (config===true) {message+=' ('+this.getId()+")";}
		return message;
    }
    
    

});
Ext.define('Voyant.widget.CodeEditor', {
	extend: 'Ext.panel.Panel',
    mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.notebook.util.Embed'],
	alias: 'widget.codeeditor',
    statics: {
    	i18n: {},
		api: {
			tableJson: undefined,
			content: '',
			mode: 'ace/mode/text',
			width: undefined
		}
    },
	constructor: function(config) {
    	config = config || {};
		var me = this;
    	me.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	me.buildFromParams();
    	Ext.apply(me, {
    		items: {
    			xtype: 'notebookcodeeditor',
    			content: config.content ? config.content : this.getApiParam('content'),
    			mode: config.mode ? config.mode : this.getApiParam("mode")
    		}
    	})
        me.callParent(arguments);
	},
	initComponent: function(config) {
    	var me = this, config = config || {};
    	me.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	me.callParent(arguments);
	},
	
	buildFromParams: function() {
		var me = this, tableJson = this.getApiParam('tableJson');
		if (tableJson) {
			var json = Ext.decode(tableJson);
			var text = json.headers.join("\t") + "\n"+
				json.rows.map(function(row) {return row.join("\t")}).join("\n");
			this.setApiParam('content', text);
		}
	}
})
Ext.define('Voyant.widget.CorpusSelector', {
    extend: 'Ext.form.field.ComboBox',
    mixins: ['Voyant.util.Localization', 'Voyant.util.Api'],
    alias: 'widget.corpusselector',
    statics: {
	    	i18n: {
	    	},
	    	api: {
	    		openMenu: undefined
	    	}
    },
    
    constructor: function(config) {
        config = config || {};
        
        // need to call here to get openMenu
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);

	    	var data = [['shakespeare',"Shakespeare's Plays"],['austen',"Austen's Novels"]];	
	    	// check API and server option for open menu values
	    	if (this.getApiParam("openMenu")) {
				data = this.getStoreItemsFromDefinition(this.getApiParam("openMenu"));
		} else if (Voyant.application && Voyant.application.getOpenMenu && Voyant.application.getOpenMenu()) {
			var arg = Voyant.application.getOpenMenu();
			arg = decodeURIComponent(arg);
			arg = arg.replace(/\+/g,' ');
			if (arg.charAt(0)=='"' && arg.charAt(arg.length-1)=='"') {
				arg = arg.substring(1, arg.length-1);
			}
			data = this.getStoreItemsFromDefinition(arg);
	    	}
	
	    	Ext.applyIf(config, {
	    		fieldLabel: this.localize('chooseCorpus'),
	            labelWidth: 125,
	            labelAlign: 'right',
	            name:'corpus',
	            queryMode:'local',
	            store: data
	    	});
        this.callParent([config]);
    },

    	initComponent: function(config) {
    		config = config || {};
        this.callParent([config]);
    },
    
    getStoreItemsFromDefinition: function(definition) {
	    	var data = [], items = definition.split(";");
	    	for (var i=0; i<items.length; i++) {
	    		var nameValue = items[i].split(":");
	    		if (nameValue[0]) {
	        		data.push([nameValue[0],nameValue[1] ? nameValue[1] : nameValue[0]]);
	    		}
	    	}
	    	return data;
    }
})
Ext.define('Voyant.widget.ListEditor', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.listeditor',
    layout: 'hbox',
    statics: {
    	i18n: {
    	}
    },
    initComponent: function(config) {
    	var me = this;
    	var value = this.up('window').panel.getApiParam(this.name);
    	var data = value ? [{name: value, value: value}] : [];
    	
    	data.splice(0, 0, {name : this.localize('none'),   value: ''},  {name : this.localize('new'),   value: 'new'})
    	Ext.apply(me, {
	    		items: [{
	    	        xtype: 'combo',
	    	        queryMode: 'local',
	    	        value: value,
	    	        triggerAction: 'all',
	    	        editable: true,
	    	        fieldLabel: this.localize(this.name+'Label'),
	    	        labelAlign: 'right',
	    	        name: this.name,
	    	        displayField: 'name',
	    	        valueField: 'value',
	    	        store: {
	    	            fields: ['name', 'value'],
	    	            data: data
	    	        }
	    		}, {width: 10}, {xtype: 'tbspacer'}, {
	    			xtype: 'button',
	    			text: this.localize('editList'),
		            ui: 'default-toolbar',
	    			handler: this.editList,
	    			scope: this
	    		}]
    	})
        me.callParent(arguments);
    },
    
    editList: function() {
    	var win = this.up('window');
    	var panel = win.panel;
    	var value = this.down('combo').getValue();
    	Ext.Ajax.request({
    	    url: panel.getTromboneUrl(),
    	    params: {
        		tool: 'resource.KeywordsManager',
        		list: value
    	    },
    	    success: function(response){
    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	var keywords = json.keywords.keywords.sort().join("\n");
    			Ext.Msg.show({
	    		    title: this.localize('editListTitle'),
	    		    message: this.localize('editListMessage'),
	    		    buttons: Ext.Msg.OKCANCEL,
	    		    buttonText: {
	    		        ok: this.localize('ok'),
	    		        cancel: this.localize('cancel')
	    		    },
	    		    icon: Ext.Msg.INFO,
	    		    prompt: true,
	    	        multiline: true,
	    	        value: keywords,
	    	        original: keywords,
	    	        fn: function(btn,value,list) {
	    	        	if (btn=='ok' && list.original!=value) {
	    	        		var combo = this.down('combo')
	    	        		if (Ext.String.trim(value).length==0) {
	    	        			combo.setValue('empty');
	    	        		}
	    	        		else {
	    	        	    	Ext.Ajax.request({
	    	        	    	    url: panel.getTromboneUrl(),
	    	        	    	    params: {
	    	        	        		tool: 'resource.StoredResource',
	    	        	    			storeResource: value
	    	        	    	    },
	    	        	    	    combo: combo,
	    	        	    	    success: function(response, req) {
	    	        	    	    	var json = Ext.util.JSON.decode(response.responseText);
	    	        	    	    	var store = req.combo.getStore();
	    	        	    	    	var value = 'keywords-'+json.storedResource.id;
	    	        	    	    	store.add({name: value, value: value});
	    	        	    	    	req.combo.setValue(value)
	    	        	    	    	req.combo.updateLayout()
	    	        	    	    },
	    	        	    	    scope: this
	    	        	    	})
	    	        		}
	    	        	}
	    	        },
	    	        scope: this
    			})
    	    },
    	    scope: this
    	});
    }
})
Ext.define('Voyant.widget.StopListOption', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.stoplistoption',
    layout: 'hbox',
    statics: {
    		stoplists: {
    		    ar: "stop.ar.arabic-lucene.txt",
    			bg: "stop.bu.bulgarian-lucene.txt",
    			br: "stop.br.breton-lucene.txt",
    			ca: "stop.ca.catalan-lucene.txt",
    			ckb: "stop.ckb-turkish-lucene.txt",
    			cn: "stop.cn.chinese-lawrence.txt",
    			cz: "stop.cz.czech-lucene.txt",
    			de: "stop.de.german.txt",
    			el: "stop.el.greek-lucene.txt",
    			en: "stop.en.taporware.txt",
    			es: "stop.es.spanish.txt",
    			eu: "stop.eu.basque-lucene.txt",
    			fa: "stop.fa.farsi-lucene.txt",
    			fr: "stop.fr.veronis.txt",
    			ga: "stop.ga-irish-lucene.txt",
    			gl: "stop.ga.galician-lucene.txt",
    			grc: "stop.grc.ancient-greek.txt",
    			hi: "stop.hi.hindi-lucene.txt",
    			hu: "stop.hu.hungarian.txt",
    			hy: "stop.hy.armenian-lucene.txt",
    			id: "stop.id.indonesian-lucene.txt",
    			it: "stop.it.italian.txt",
    			ja: "stop.ja.japanese-lucene.txt",
    			la: "stop.la.latin.txt",
    			lv: "stop.lv.latvian-lucene.txt",
    			lt: "stop.lt.lithuanian-lucene.txt",
    			mu: "stop.mu.multi.txt",
    			nl: "stop.nl.dutch.txt",
    			no: "stop.no.norwegian.txt",
    			ro: "stop.ro.romanian-lucene.txt",
    			se: "stop.se.swedish-long.txt",
    			th: "stop.th.thai-lucene.txt",
    			tr: "stop.tr.turkish-lucene.txt"
    		},
	    	i18n: {
	    	}
    },
    initComponent: function(config) {
    	var me = this;
    	var value = this.up('window').panel.getApiParam('stopList');
    	var data = [];
    	for (id in Voyant.widget.StopListOption.stoplists) {
    		data.push({name: this.localize(id), value: Voyant.widget.StopListOption.stoplists[id]})
    	}
    	data.sort(function(a,b) { // sort by label
    		return a.name < b.name ? -1 : 1;
    	})
    	data.splice(0, 0, {name : this.localize('auto'),   value: 'auto'}, {name : this.localize('none'),   value: ''},  {name : this.localize('new'),   value: 'new'})
    	Ext.apply(me, {
	    		items: [{
	    	        xtype: 'combo',
	    	        queryMode: 'local',
	    	        value: value,
	    	        triggerAction: 'all',
	    	        editable: true,
	    	        fieldLabel: this.localize('label'),
	    	        labelAlign: 'right',
	    	        name: 'stopList',
	    	        displayField: 'name',
	    	        valueField: 'value',
	    	        store: {
	    	            fields: ['name', 'value'],
	    	            data: data
	    	        }
	    		}, {width: 10}, {xtype: 'tbspacer'}, {
	    			xtype: 'button',
	    			text: this.localize('editList'),
		            ui: 'default-toolbar',
	    			handler: this.editList,
	    			scope: this
	    		}, {width: 10}, {
	    			xtype: 'checkbox',
	    			name: 'stopListGlobal',
	    			checked: true,
	    			boxLabel: this.localize('applyGlobally')
	    		}]
    	})
        me.callParent(arguments);
    },
    
    editList: function() {
    	var win = this.up('window');
    	var panel = win.panel;
    	var value = this.down('combo').getValue();
    	var corpusId = panel.getApplication && panel.getApplication().getCorpus ? panel.getApplication().getCorpus().getId() : undefined;
    	if (value=='auto' && !corpusId) {
    		Ext.Msg.show({
			    title: this.localize('noEditAutoTitle'),
			    message: this.localize('noEditAutoMessage'),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
    		return
    	}
    	Ext.Ajax.request({
    	    url: panel.getTromboneUrl(),
    	    params: {
        		tool: 'resource.KeywordsManager',
    			stopList: value,
    			corpus: corpusId
    	    },
    	    success: function(response){
    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	var keywords = json.keywords.keywords.sort().join("\n");
    			Ext.Msg.show({
	    		    title: this.localize('editStopListTitle'),
	    		    message: this.localize('editStopListMessage'),
	    		    buttons: Ext.Msg.OKCANCEL,
	    		    buttonText: {
	    		        ok: this.localize('ok'),
	    		        cancel: this.localize('cancel')
	    		    },
	    		    icon: Ext.Msg.INFO,
	    		    prompt: true,
	    	        multiline: true,
	    	        value: keywords,
	    	        original: keywords,
	    	        fn: function(btn,value,stoplist) {
	    	        	if (btn=='ok' && stoplist.original!=value) {
	    	        		var combo = this.down('combo')
	    	        		if (Ext.String.trim(value).length==0) {
	    	        			combo.setValue('empty');
	    	        		}
	    	        		else {
	    	        	    	Ext.Ajax.request({
	    	        	    	    url: panel.getTromboneUrl(),
	    	        	    	    params: {
	    	        	        		tool: 'resource.StoredResource',
	    	        	    			storeResource: value,
	    	        	    			corpus: corpusId
	    	        	    	    },
	    	        	    	    combo: combo,
	    	        	    	    success: function(response, req) {
	    	        	    	    	var json = Ext.util.JSON.decode(response.responseText);
	    	        	    	    	var store = req.combo.getStore();
	    	        	    	    	var value = 'keywords-'+json.storedResource.id;
	    	        	    	    	store.add({name: value, value: value});
	    	        	    	    	req.combo.setValue(value)
	    	        	    	    	req.combo.updateLayout()
	    	        	    	    },
	    	        	    	    scope: this
	    	        	    	})
	    	        		}
	    	        	}
	    	        },
	    	        scope: this
    			})
    	    },
    	    scope: this
    	});
    }
})
Ext.define('Voyant.widget.QuerySearchField', {
    extend: 'Ext.form.field.Tag',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.querysearchfield',
	statics: {
		i18n: {
		}
	},
	config: {
		corpus: undefined,
		tokenType: 'lexical',
		isDocsMode: false,
		inDocumentsCountOnly: undefined,
		stopList: undefined,
		showAggregateInDocumentsCount: false,
		clearOnQuery: false
	},
	hasCorpusLoadedListener: false,
	isClearing: false, // flag for clearOnQuery
    
    constructor: function(config) {
    	config = config || {};
    	var itemTpl = config.itemTpl ? config.itemTpl : '{term} ({'+(config.inDocumentsCountOnly ? 'inDocumentsCount' : 'rawFreq')+'})';
    	Ext.applyIf(config, {
    		minWidth: 100,
    		maxWidth: 200,
    		matchFieldWidth : false,
    		minChars: 2,
    	    displayField: 'term',
    	    valueField: 'term',
    	    filterPickList: true,
    	    createNewOnEnter: true,
    	    createNewOnBlur: false,
    	    autoSelect: false,
//    	    emptyText: this.localize('querySearch'),
    	    tpl: [
    	    	'<ul class="x-list-plain"><tpl for=".">',
    	    	'<li role="option" class="x-boundlist-item" style="white-space: nowrap;">'+itemTpl+'</li>',
    	    	'</tpl></ul>'
    	    ],
    	    triggers: {
    	        help: {
    	            weight: 2,
    	            cls: 'fa-trigger form-fa-help-trigger',
    	            handler: function() {
    	            	Ext.Msg.show({
    	            	    title: this.localize('querySearch'),
    	            	    message: this.getIsDocsMode() ? this.localize('querySearchDocsModeTip') : this.localize('querySearchTip'),
    	            	    buttons: Ext.OK,
    	            	    icon: Ext.Msg.INFO
    	            	});
    	            },
    	            scope: 'this'
    	        }
    	   }
    	})
    	if (config.showAggregateInDocumentsCount) {
    		config.triggers.count = {
	            cls: 'fa-trigger',
	            handler: 'onHelpClick',
	            scope: 'this',
	            hidden: true
    		}
    	}
    	if (config.clearOnQuery) {
    		this.setClearOnQuery(config.clearOnQuery);
    	}
        this.callParent(arguments);
    },
    initComponent: function(config) {
    	var me = this;

    	me.on("beforequery", function(queryPlan) {
    		if (queryPlan.query) {
    			queryPlan.query = queryPlan.query.trim();
    			if (queryPlan.query.charAt(0)=="^") {
    				queryPlan.query=queryPlan.query.substring(1)
    				queryPlan.cancel = queryPlan.query.length==0; // cancel if it's just that character
    			}
    			if (queryPlan.query.charAt(0)=="*") { // convert leading wildcard to regex
    				queryPlan.query = "."+queryPlan.query;
    			}
    			if (queryPlan.query.charAt(queryPlan.query.length-1)=='*' || queryPlan.query.charAt(queryPlan.query.length-1)=='|') {
    				queryPlan.query=queryPlan.query.substring(0,queryPlan.query.length-1)
    				queryPlan.cancel = queryPlan.query.length==0; // cancel if it's just that character
    			}
    			if (queryPlan.query.charAt(0)==".") {
    				queryPlan.cancel = queryPlan.query.length< (/\W/.test(queryPlan.query.charAt(1)) ? 5 : 4) // cancel if we only have 3 or fewer after .
    			}
    			try {
                    new RegExp(queryPlan.query);
	            }
	            catch(e) {
	            	queryPlan.cancel = true;
	            }
	            if (queryPlan.query.indexOf('"')>-1) { // deal with unfinished phrases
	            	if (queryPlan.query.indexOf(" ")==-1) {queryPlan.cancel=true} // no space in phrase
	            	if ((queryPlan.query.match(/"/) || []).length!=2) {queryPlan.cancel=true;} // not balanced quotes
	            }
	            if (queryPlan.query.indexOf("*")>-1) {
	            	// skip for multiword or pipes
	            	if (queryPlan.query.indexOf(" ")==-1 && queryPlan.query.indexOf("|")==-1) {
	            		queryPlan.query += ",^"+queryPlan.query;
	            	}
	            } else {
	            	queryPlan.query = queryPlan.query+"*"+ (queryPlan.query.indexOf(" ")==-1  && queryPlan.query.indexOf("|")==-1 ? ","+"^"+queryPlan.query+"*" : "")
	            }
    		}
    	});
    	
    	me.on("change", function(tags, queries) {
    		if (!me.isClearing) {
	    		queries = queries.map(function(query) {return query.replace(/^(\^?)\*/, "$1.*")});
	    		me.up('panel').fireEvent("query", me, queries);
	    		if (me.getClearOnQuery()) {
	    			me.isClearing = true;
	    			me.removeValue(me.getValueRecords());
	    		}
	    		if (me.triggers.count) {
	    			me.triggers.count.show();
	    			me.triggers.count.getEl().setHtml('0');
	    			if (queries.length>0) {
	    				me.getCorpus().getCorpusTerms().load({
	    					params: {
	    						query: queries.map(function(q) {return '('+q+')'}).join("|"),
				    			tokenType: me.getTokenType(),
				    			stopList: me.getStopList(),
				    			inDocumentsCountOnly: true
	    					},
	    					callback: function(records, operation, success) {
	    						debugger
	    						if (success && records && records.length==1) {
	    							me.triggers.count.getEl().setHtml(records[0].getInDocumentsCount())
	    						}
	    					}
	    				})
	    			} else {
	    				me.triggers.count.hide();
	    			}
	    		}
    		} else {
    			me.isClearing = false;
    		}
    	});

    	// we need to make sure the panel is a voyantpanel
    	// so that we get loadedCorpus event after a call to Voyant.util.Toolable.replacePanel
    	var parentPanel = me.findParentBy(function(clz) {
    		return clz.mixins["Voyant.panel.Panel"];
		});
    	if (parentPanel != null) {
    		if (parentPanel.getCorpus && parentPanel.getCorpus()) {
    			me.on("afterrender", function(c) {
    				this.doSetCorpus(parentPanel.getCorpus());	
    			})
    			me.hasCorpusLoadedListener = true;    			
    		} else {
	    	    	parentPanel.on("loadedCorpus", function(src, corpus) {
	    	    		me.doSetCorpus(corpus);
	    	    	}, me);
	    	    	me.hasCorpusLoadedListener = true;    			
    		}
    	}
    	
    	me.on("afterrender", function(c) {
    		if (me.hasCorpusLoadedListener === false) {
    			if (!me.getCorpus()) {
    	    		parentPanel = me.findParentBy(function(clz) {
    	    			return clz.mixins["Voyant.panel.Panel"];
        			});
    	    		if (parentPanel == null) {
    	    			parentPanel = me.up('window').panel;
    	    		}
    	    		var corpus = parentPanel.getApplication().getCorpus();
    				if (corpus !== undefined) {
    					me.doSetCorpus(corpus);
    				} else {
    					parentPanel.on("loadedCorpus", function(src, corpus) {
    						me.doSetCorpus(corpus);
    			    	}, me);
    					me.hasCorpusLoadedListener = true;
    				}
    			}
    		}
			
    		if (me.triggers && me.triggers.help) {
    			Ext.tip.QuickTipManager.register({
    				target: me.triggers.help.getEl(),
    				text: me.getIsDocsMode() ? me.localize('querySearchDocsModeTip') : me.localize('querySearchTip')
				});
			}
    		if (me.triggers && me.triggers.count) {
    			Ext.tip.QuickTipManager.register({
    				target: me.triggers.count.getEl(),
    				text: me.localize('aggregateInDocumentsCount')
				});
			}
    	});
    	
    	me.on("beforedestroy", function(c) {
    		if (me.triggers && me.triggers.help) {
    			Ext.tip.QuickTipManager.unregister(me.triggers.help.getEl());
    		}
    		if (me.triggers && me.triggers.count) {
    			Ext.tip.QuickTipManager.unregister(me.triggers.count.getEl());
    		}
    	});
    	
    	me.callParent(arguments);
    },
    
    doSetCorpus: function(corpus) {
    	if (corpus != null) {
	    	this.setCorpus(corpus);
			var stopList = this.getStopList();
			if (stopList==undefined) {
	    		if (this.getApiParam) {this.setStopList(this.getApiParam("stopList"))}
	    		else {
	    			var parent = this.up("panel");
	    			while (parent) {
	    				if (parent && parent.getApiParam) {
		    				this.setStopList(parent.getApiParam("stopList"))
		    				break;
		    			}
	    				parent = parent.up("panel");
	    			}
	    		}
			}

			var store = corpus.getCorpusTerms({				
				corpus: corpus.getAliasOrId(),
				proxy: {
					extraParams: {
			    			limit: 10,
			    			tokenType: this.tokenType,
			    			stopList: this.getStopList(),
			    			inDocumentsCountOnly: this.getInDocumentsCountOnly()
					}
				}
			});
			store.on("load", function() {
				this.fireEvent.apply(this, ["load"].concat(Array.prototype.slice.call(arguments)));
			}, this);

			this.setStore(store);
    	}
    }
    
});

Ext.define('Voyant.widget.TotalPropertyStatus', {
    extend: 'Ext.Component',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.totalpropertystatus',
	statics: {
		i18n: {
		}
	},
    initComponent: function() {
        var me = this;
        Ext.applyIf(me, {
            tpl: this.localize('totalPropertyStatus'),
            itemId: 'totalpropertystatus',
            style: 'margin-right:5px',
            listeners: {
            	afterrender: function(cmp) {
            		var grid = cmp.up('grid')
            		if (grid) {
            			var store = grid.getStore();
            			cmp.updateStatus(store.getTotalCount()); // make sure we set this in case of lazy render
            			grid.getStore().on("totalcountchange", cmp.updateStatus, cmp) // bind changes to update
            		}
            	}
            }
        })
        me.callParent(arguments);
    },
    updateStatus: function(count) {
    	this.update({count: count})
    }
});

Ext.define('Voyant.widget.DocumentSelector', {
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.documentselector',
	glyph: 'xf10c@FontAwesome',
	statics: {
		i18n: {
		}
	},

	config: {
		docs: undefined,
		corpus: undefined,
		singleSelect: false
	},
	
    initComponent: function() {

		var me = this;
		
		this.setSingleSelect(this.config.singleSelect == undefined ? this.getSingleSelect() : this.config.singleSelect);
		
		Ext.apply(me, {
			text: this.localize('documents'),
			menu: {
				width: 250,
				fbar: [{
					xtype: 'checkbox',
					hidden: this.getSingleSelect(),
					boxLabel: this.localize("all"),
					listeners: {
						change: {
							fn: function(item, checked) {
								this.getMenu().items.each(function(item) {
									item.setChecked(checked);
								});
							},
							scope: this
						}
					}
				},{xtype:'tbfill'},{
		    		xtype: 'button',
		    		text: this.localize('ok'),
					hidden: this.getSingleSelect(),
	    	    	scale: 'small',
		    		handler: function(button, e) {
		    			var docs = [];
		    			this.getMenu().items.each(function(item) {
		    				if (item.checked) {
			    				docs.push(item.docId);
		    				}
		    			}, this);
		    			
		    			// tell parent tool
						var panel = button.findParentBy(function(clz) {
							return clz.mixins["Voyant.panel.Panel"];
						});
						if (panel) {
			    			panel.fireEvent('documentsSelected', button, docs);
						}

		    			// hide the opened menu
		    			button.findParentBy(function(clz) {
		    				if (clz.isXType("button") && clz.hasVisibleMenu()) {
		    					clz.hideMenu();
		    					return true;
		    				}
		    				return false;
		    			});
		    		},
		    		scope: this
		    	},{
		    		xtype: 'button',
		    		text: this.localize('cancel'),
	    	    	scale: 'small',
		    		handler: function(b, e) {
		    			this.findParentBy(function(clz) {
		    				if (clz.isXType("button") && clz.hasVisibleMenu()) {
		    					clz.hideMenu();
		    					return true;
		    				}
		    				return false;
		    			}, this);
		    			this.hideMenu();
		    		},
		    		scope: this
		    	}]
			},
			listeners: {
				afterrender: function(selector) {
					selector.on("loadedCorpus", function(src, corpus) {
						this.setCorpus(corpus);
						if (corpus.getDocumentsCount()==1) {
							this.hide();
						} else {
							selector.populate(corpus.getDocumentsStore().getRange(), true);
						}
					}, selector);
					var panel = selector.findParentBy(function(clz) {
						return clz.mixins["Voyant.panel.Panel"];
					});
					if (panel) {
						panel.on("loadedCorpus", function(src, corpus) {
							selector.fireEvent("loadedCorpus", src, corpus);
						}, selector);
						if (panel.getCorpus && panel.getCorpus()) {selector.fireEvent("loadedCorpus", selector, panel.getCorpus());}
						else if (panel.getStore && panel.getStore() && panel.getStore().getCorpus && panel.getStore().getCorpus()) {
							selector.fireEvent("loadedCorpus", selector, panel.getStore().getCorpus());
						}
					}
				}
			}
		});


    },
    
    populate: function(docs, replace) {
    	this.setDocs(docs);
    	
    	var menu = this.getMenu();
    	if (replace) {
    		menu.removeAll();
    	}
    	
    	var isSingleSelect = this.getSingleSelect();
    	
    	var groupId = 'docGroup'+Ext.id();
    	docs.forEach(function(doc, index) {
    		menu.add({
    			xtype: 'menucheckitem',
    			text: doc.getShortTitle(),
    			docId: doc.get('id'),
    			checked: isSingleSelect && index == 0 || !isSingleSelect,
    			group: isSingleSelect ? groupId : undefined,
    			checkHandler: function(item, checked) {
    				if (this.getSingleSelect() && checked) {
    					var panel = this.findParentBy(function(clz) {
    						return clz.mixins["Voyant.panel.Panel"];
    					});
    					if (panel) {
	    					panel.fireEvent('documentSelected', this, doc);
    					}
    				}
    			},
    			scope: this
    		});
    	}, this);
    	
    }
});

Ext.define('Voyant.widget.DocumentSelectorButton', {
    extend: 'Ext.button.Button',
    alias: 'widget.documentselectorbutton',
    mixins: ['Voyant.widget.DocumentSelector'],
    initComponent: function() {
    	this.mixins["Voyant.widget.DocumentSelector"].initComponent.apply(this, arguments);
		this.callParent();
    }
})
    
Ext.define('Voyant.widget.DocumentSelectorMenuItem', {
    extend: 'Ext.menu.Item',
    alias: 'widget.documentselectormenuitem',
    mixins: ['Voyant.widget.DocumentSelector'],
    initComponent: function() {
    	this.mixins["Voyant.widget.DocumentSelector"].initComponent.apply(this, arguments);
		this.callParent();
    }
})

Ext.define('Voyant.widget.CorpusDocumentSelector', {
    extend: 'Ext.button.Button',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.corpusdocumentselector',
	statics: {
		i18n: {
		}
	},
	config: {
		corpus: undefined,
		singleSelect: false
	},
	
    initComponent: function() {
		var me = this;
		
		this.setSingleSelect(this.config.singleSelect == undefined ? this.getSingleSelect() : this.config.singleSelect);
		
		Ext.apply(me, {
			text: this.localize('scale'),
			glyph: 'xf059@FontAwesome',
			menu: {
				items: [{
					text: this.localize("corpus"),
					glyph: 'xf111@FontAwesome',
					handler: function(button) {
						var panel = this.findParentBy(function(clz) {
							return clz.mixins["Voyant.panel.Panel"];
						});
						if (panel) {
							button.nextSibling().menu.items.each(function(item) {
								item.setChecked(false, true);
							});
							panel.fireEvent("corpusSelected", this, this.getCorpus());
						}
					},
					scope: this
				},{
					xtype: 'documentselectormenuitem',
					singleSelect: this.getSingleSelect()
				}]
			},
			listeners: {
				afterrender: function(selector) {
					selector.on("loadedCorpus", function(src, corpus) {
						this.setCorpus(corpus);
						if (corpus.getDocumentsCount()==1) {
							this.hide();
						}
					}, selector);
					var panel = selector.findParentBy(function(clz) {
						return clz.mixins["Voyant.panel.Panel"];
					});
					if (panel) {
						panel.on("loadedCorpus", function(src, corpus) {
							selector.fireEvent("loadedCorpus", src, corpus);
						}, selector);
						if (panel.getCorpus && panel.getCorpus()) {selector.fireEvent("loadedCorpus", selector, panel.getCorpus())}
						else if (panel.getStore && panel.getStore() && panel.getStore().getCorpus && panel.getStore().getCorpus()) {
							selector.fireEvent("loadedCorpus", selector, panel.getStore().getCorpus());
						}
					}
				}
			}
		});

		me.callParent(arguments);	
    }
});
Ext.define('Voyant.widget.DownloadFilenameBuilder', {
    extend: 'Ext.form.FieldContainer', //'Ext.container.Container',
    mixins: ['Voyant.util.Localization', 'Ext.form.field.Field'],
    alias: 'widget.downloadfilenamebuilder',
	statics: {
		i18n: {
		}
	},
	config: {
	    name: 'documentFilename',
	    itemId: 'documentFilename',
		fields: ['pubDate', 'title', 'author'],
		value: ['pubDate', 'title'],
		width: 400
	},
	

    initComponent: function(config) {
    	config = config || {};
        var me = this;
        
        me.initField();

        me.on('afterrender', function() {
        	this.items.eachKey(function(key) {
        		new Ext.dd.DropZone(this.items.get(key).getTargetEl(), {
        			ddGroup: 'downloadfilename',
        			getTargetFromEvent: function(e) {
        				var target = e.getTarget();
        				// check that we're not dropping on another source
        				return target.className && target.className.indexOf('dragsource')>-1 ? target.parentNode : target;
        	        },
        	        onNodeDrop : function(target, dd, e, data){
        	        	target.appendChild(dd.el.dom);
        	            return true;
        	        }
        		});
        	}, this)
        	
        	this.getFields().map(function(item) {
        		item = Ext.isString(item) ? {
            		tag: 'span',
            		html: this.localize(item+"Label"),
            		value: item
        		} : item;
        		var container = this.queryById(Ext.Array.contains(this.getValue(), item.value) ? 'enabled' : 'available')
				var el = Ext.dom.Helper.append(container.getTargetEl(), Ext.apply(item, {cls: 'dragsource'}));
    			Ext.create('Ext.dd.DragSource', el, {
    				ddGroup: 'downloadfilename'
                });
        	}, this)
        }, me);
        me.callParent(arguments);
    }, 
    defaults: {
    	xtype: 'container',
    	width: '100%'
    },
    items: [{
    	itemId: 'enabled',
    	cls: 'dropzone dropzone-enabled'
    }, {
    	itemId: 'available',
    	cls: 'dropzone dropzone-disabled'
    }],
    
    
    getValue: function() {
    	return this.rendered ? this.getTargetEl().query('.dropzone-enabled .dragsource').map(function(source) {return source.getAttribute('value')}) : this.value;
    },
    
    setValue: function(val) {
    	if (this.rendered) {
        	this.getTargetEl().query(".dragsource", false).forEach(function(source) {
        		var enabled = Ext.Array.contains(this.value, source.getAttribute('value'))
        		if (enabled && source.parent().hasCls('dropzone-disabled')) {
        			this.queryById('enabled').getTargetEl().appendChild(source.dom);
        		} else if (!enabled && source.parent().hasCls('dropzone-enabled')) {
        			this.queryById('available').getTargetEl().appendChild(source.dom);
        		}
        	}, this)
    	} else {
    		this.value = val;
    	}
    }
    
    
});

Ext.define('Voyant.widget.DownloadFileFormat', {
    extend: 'Ext.form.CheckboxGroup', //'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.downloadfileformat',
	statics: {
		i18n: {
		}
	},
    initComponent: function(config) {
    	config = config || {};
        var me = this;
        
        Ext.apply(this, {
        	labelAlign: config.labelAlign ? config.labelAlign : 'right'
        })

        Ext.applyIf(this, {
        	fieldLabel: this.localize('fieldLabel'),
        	items: [
	            {boxLabel: this.localize('original'), name: 'documentFormat', inputValue: 'SOURCE'},
	            {boxLabel: this.localize('voyantXml'), name: 'documentFormat', inputValue: 'VOYANT'},
                {boxLabel: this.localize('plainText'), name: 'documentFormat', inputValue: 'TXT'}
        	],
        	width: 450
        })
        me.on('afterrender', function() {
        	this.query('checkbox').forEach(function(cmp) {
        		var tooltip = this.localize(cmp.inputValue+"Tip");
        		if (tooltip.indexOf(cmp.inputValue+"Tip")==-1) {
		        	Ext.tip.QuickTipManager.register({
		                 target:cmp.getEl(),
		                 text: tooltip
		             });
        		}
        	}, this)
        }, this)
        me.on('beforedestroy', function() {
        	this.query('checkbox').forEach(function(cmp) {
        		Ext.tip.QuickTipManager.unregister(cmp.getEl());
        	}, this);
        }, this);

        me.callParent(arguments);
    }
});

Ext.define('Voyant.widget.DownloadOptions', {
    extend: 'Ext.form.FieldSet',
    mixins: ['Voyant.util.Localization'],
    requires: ['Voyant.widget.DownloadFileFormat', 'Voyant.widget.DownloadFilenameBuilder'],
    alias: 'widget.downloadoptions',
	statics: {
		i18n: {
		}
	},
	config: {
		items: [{xtype: 'downloadfileformat'}, {xtype: 'downloadfilenamebuilder'}]
	},
    initComponent: function(config) {
    	config = config || {};
    	var me = this;
        Ext.apply(this, {
        	title: config.title ? config.title : this.localize('title')
        })
        me.callParent(arguments);
    }
});

Ext.define('Voyant.widget.FontFamilyOption', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.fontfamilyoption',
    statics: {
    	i18n: {
    	},
    	fonts: [{name: "Georgia", value: 'Georgia, serif'},
	            {name: "Palatino", value: '"Palatino Linotype", "Book Antiqua", Palatino, serif'},
	            {name: "Times New Roman", value: '"Times New Roman", Times, serif'},
	            {name: "Arial", value: 'Arial, Helvetica, sans-serif'},
	            {name: "Arial Black", value: '"Arial Black", Gadget, sans-serif'},
	            {name: "Comic Sans MS", value: '"Comic Sans MS", cursive, sans-serif'},
	            {name: "Impact", value: 'Impact, Charcoal, sans-serif'},
	            {name: "Lato", value: 'LatoWeb'},
	            {name: "Lucida", value: '"Lucida Sans Unicode", "Lucida Grande", sans-serif'},
	            {name: "Tahoma/Geneva", value: 'Tahoma, Geneva, sans-serif'},
	            {name: "Trebuchet MS/Helvetica", value: '"Trebuchet MS", Helvetica, sans-serif'},
	            {name: "Verdana/Geneva", value: 'Verdana, Geneva, sans-serif'},
	            {name: "Courrier New", value: '"Courier New", Courier, monospace'},
	            {name: "Lucida/Monaco", value: '"Lucida Console", Monaco, monospace'}]
    },
    name: 'fontFamily',
    initComponent: function(config) {
    	config = config || {};
    	var me = this;
    	var value = this.up('window').panel.getApiParam('fontFamily');
    	var data = Ext.ClassManager.getClass(this).fonts;

    	if (!Ext.Array.contains(data.map(function(item) {return item.value}), value)) {
        	data.splice(0, 0, {name : value, value: value});//
    	}
    	
    	Ext.apply(me, {
    		items: {
    			xtype: 'combo',
    	        queryMode: 'local',
    	        name: 'fontFamily',
    	        value: value,
    	        triggerAction: 'all',
    	        editable: true,
    	        fieldLabel: this.localize('label'),
    	        labelAlign: 'right',
    	        displayField: 'name',
    	        valueField: 'value',
    	        store: {
    	            fields: ['name', 'value'],
    	            data: data
    	        },
    	        width: 400
    		}
    	})
        me.callParent(arguments);
    }
})
Ext.define('Voyant.widget.ColorPaletteOption', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.colorpaletteoption',
    layout: 'hbox',
    statics: {
    	i18n: {
    	}
    },
    
    paletteTpl: new Ext.XTemplate(
		'<tpl for=".">',
			'<div class="color" style="background-color: rgb({color});"></div>',
		'</tpl>'
	),
	paletteStore: new Ext.data.ArrayStore({
        fields: ['id', 'color'],
        listeners: {
        	update: function(store, record, op, mod, details) {
        	},
        	scope: this
        } 
    }),
    
    editPaletteWin: null,
    spectrum: null,
    
    initComponent: function(config) {
    	var me = this;

    	var app = this.up('window').panel.getApplication();
    	var data = [];
    	for (var key in app.palettes) {
    		data.push({name: key, value: key});
    	}
    	var value = app.getApiParam('palette');
    	
    	Ext.apply(me, {
	    		items: [{
	    	        xtype: 'combo',
	    	        queryMode: 'local',
	    	        value: value,
	    	        triggerAction: 'all',
	    	        editable: true,
	    	        fieldLabel: me.localize('palette'),
	    	        labelAlign: 'right',
	    	        name: 'palette',
	    	        displayField: 'name',
	    	        valueField: 'value',
	    	        store: {
	    	            fields: ['name', 'value'],
	    	            data: data
	    	        }
	    		}, {width: 10}, {xtype: 'tbspacer'}, {
	    			xtype: 'button',
	    			text: this.localize('editList'),
		            ui: 'default-toolbar',
	    			handler: this.editPalette,
	    			scope: this
	    		}
//	    		, {width: 10}, {
//	    			xtype: 'checkbox',
//	    			name: 'paletteGlobal',
//	    			checked: true,
//	    			boxLabel: this.localize('applyGlobally')
//	    		}
	    		]
    	});
        me.callParent(arguments);
    },
    
    editPalette: function() {
    	var value = this.down('combo').getValue();
    	this.loadPalette(value);
    	
    	this.editPaletteWin = Ext.create('Ext.window.Window', {
			title: this.localize('paletteEditor'),
			modal: true,
			height: 300,
			width: 425,
			padding: 5,
			layout: {
				type: 'hbox',
				align: 'stretch'
			},
			items:[{
				flex: 1,
				layout: {
					type: 'vbox',
					align: 'stretch'
				},
				items: [{
					height: 24,
					margin: '0 0 5 0',
					items: [{
						xtype: 'button',
						text: this.localize('add'),
						margin: '0 5 0 0',
						handler: function(btn) {
							var color = this.spectrum.spectrum('get').toRgb();
							var dv = this.editPaletteWin.down('dataview');
							this.paletteStore.add([ [Ext.id(), [color.r, color.g, color.b]] ]);
							dv.refresh();
						},
						scope: this
					},{
						xtype: 'button',
						text: this.localize('remove'),
						margin: '0 5 0 0',
						handler: function(btn) {
							var dv = this.editPaletteWin.down('dataview');
							var sel = dv.getSelectionModel().getSelection()[0];
							if (sel != null) {
								this.paletteStore.remove(sel);
							}
							dv.refresh();
						},
						scope: this
					},{
						xtype: 'button',
						text: this.localize('clear'),
						handler: function(btn) {
							this.paletteStore.removeAll();
						},
						scope: this
					}]
				},{
					xtype: 'dataview',
					flex: 1,
					scrollable: 'y',
		        	store: this.paletteStore,
		        	tpl: this.paletteTpl,
		        	itemSelector: 'div.color',
		        	overItemCls: 'over',
		        	selectedItemCls: 'selected',
		        	selectionModel: {
		        		mode: 'SINGLE'
		        	},
		        	listeners: {
		        		selectionchange: function(viewmodel, selected, opts) {
		        			if (selected[0] != null) {
								var color = selected[0].get('color');
								var parentPanel = this.up('window').panel;
								var hex = parentPanel.getApplication().rgbToHex(color);
								this.spectrum.spectrum('set', hex);
							}
		        		},
		        		scope: this
		        	}
				}]
			},{
				itemId: 'colorEditor',
				width: 200,
				margin: '0 0 0 5',
				html: '<input type="text" style="display: none;" />'
			}],
			buttons: [{
				text: this.localize('saveNewPalette'),
				handler: function(btn) {
					this.savePalette();
					btn.up('window').close();
				},
				scope: this
			},{
				text: this.localize('cancel'),
				handler: function(btn) {
					btn.up('window').close();
				},
				scope: this
			}],
			listeners: {
				close: function(panel) {
					if (this.spectrum) {
						this.spectrum.spectrum('destroy');
						this.spectrum = null;
					}
				},
				scope: this
			}
    	}).show();
    	
    	this.initSpectrum();
    },
    
    setColorForSelected: function(color) {
    	if (this.spectrum !== null) { // need check due to https://github.com/bgrins/spectrum/issues/387
			var rgb = color.toRgb();
			var rgbA = [rgb.r, rgb.g, rgb.b];
			var dv = this.editPaletteWin.down('dataview');
			var sel = dv.getSelectionModel().getSelection()[0];
			if (sel != null) {
				sel.set('color', rgbA);
			}
    	}
	},
    
	initSpectrum: function() {
		if (this.spectrum === null) {
			var editor = this.editPaletteWin.down('#colorEditor');
			var input = editor.el.down('input');
			this.spectrum = $(input.dom).spectrum({
				flat: true,
				showInput: true,
				showButtons: false,
				preferredFormat: 'hex',
				change: this.setColorForSelected.bind(this),
				move: this.setColorForSelected.bind(this)
			});
		}
	},
	
    loadPalette: function(paletteId) {
    	var parentPanel = this.up('window').panel;
    	
    	var palette = parentPanel.getApplication().getColorPalette(paletteId);
    	var paletteData = [];
    	palette.forEach(function(c) {
    		paletteData.push([Ext.id(), c]);
    	}, this);
    	this.paletteStore.loadData(paletteData);
    },
    
    savePalette: function() {
    	var value = [];
    	this.paletteStore.each(function(c) {
    		value.push(c.get('color'));
    	});
    	var valueString = Ext.encode(value);
    	var parentPanel = this.up('window').panel;
    	var corpusId = parentPanel.getCorpus().getId();
    	Ext.Ajax.request({
    	    url: parentPanel.getTromboneUrl(),
    	    params: {
        		tool: 'resource.StoredResource',
    			storeResource: valueString,
    			corpus: corpusId
    	    },
    	    success: function(response, req) {
    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	var id = json.storedResource.id;
    	    	var combo = this.down('combo');
    	    	var store = combo.getStore();
    	    	store.add({name: id, value: id});
    	    	combo.setValue(id);
    	    	combo.updateLayout();
    	    	
    	    	parentPanel.getApplication().addColorPalette(id, value);
    	    },
    	    scope: this
    	});
    }
});
Ext.define('Voyant.widget.VoyantChart', {
    extend: 'Ext.chart.CartesianChart',
    mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.notebook.util.Embed'],
    alias: 'widget.voyantchart',
    statics: {
    	i18n: {
    	},
    	api: {
    		tableJson: undefined
    	}
    },
    constructor: function(config) {
    	config = config || {};
    	var me = this;
    	this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	this.callParent(arguments)
    	
    },
    initComponent: function(config) {
    	config = config || {};
    	this.on("afterrender", function() {
        	if (config && "tableJson" in config) {
        		Ext.apply(this, this.getConfigFromTableJson(config.tableJson));
        	}
        	else if (this.getApiParam('tableJson')) {
        		var chart = this.getConfigFromTableJson();
        		this.setAxes(chart.axes);
        		this.setSeries(chart.series);
        		this.setLegend(chart.legend);
        		this.setStore(chart.store);
        		this.redraw();
        	}
    	}, this)
    	this.callParent(arguments)
    },
    
    getConfigFromTableJson: function(jsonString) {
    	jsonString = jsonString || this.getApiParam('tableJson');
    	if (!jsonString) {return {}};
    	
		var json = JSON.parse(jsonString);
		
		json.headers = json.headers.map(function(header) {return header})
		// if we have only one column add a second column with a counter (as category)
		if (json.headers.length==1) {
			json.headers.push(1);
			json.rowKey = 1;
			json.rows.forEach(function(row, i) {if (row) {row.push(i)}})
		}
		
		// data
		var data = [];
		if (!json.rowKey) {json.rowKey=json.headers[0];}
		json.rows.forEach(function(row, i) {
			if (row) {
				var map = {};
				map[json.rowKey] = i;
				row = row.forEach(function(cell, j) {
					map[json.headers[j]] = cell
				})
				data.push(map);
			}
		})

		// start chart
		if (!json.config) {json.config = {}}
		var chart = {
			store: {
		        fields: Object.keys(data[0]),
		        data: data
			},
	        axes: Ext.isArray(json.config.axes) ? json.config.axes : [{},{}],
	        series: [],
    		legend: json.config.noLegend || Object.keys(data[0]).length<3 ? undefined : {docked:'top'}

		}

		// axes
		if (!json.config.axes) {json.config.axes = [{},{}]}
		chart.axes.forEach(function(axis, i) {
			if (Ext.isObject(json.config.axes)) {
				Ext.apply(axis, json.config.axes);
			} else if (Ext.isArray(json.config.axes)) {
				Ext.apply(axis, json.config.axes[i]);
			}
			Ext.applyIf(axis, {
	        	type: i==0 ? 'numeric' : 'category',
	        	position: i==0 ? 'left' : 'bottom',
	        	label: i==0 ? {} : {rotation: {degrees:-30}}
	        });
		})

		// series
		for (var i=0, len=json.headers.length; i<len;i++) {
			if (json.headers[i]==json.rowKey) {continue;} // don't chart the row key, that's the x axis 
			var cfg = {};
			if (json.config.series) {
				if (Ext.isObject(json.config.series)) {
					Ext.apply(cfg, json.config.series);
				} else if (Ext.isArray(json.config.series)) {
					Ext.apply(cfg, json.config.series[chart.series.length]);
				}
			}
			Ext.applyIf(cfg, {
		        type: 'line',
		        xField: json.rowKey,
		        yField: json.headers[i],
		        marker: {
		        	radius: 2
		        },
		        highlightCfg: {
	                scaling: 2
	            },
	            tooltip: {
	            	trackMouse: true,
	            	renderer: function (tooltip, record, item) {
	                    tooltip.setHtml(record.get(item.series.getYField())+": "+record.get(item.series.getYField()));
	                }
	            }
			});
			chart.series.push(cfg);
		}
		
		return chart;
    	
    }

})
Ext.define('Voyant.widget.LiveSearchGrid', {
    extend: 'Ext.grid.Panel',
    
    /**
     * @private
     * search value initialization
     */
    searchValue: null,
    
    /**
     * @private
     * The matched positions from the most recent search
     */
    matches: [],
    
    /**
     * @private
     * The current index matched.
     */
    currentIndex: null,
    
    /**
     * @private
     * The generated regular expression used for searching.
     */
    searchRegExp: null,
    
    /**
     * @private
     * Case sensitive mode.
     */
    caseSensitive: false,
    
    /**
     * @private
     * Regular expression mode.
     */
    regExpMode: false,
    
    /**
     * @cfg {String} matchCls
     * The matched string css classe.
     */
    matchCls: 'keyword',
    
    // Component initialization override: adds the top and bottom toolbars and setup headers renderer.
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    },
    
    // detects html tag
    tagsRe: /<[^>]*>/gm,
    
    // DEL ASCII code
    tagsProtect: '\x0f',
    
    /**
     * Finds all strings that matches the searched value in each grid cells.
     * @private
     */
     onTextFieldChange: function(field, val) {
         var me = this,
             count = 0,
             view = me.view,
             cellSelector = view.cellSelector,
             innerSelector = view.innerSelector,
             columns = me.visibleColumnManager.getColumns();

         view.refresh();

         me.searchValue = val;
         me.matches = [];
         me.currentIndex = null;

         if (me.searchValue !== null) {
             me.searchRegExp = new RegExp(val, 'g' + (me.caseSensitive ? '' : 'i'));

             me.store.each(function(record, idx) {
                var node = view.getNode(record);

                if (node) {
                    Ext.Array.forEach(columns, function(column) {
                    	
                        var cell = Ext.fly(node).down(column.getCellInnerSelector(), true),
                            matches, cellHTML,
                            seen;

                        if (cell && column.isXType('widgetcolumn')==false) {
                            matches = cell.innerHTML.match(me.tagsRe);
                            cellHTML = cell.innerHTML.replace(me.tagsRe, me.tagsProtect);

                            // populate indexes array, set currentIndex, and replace wrap matched string in a span
                            cellHTML = cellHTML.replace(me.searchRegExp, function(m) {
                                ++count;
                                if (!seen) {
                                    me.matches.push({
                                        record: record,
                                        column: column
                                    });
                                    seen = true;
                                }
                                return '<span class="' + me.matchCls + '">' + m + '</span>';
                            }, me);
                            // restore protected tags
                            Ext.each(matches, function(match) {
                                cellHTML = cellHTML.replace(me.tagsProtect, match);
                            });
                            // update cell html
                            cell.innerHTML = cellHTML;
                        }
                    });
                }
             }, me);

             // results found
             if (count) {
                me.currentIndex = 0;
                me.gotoCurrent();
             }
         }

         // no results found
         if (me.currentIndex === null) {
             me.getSelectionModel().deselectAll();
         }
         field.focus();
     },

    privates: {
        gotoCurrent: function() {
            var pos = this.matches[this.currentIndex];
            this.getNavigationModel().setPosition(pos.record, pos.column);
            this.getSelectionModel().select(pos.record);
        }
    }
});

Ext.define('Voyant.widget.ProgressMonitor', {
	extend: "Ext.Base",
	mixins: ['Voyant.util.Localization'],
	msgbox: undefined,
	statics: {
		i18n: {
		}
	},
	config: {
		progress: undefined,
		scope: undefined,
		success: undefined,
		failure: undefined,
		args: undefined,
		tool: undefined,
		delay: 1000,
		maxMillisSinceStart: undefined
	},
	constructor: function(config) {
		config = config || {};
		this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
		if (!config || !config.progress || !config.progress.id) {
			return Voyant.application.showError(this.localize("noProgress"))
		}
		this.initConfig(config);
		this.callParent(arguments);
		this.update();
	},

	update: function() {
		var progress = this.getProgress(), scope = this.getScope();
		var msg = scope.localize ? scope.localize(progress.code) : this.localize(progress.code);
		if (msg=="["+progress.code+"]") {msg=progress.message}
		msg+=" ("+(parseInt(progress.completion*100))+"%)";
		var text = this.localize(progress.status.toLowerCase());
		if (!this.msgbox || this.msgbox.msg.html!=msg || !this.msgbox.progressBar || this.msgbox.progressBar.getText()!=text) {
			this.msgbox = Ext.Msg.wait(msg, this.localize("progress"), {
				text: text
			});
		}
		if (progress.status=="LAUNCH" || progress.status=="RUNNING") {
			var me = this;
			Ext.defer(function() {
				Ext.Ajax.request({
				     url: Voyant.application.getTromboneUrl(),
				     params: {
				    	 	tool: "progress.ProgressMonitor",
				    	 	id: progress.id,
				    	 	maxMillisSinceStart: me.getMaxMillisSinceStart()
				     }
				 }).then(function(response, opt) {
					 var data = Ext.decode(response.responseText);
					 if (data && data.progress.progress) {
						 me.setProgress(data.progress.progress);
						 me.update();
					 } else {
						 me.finish(false, me.localize("badProgress"))
					 }
				 }, function(response, opt) {
					 me.finish(false, response);
				 });
			}, this.getDelay(), this)
		} else {
			this.finish(progress.status=="FINISHED", msg);
		}
		if (this.getDelay()<5000) {this.setDelay(this.getDelay()+500)} // longer delay, up to 5 secs
	},
	
	finish: function(success, response) {
		var callback = success ? this.getSuccess() : this.getFailure();
		var args = this.getArgs(), progress = this.getProgress(), scope = this.getScope();
		this.close();
		if (callback && callback.apply) {
			callback.apply(scope, [success ? args : response || progress]);
		} else {
			Voyant.application.showError(response);
		}
	},
	
	close: function() {
		if (this.msgbox) {
			this.msgbox.close();
		}
		this.destroy();
	}

})
Ext.define('Voyant.widget.VoyantTableTransform', {
	extend: 'Ext.panel.Panel',
    mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.notebook.util.Embed'],
	alias: 'widget.voyanttabletransform',
    statics: {
    	i18n: {},
		api: {
			tableHtml: undefined,
			tableJson: undefined,
			width: undefined,
			api: undefined
		}
    },
    html: '',
    config: {
    	hiddenColumns: undefined
    },
	constructor: function(config) {
    	config = config || {};
		var me = this;
        me.callParent(arguments);
	},
	initComponent: function(config) {
    	var me = this, config = config || {};
    	me.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	if (this.config.api && this.config.api.tableJson) {
    		this.setApiParam("tableJson", this.config.api.tableJson);
    	}
		me.on('afterrender', function() {
	    	me.buildFromParams();
			var table = this.getTargetEl().down('table');
			if (table) {
				var parent = table.parent();
				var grid = new Ext.ux.grid.TransformGrid(table, {
					width: this.getApiParam('width') || parent.getWidth(),
					height: this.getApiParam('height') || 20+(table.query('tr').length*24) // based on grid heights in crisp
				});
				grid.render(parent);
				if (this.getHiddenColumns()) {
					var hides = {}; // map for speed
					Ext.Array.from(this.getHiddenColumns()).forEach(function(header) {hides[header]=true})
					grid.getColumns().forEach(function(column) {
						if (column.text in hides) {column.hide()}
					});
					Ext.defer(function() {
						grid.setWidth(grid.getEl().dom.parentNode.offsetWidth); // resize
					},10)
				}
			}
		}, me);
		
    	me.callParent(arguments);
	},
	
	buildFromParams: function() {
		var me = this, tableHtml = this.getApiParam('tableHtml'), tableJson = this.getApiParam('tableJson');
		if (tableHtml) {
			this.setHtml(tableHtml);
		} else if (tableJson) {
			var html = "<table><thead><tr>", json = JSON.parse(tableJson);
			
			if (json.headers) {
				json.headers.forEach(function(header) {
					html+="<th>"+header+"</th>"
				});
			} else {
				json.rows[0].forEach(function(cell, i) {
					html+="<th>"+(i+1)+"</th>";
				})
			}
			html+="</tr></thead><tbody>";
			json.rows.forEach(function(row) {
				html+="<tr>";
				row.forEach(function(cell) {
					html+="<td>"+cell+"</td>"
				})
				html+="</tr>";
			})
			html+="</tbody></table>";
			this.setHtml(html);
			if (json.config && json.config.hidden) {this.setHiddenColumns(json.config.hidden)}
		}
		
	}

})



/**
 * A Grid which creates itself from an existing HTML table element.
 */
Ext.define('Ext.ux.grid.TransformGrid', {
    extend: 'Ext.grid.Panel',

    /**
     * Creates the grid from HTML table element.
     * @param {String/HTMLElement/Ext.Element} table The table element from which this grid will be created -
     * The table MUST have some type of size defined for the grid to fill. The container will be
     * automatically set to position relative if it isn't already.
     * @param {Object} [config] A config object that sets properties on this grid and has two additional (optional)
     * properties: fields and columns which allow for customizing data fields and columns for this grid.
     */
    constructor: function(table, config) {
        config = Ext.apply({}, config);
        this.table = Ext.get(table);

        var configFields = config.fields || [],
            configColumns = config.columns || [],
            fields = [],
            cols = [],
            headers = table.query("thead th"),
            i = 0,
            len = headers.length,
            data = table.dom,
            width,
            height,
            store,
            col,
            text,
            name;

        for (; i < len; ++i) {
            col = headers[i];

            text = col.innerHTML;
            name = 'tcol-' + i;

            fields.push(Ext.applyIf(configFields[i] || {}, {
                name: name,
                mapping: 'td:nth(' + (i + 1) + ')/@innerHTML'
            }));

            cols.push(Ext.applyIf(configColumns[i] || {}, {
                text: text,
                dataIndex: name,
                //width: col.offsetWidth,
                flex: 1,
                tooltip: col.title,
                sortable: true
            }));
        }

        if (config.width) {
            width = config.width;
        } else {
            width = table.getWidth() + 1;
        }

        if (config.height) {
            height = config.height;
        }

        Ext.applyIf(config, {
            store: {
                data: data,
                fields: fields,
                proxy: {
                    type: 'memory',
                    reader: {
                        record: 'tbody tr',
                        type: 'xml'
                    }
                }
            },
            columns: cols,
            width: width,
            height: height
        });
        this.callParent([config]);
        
        if (config.remove !== false) {
            // Don't use table.remove() as that destroys the row/cell data in the table in
            // IE6-7 so it cannot be read by the data reader.
            data.parentNode.removeChild(data);
        }
    },

    doDestroy: function() {
        this.table.remove();
        this.tabl = null;
        this.callParent();
    }
});

Ext.define('Voyant.widget.CategoriesOption', {
	extend: 'Ext.container.Container',
	mixins: ['Voyant.util.Localization'],
	alias: 'widget.categoriesoption',
	statics: {
		i18n: {
		}
	},
	config: {
		builderWin: undefined
	},
	initComponent: function() {
	    // TODO set value of option to current categories id if it exists
		var value = this.up('window').panel.getApiParam('categories');
    	var data = value ? [{name: 'categories-'+value, value: value}] : [];
		
		Ext.apply(this, {
    		layout: 'hbox',
    		items: [{
    			xtype: 'combo',
    			queryMode: 'local',
    			triggerAction: 'all',
    			fieldLabel: this.localize('categories'),
    			labelAlign: 'right',
    			displayField: 'name',
    			valueField: 'value',
    			store: {
    				fields: ['name', 'value'],
    				data: data
    			},
    			name: 'category'
    		}, {width: 10}, {xtype: 'tbspacer'}, {
    			xtype: 'button',
    			text: this.localize('edit'),
    			ui: 'default-toolbar',
    			handler: function() {
    				if (this.getBuilderWin() === undefined) {
    					var panel = this.up('window').panel;
    					var win = Ext.create('Voyant.widget.CategoriesBuilder', {
    						panel: panel,
    						height: panel.getApplication().getViewport().getHeight()*0.75,
    						width: panel.getApplication().getViewport().getWidth()*0.75
    					});
    					win.on('close', function(win) {
    						var id = win.getCategoriesId();
    						if (id !== undefined) {
	    						var combo = this.down('combo');
								var name = 'categories-'+id;
								combo.getStore().add({name: name, value: id});
								combo.setValue(id);
								
								this.up('window').panel.setApiParam('categories', id);
    						}
    					}, this);
    					this.setBuilderWin(win);
    				}
    				
    				var categoriesId = this.down('combo').getValue();
    				this.getBuilderWin().setCategoriesId(categoriesId);
					this.getBuilderWin().show();
    			},
    			scope: this
    		}]
    	});
		
		this.callParent(arguments);
	}
});

Ext.define('Voyant.widget.CategoriesBuilder', {
    extend: 'Ext.window.Window',
    requires: ['Voyant.widget.FontFamilyOption'],
    mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.util.CategoriesManager'],
    alias: 'widget.categoriesbuilder',
    statics: {
    	i18n: {
    		title: 'Categories Builder',
    		terms: 'Terms',
    		term: 'Term',
    		rawFreq: 'Count',
    		relativeFreq: 'Relative',
    		categories: 'Categories',
    		addCategory: 'Add Category',
    		removeCategory: 'Remove Category',
    		removeTerms: 'Remove Selected Terms',
    		categoryName: 'Category Name',
    		add: 'Add',
    		cancel: 'Cancel',
    		exists: 'Category already exists',
    		confirmRemove: 'Are you sure you want to remove the category?',
    		save: 'Save',
    		cancel: 'Cancel',
    		features: 'Features',
    		category: 'Category',
    		
    		color: 'Color',
    		font: 'Font',
    		orientation: 'Orientation'
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined
    	},
    	features: {
        	color: {
        		xtype: 'colorfield',
        		format: '#hex6'
//        		,listeners: {
//        			render: function(field) {
//        				field.on('change', function(field, color) {
//        					field.inputEl.setStyle('background-color', color);
//        				});
//        			}
//        		}
        	},
        	font: {
        		xtype: 'combobox',
        		queryMode: 'local',
        		displayField: 'name',
        		valueField: 'value',
        		store: {
        			fields: ['name', 'value'],
        			data: Voyant.widget.FontFamilyOption.fonts
        		}
        	},
        	orientation: {
        		xtype: 'combobox',
        		queryMode: 'local',
        		displayField: 'name',
        		valueField: 'value',
        		store: {
        			fields: ['name', 'value'],
        			data: [{name: 'Horizontal', value: 0}, {name: 'Vertical', value: 90}]
        		}
        	}
        }
    },
    config: {
    	corpus: undefined,
    	categoriesManager: undefined,
    	builderWin: undefined,
    	addCategoryWin: undefined,
    	categoriesId: undefined
    },
    
    // window defaults
    closeAction: 'hide',
    modal: true,
	height: 250,
	width: 500,

    constructor: function(config) {
    	config = config || {};
    	
    	if (config.panel) {
    		this.panel = config.panel;
    		this.app = this.panel.getApplication();
    	} else {
    		if (window.console) {
    			console.warn('can\'t find panel!');
    		}
    	}
    	
    	this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	this.callParent(arguments);
    },
    
    initComponent: function() {
    	Ext.apply(this, {
    		header: false,
    		layout: 'fit',
    		onEsc: Ext.emptyFn,
    		items: {
	    		xtype: 'tabpanel',
	    		title: this.localize('title'),
	    		tabBarHeaderPosition: 1,
	    		items: [{
		    		layout: 'border',
		    		title: this.localize('categories'),
		    		items: [{
		    			title: this.localize('terms'),
		    			split: true,
		    			width: 250,
		    			region: 'west',
		    			layout: 'fit',
		    			items: {
		    				itemId: 'terms',
		    				xtype: 'grid',
		    				store: Ext.create('Voyant.data.store.CorpusTermsBuffered', {
		    		        	parentPanel: this
		    		        }),
		    				viewConfig: {
		    					plugins: {
		    						ptype: 'gridviewdragdrop',
		    						ddGroup: 'terms',
		    						copy: true,
		    						enableDrop: false, // can't drop on grid with buffered store
		    						dragZone: {
		    							getDragText: function() {
		    								var text = '';
		    								this.dragData.records.forEach(function(d) {
		    									text += d.get('term')+', ';
		    								});
		    								text = text.substr(0, text.length-2);
		    								if (text.length > 20) {
		    									text = text.substr(0, 20) + '...';
		    								}
		    								return text;
		    							}
		    						}
		    					}
		    				},
		    				selModel: {
		    	    			mode: 'MULTI'
		    	    		},
		    				columns: [{
				    			text: this.localize('term'),
				        		dataIndex: 'term',
				        		flex: 1,
				                sortable: true
				            },{
				            	text: this.localize('rawFreq'),
				            	dataIndex: 'rawFreq',
				                width: 'autoSize',
				            	sortable: true
				            },{
				            	text: this.localize('relativeFreq'),
				            	dataIndex: 'relativeFreq',
				            	renderer: function(val) {
				            		return Ext.util.Format.number(val*1000000, "0,000");
				            	},
				                width: 'autoSize',
				                hidden: true,
				            	sortable: true
				            }],
				            dockedItems: [{
				                dock: 'bottom',
				                xtype: 'toolbar',
				                overflowHandler: 'scroller',
				                items: [{
				                    xtype: 'querysearchfield'
				                }]
				            }],
				            listeners: {
				            	query: function(src, query) {
				            		this.setApiParam('query', query);
				            		var store = this.queryById('terms').getStore();
				            		store.removeAll();
				            		store.load();
				            	},
				            	scope: this
				            }
		    			}
		    		},{
		    			title: this.localize('categories'),
		    			itemId: 'categories',
		    			region: 'center',
		    			xtype: 'panel',
		    			layout: {
		    				type: 'hbox',
		    				align: 'stretch'
		    			},
		    			scrollable: 'x',
		    			dockedItems: [{
		                    dock: 'bottom',
		                    xtype: 'toolbar',
		                    overflowHandler: 'scroller',
		                    items: [{
		                    	text: this.localize('addCategory'),
		                    	handler: function() {
		                    		this.getAddCategoryWin().show();
		                    	},
		                    	scope: this
		                    },{
		                    	text: this.localize('removeTerms'),
		                    	handler: function() {
		                    		this.queryById('categories').query('grid').forEach(function(grid) {
		                    			grid.getStore().remove(grid.getSelection());
		                    		}, this);
		                    	},
		                    	scope: this
		                    }]
		    			}],
		    			items: []
		    		}]
	    		},{
	    			layout: 'fit',
	    			itemId: 'features',
	    			title: this.localize('features'),
	    			xtype: 'grid',
	    			scrollable: 'y',
	    			store: Ext.create('Ext.data.JsonStore', {
		    			fields: ['category']
		    		}),
	    			columns: [{
	    				text: this.localize('category'),
	    				dataIndex: 'category',
	    				sortable: false,
	    				hideable: false,
	    				flex: 1
	    			}]
	    		}]
    		},
    		buttons: [{
				text: this.localize('cancel'),
				handler: function(btn) {
					this.setCategoriesId(undefined);
					btn.up('window').close();
				},
				scope: this
			},{
				text: this.localize('save'),
				handler: function(btn) {
					this.app.setColorTermAssociations();
					this.app.saveCategoryData().then(function(id) {
						this.setCategoriesId(id);
						btn.up('window').close();
					}, function() {
						this.setCategoriesId(undefined);
						btn.up('window').close();
					}, null, this);
				},
				scope: this
			}],
			listeners: {
				show: function() {
					if (this.getCategoriesId()) {
		    			this.app.loadCategoryData(this.getCategoriesId()).then(function(data) {
							this.buildCategories();
							this.buildFeatures();
						}, null, null, this);
	    			} else {
	    				this.buildCategories();
	    				this.buildFeatures();
	    			}
					
					this.down('tabpanel').setActiveTab(0);
				},
				afterrender: function(builder) {
					builder.on('loadedCorpus', function(src, corpus) {
		    			this.setCorpus(corpus);
			    		var terms = this.queryById('terms');
			    		terms.getStore().load();
		    		}, builder);
		    		
					this.panel.on('loadedCorpus', function(src, corpus) {
	    				builder.fireEvent('loadedCorpus', src, corpus);
	    			}, builder);
	    			if (this.panel.getCorpus && this.panel.getCorpus()) {builder.fireEvent('loadedCorpus', builder, this.panel.getCorpus());}
	    			else if (this.panel.getStore && this.panel.getStore() && this.panel.getStore().getCorpus && this.panel.getStore().getCorpus()) {
	    				builder.fireEvent('loadedCorpus', builder, this.panel.getStore().getCorpus());
	    			}
				},
				scope: this
			}
    	});
    	
    	this.setAddCategoryWin(Ext.create('Ext.window.Window', {
    		title: this.localize('addCategory'),
    		modal: true,
    		closeAction: 'hide',
    		layout: 'fit',
    		items: {
    			xtype: 'form',
    			width: 300,
    			defaults: {
    				labelAlign: 'right'
    			},
	    		items: [{
	    			xtype: 'textfield',
	    			fieldLabel: this.localize('categoryName'),
	    			name: 'categoryName',
	    			allowBlank: false,
	    			validator: function(val) {
	    				return this.app.getCategoryTerms(val) === undefined ? true : this.localize('exists');
	    			}.bind(this),
	    			enableKeyEvents: true,
	    			listeners: {
	    				keypress: function(field, evt) {
	    					if (evt.getKey() === Ext.event.Event.ENTER) {
	    						field.up('form').queryById('addCategoryButton').click();
	    					}
	    				},
	    				scope: this
	    			}
	    		}],
	    		buttons: [{
	    			text: this.localize('cancel'),
	    			handler: function(btn) {
	    				btn.up('window').close();
	    			}
	    		},{
	    			itemId: 'addCategoryButton',
	    			text: this.localize('add'),
	    			handler: function(btn) {
	    				var form = btn.up('form');
	    				if (form.isValid()) {
	    					var name = form.getValues()['categoryName'];
	    					this.addCategory(name);
	    					btn.up('window').close();
	    				}
	    			},
	    			scope: this
	    		}]
    		},
    		listeners: {
    			show: function(win) {
    				var form = win.down('form').getForm();
    				form.reset();
					form.clearInvalid();
    			}
    		}
    	}));
    	
    	this.callParent(arguments);
    },
    
    addCategory: function(name) {
    	this.app.addCategory(name);
    	
    	this.queryById('features').getStore().add({category: name});

    	var termsData = [];
    	var terms = this.app.getCategoryTerms(name);
    	if (terms !== undefined) {
    		for (var i = 0; i < terms.length; i++) {
    			termsData.push({term: terms[i]});
    		}
    	}
    	
    	var grid = this.queryById('categories').add({
    		xtype: 'grid',
    		category: name,
    		title: name,
//    		header: {
//    			items: [{
//    				xtype: 'colorbutton',
//    				format: '#hex6',
//    				value: color,
//    				width: 30,
//    				height: 15,
//    				listeners: {
//    					change: function(btn, color, pcolor) {
//    						this.app.setCategoryFeature(name, 'color', color);
//    					},
//    					afterrender: function(btn) {
//    						var popup = btn.getPopup();
//    						popup.listeners = {
//    							focusleave: function(sel, evt) {
//    								sel.close(); // fix for conflict between selector and parent modal window, when you click outside of the selector
//    							}
//    						};
//    					},
//    					scope: this
//    				}
//    			}]
//    		},
    		frame: true,
    		width: 150,
    		margin: '10 0 10 10',
    		layout: 'fit',
    		tools: [{
    			type: 'close',
    			tooltip: this.localize('removeCategory'),
    			callback: function(panel) {
    				Ext.Msg.confirm(this.localize('removeCategory'), this.localize('confirmRemove'), function(btn) {
    					if (btn === 'yes') {
    						this.removeCategory(name);
    					}
    				}, this);
    			},
    			scope: this
    		}],
    		
    		store: Ext.create('Ext.data.JsonStore', {
    			data: termsData,
    			fields: ['term']
    		}),
    		viewConfig: {
	    		plugins: {
	    			ptype: 'gridviewdragdrop',
					ddGroup: 'terms',
					dragZone: {
						getDragText: function() {
							var text = '';
							this.dragData.records.forEach(function(d) {
								text += d.get('term')+', ';
							});
							return text.substr(0, text.length-2);
						}
					}
	    		}
    		},
    		selModel: {
    			mode: 'MULTI'
    		},
    		columns: [{
        		dataIndex: 'term',
        		flex: 1,
                sortable: true
            }],
    		listeners: {
    			beforedrop: function(node, data) {
    				// remove duplicates
    				var app = this.up('categoriesbuilder').app;
    				for (var i = data.records.length-1; i >= 0; i--) {
    					var term = data.records[i].get('term');
    					if (app.getCategoryForTerm(term) !== undefined) {
    						data.records.splice(i, 1);
    					}
    				}
    			},
    			drop: function(node, data) {
    				data.view.getSelectionModel().deselectAll();
    				this.getSelectionModel().deselectAll();
    				
    				var app = this.up('categoriesbuilder').app;
    				var terms = [];
    				for (var i = 0; i < data.records.length; i++) {
    					var term = data.records[i].get('term');
    					if (app.getCategoryForTerm(term) === undefined) {
    						terms.push(term);
    					}
    				}
    				app.addTerms(name, terms);
    				
    				var source = data.view.up('grid');
    				if (source.category) {
    					app.removeTerms(source.category, terms);
    				}
    			}
    		}
    	});
    	
    	var titleEditor = new Ext.Editor({
    		updateEl: true,
    		alignment: 'l-l',
    		autoSize: {
    			width: 'boundEl'
    		},
    		field: {
    			xtype: 'textfield',
    			allowBlank: false,
    			validator: function(val) {
    				return this.app.getCategoryTerms(val) === undefined || val ===  grid.getTitle() ? true : this.localize('exists');
    			}.bind(this)
    		},
    		listeners: {
    			complete: function(ed, newvalue, oldvalue) {
    				this.app.renameCategory(oldvalue, newvalue);
    				this.buildFeatures();
    			},
    			scope: this
    		}
    	});
    	
    	grid.header.getTitle().textEl.on('dblclick', function(e, t) {
    		titleEditor.startEdit(t);
    	});
    },
    
    removeCategory: function(name) {
    	var categoriesParent = this.queryById('categories');
    	var panel = categoriesParent.queryBy(function(cmp) {
    		if (cmp.category && cmp.category == name) {
    			return true;
    		}
    		return false;
    	});
    	categoriesParent.remove(panel[0]);
    	
    	var featuresStore = this.queryById('features').getStore();
    	featuresStore.removeAt(featuresStore.findExact('category', name));
    	
		this.app.removeCategory(name);
    },
    
    addFeature: function(name) {
		this.app.addFeature(name);
		this.buildFeatures();
    },
    
    buildFeatures: function() {
    	this.queryById('features').getStore().removeAll();
    	
    	var fields = ['category'];
		var columns = [{
			sortable: false,
			text: this.localize('category'),
			dataIndex: 'category',
			flex: 1
		}];
		var data = [];
		
		for (var category in this.app.getCategories()) {
			data.push({category: category});
		}
		
		var features = this.app.getFeatures();
		var featuresConfigs = Ext.ClassManager.getClass(this).features;
		
		for (var feature in features) {
			fields.push(feature);
			
			var featureConfig = featuresConfigs[feature];
			var widgetConfig = Ext.applyIf({
				feature: feature,
				listeners: {
					change: function(cmp, newvalue) {
						if (cmp.rendered) {
							var rowIndex = cmp.up('gridview').indexOf(cmp.el.up('table'));
							var record = cmp.up('grid').getStore().getAt(rowIndex);
							if (record) {
								var category = record.get('category');
								this.app.setCategoryFeature(category, cmp.feature, newvalue);
							} else {
								if (window.console) {
									console.warn('no record for', rowIndex, cmp);
								}
							}
						}
					},
					scope: this
				}
			}, featureConfig);
			if (featureConfig.listeners) {
				Ext.applyIf(widgetConfig.listeners, featureConfig.listeners);
			}
			
			
			columns.push({
				sortable: false,
				hideable: false,
				text: this.localize(feature),
				dataIndex: feature,
				flex: 0.5,
				xtype: 'widgetcolumn',
				widget: widgetConfig
			});
			
			for (var category in this.app.getCategories()) {
				var value = this.app.getCategoryFeature(category, feature);
				for (var i = 0; i < data.length; i++) {
					if (data[i].category == category) {
						data[i][feature] = value;
						break;
					}
				}
			}
		}
		
		var store = Ext.create('Ext.data.JsonStore', {
			fields: fields,
			data: data
		});
		this.queryById('features').reconfigure(store, columns);
    },
    
    buildCategories: function() {
    	this.queryById('categories').removeAll();
    	
    	var cats = this.app.getCategories();
    	for (var key in cats) {
    		this.addCategory(key);
    	}
    }
});
Ext.define('Voyant.widget.VoyantNetworkGraph', {
    extend: 'Ext.panel.Panel',
    mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.notebook.util.Embed'],
    embeddable: ['Voyant.widget.VoyantNetworkGraph'],
    alias: 'widget.voyantnetworkgraph',
    statics: {
        i18n: {
        },
        api: {
            jsonData: undefined,
            docId: undefined,
            docIndex: undefined,
            json: undefined,
            api: undefined
        }
    },
    config: {
        vis: undefined, // svg > g element
        visLayout: undefined, // d3 layout algorithm
        
        // backing data. don't set through config, use config.nodes & config.edges
        nodeData: undefined,
        edgeData: undefined,
        
        nodeSelection: undefined, // d3 selection for nodes
        edgeSelection: undefined, // d3 selection for edges
        
        currentNode: undefined,
        currentEdge: undefined,
        
        zoom: undefined, // d3 zoom
        zoomExtent: [0.25, 8],
        
        fixOnDrag: true, // fix node when dragged
        
        nodeScaling: {
        	minSize: 8,
        	maxSize: 36,
        	scalingFunction: undefined
        },
        edgeScaling: {
        	minSize: 1,
        	maxSize: 10,
        	scalingFunction: undefined
        },
        
        graphStyle: {
    		node: {
    			normal: {
    				fill: '#c6dbef',
    				fillOpacity: 1,
    				stroke: '#6baed6',
    				strokeOpacity: 1,
    				strokeWidth: 1
    			},
    			highlight: {
    				fill: '#9ecae1',
    				fillOpacity: 1,
    				stroke: '#3182bd',
    				strokeOpacity: 1,
    				strokeWidth: 3
    			}
    		},
    		edge: {
    			normal: {
    				stroke: '#000000',
    				strokeOpacity: 0.25,
    				strokeWidth: 1
    			},
    			highlight: {
    				stroke: '#000000',
    				strokeOpacity: 0.5,
    				strokeWidth: 3
    			}
    		}
    	},
    	
    	graphPhysics: {
    		damping: 0.4, // 0 = no damping, 1 = full damping
    		centralGravity: 0.1, // 0 = no grav, 1 = high grav
    		nodeGravity: -50,  // negative = repel, positive = attract
			springLength: 100,
			springStrength: 0.25, // 0 = not strong, >1 = probably too strong
			collisionScale: 1.25 // 1 = default, 0 = no collision 
    	}
    },
    constructor: function(config) {
        config = config || {};
        
        this.setNodeData([]);
        this.setEdgeData([]);
        
        this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
        this.callParent(arguments);
        
        var json = {};
        if (this.getApiParam('jsonData')) {
            json = Ext.decode(this.getApiParam('jsonData'));
        } else if (this.getApiParam('json')) {
        	json = this.getApiParam('json');
        } else if (config.json) {
        	json = config.json;
        } else if (config.edges) {
        	json.edges = config.edges;
        	if (config.nodes) {
        		json.nodes = config.nodes;
        	}
        } else if (config && config.jsonData) {
        	json = JSON.parse(config.jsonData);
        }
        this.loadJson(json);
    },
    initComponent: function(config) {
        this.on('boxready', function(src, corpus) {
            this.initGraph();
            this.refreshGraph();
        }, this);
        
        this.on('resize', function(panel, width, height) {
            var vis = this.body.down('svg');
            if (vis) {
                var el = this.body;
                var elHeight = el.getHeight();
                var elWidth = el.getWidth();
                vis.dom.setAttribute('width', elWidth);
                vis.dom.setAttribute('height', elHeight);
                this.getVisLayout()
                    .force('x', d3.forceX(elWidth/2))
	    			.force('y', d3.forceY(elHeight/2));
                
                if (this.getVisLayout().alpha() < 0.075) {
                	this.getVisLayout().alpha(-1); // trigger end/zoomToFit
                }
            }
        }, this);
        
        this.callParent(arguments);
    },
    
    processJson: function(json) {
    	if (!json || !json.edges) {
            if (json && json.links) {
                json.edges = json.links;
                delete json.links;
            }
            if (!json || !json.edges) {
                json = json || {};
                json.edges = [];
            }
        }
    	if (!json.nodes) {
    		json.nodes = [];
    	}
        if (json.nodes.length === 0) {
            var wordFreq = {};
            json.edges.forEach(function(edge) {
                ['source', 'target'].forEach(function(loc) {
                	var term = edge[loc];
                    if (term in wordFreq == false) {
                        wordFreq[term] = 1;
                        json.nodes.push({term: term});
                    } else {
                        wordFreq[term]++;
                    }
                    edge.value = 1;
                });
            }, this);
            json.nodes.forEach(function(node) {
            	var val = wordFreq[node.term] === undefined ? 1 : wordFreq[node.term];
                Ext.applyIf(node, {value: val});
            });
        } else {
        	json.nodes.forEach(function(node) {
        		Ext.applyIf(node, {value: 1});
        	});
        }
        
        return json;
    },
    
    loadJson: function(json) {
    	this.processJson(json);
    	
    	var existingTerms = {};
		this.getNodeData().forEach(function(node) {
			existingTerms[node.term] = true;
		}, this);
		
    	var newNodes = [];
    	var newEdges = [];
    	
    	json.nodes.forEach(function(node) {
            if (existingTerms[node.term] === undefined) {
            	node.id = this.idGet(node.term);
            	newNodes.push(node);
            }
        }, this);
        json.edges.forEach(function(newedge) {
            var sourceId = this.idGet(newedge.source);
            var targetId = this.idGet(newedge.target);
            var edges = this.getEdgeData();
            var exists = false;
            for (var i = 0; i < edges.length; i++) {
            	var edge = edges[i];
            	if ((edge.source.id == sourceId && edge.target.id == targetId) || (edge.target.id == sourceId && edge.source.id == targetId)) {
            		exists = true;
            		break;
            	}
            }
            if (!exists) {
            	newedge.source = sourceId;
            	newedge.target = targetId;
            	newedge.id = sourceId+'-'+targetId;
	            newEdges.push(newedge);
            }
        }, this);
        
        this.setNodeData(this.getNodeData().concat(newNodes));
        this.setEdgeData(this.getEdgeData().concat(newEdges));
        
        this.refreshGraph();
    },
    
    // get a DOM appropriate id
    idGet: function(term) {
    	return term.replace(/\W/g, '_');
    },
    
    updateDataForNode: function(nodeId, dataObj) {
    	var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				Ext.apply(data[i], dataObj);
				break;
			}
		}
    },
    
    updateDataForEdge: function(edgeId, dataObj) {
    	var data = this.getEdgeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === edgeId) {
				Ext.apply(data[i], dataObj);
				break;
			}
		}
    },
    
    addNode: function(dataObj) {
    	if (Ext.isString(dataObj)) {
    		dataObj = {term: dataObj};
    	}
    	if (dataObj.term) {
    		this.loadJson({nodes: [dataObj]});
    	}
    },
    
    removeNode: function(nodeId, removeOrphans) {
    	var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				data.splice(i, 1);
				break;
			}
		}
		
		var potentialOrphans = {};
		data = this.getEdgeData();
		for (var i = data.length-1; i >= 0; i--) {
			var match = false;
			if (data[i].source.id === nodeId) {
				match = true;
				potentialOrphans[data[i].target.id] = true;
			}
			if (data[i].target.id === nodeId) {
				match = true;
				potentialOrphans[data[i].source.id] = true;
			}
			if (match) {
				data.splice(i, 1);
			}
		}
		
		if (removeOrphans) {
			for (var i = 0; i < data.length; i++) {
				if (potentialOrphans[data[i].source.id]) {
					delete potentialOrphans[data[i].source.id];
				}
				if (potentialOrphans[data[i].target.id]) {
					delete potentialOrphans[data[i].target.id];
				}
			}
			for (var orphanId in potentialOrphans) {
				this.removeNode(orphanId, true);
			}
		}
		
		this.refreshGraph();
    },
    
    addEdge: function(dataObj) {
    	if (Ext.isObject(dataObj) && dataObj.source && dataObj.target) {
    		this.loadJson({edges: [dataObj]});
    	}
    },
    
    removeEdge: function(edgeId, removeOrphans) {
    	var data = this.getEdgeData();
    	for (var i = data.length-1; i >= 0; i--) {
			if (data[i].id === edgeId) {
				data.splice(i, 1);
			}
		}
		
		if (removeOrphans) {
			var potentialOrphans = {};
			data = this.getNodeData();
			for (var i = 0; i < data.length; i++) {
				potentialOrphans[data[i].id] = true;
			}
			data = this.getEdgeData();
			for (var i = 0; i < data.length; i++) {
				if (potentialOrphans[data[i].source.id]) {
					delete potentialOrphans[data[i].source.id];
				}
				if (potentialOrphans[data[i].target.id]) {
					delete potentialOrphans[data[i].target.id];
				}
			}
			for (var orphanId in potentialOrphans) {
				this.removeNode(orphanId, true);
			}
			
		}
		
		this.refreshGraph();
    },
    
    initGraph: function() {
        var el = this.getLayout().getRenderTarget();
        el.update('');
        var width = el.getWidth();
        var height = el.getHeight();
        
        var physics = this.getGraphPhysics();
        this.setVisLayout(d3.forceSimulation()
        	.velocityDecay(physics.damping)
    		.force('x', d3.forceX(width/2).strength(physics.centralGravity))
    		.force('y', d3.forceY(height/2).strength(physics.centralGravity))
            .force('link', d3.forceLink().id(function(d) { return d.id; }).distance(physics.springLength).strength(physics.springStrength))
            .force('charge', d3.forceManyBody().strength(physics.nodeGravity))
            .force('collide', d3.forceCollide().radius(function(d) { return Math.sqrt(d.bbox.width * d.bbox.height)*physics.collisionScale; }))
            .on('tick', function() {
            	 this.getEdgeSelection()
	                .attr('x1', function(d) { return d.source.x; })
	                .attr('y1', function(d) { return d.source.y; })
	                .attr('x2', function(d) { return d.target.x; })
	                .attr('y2', function(d) { return d.target.y; });
	    
            	 this.getNodeSelection()
            	 	.attr('transform', function(d) {
            	 		var x = d.x - d.bbox.width*0.5;
            	 		var y = d.y - d.bbox.height*0.5;
            	 		return 'translate('+x+','+y+')';
        	 		});
            	 
            	 if (this.getVisLayout().alpha() < 0.075) {
 	    			this.getVisLayout().alpha(-1); // trigger end event
 	    		}
	        }.bind(this))
	        .on('end', function() {
	    		this.zoomToFit();
	    	}.bind(this))
        );
        
        var svg = d3.select(el.dom).append('svg').attr('width', width).attr('height', height);
        var g = svg.append('g');
        
        var zoom = d3.zoom()
		.scaleExtent(this.getZoomExtent())
		.on('zoom', function() {
			g.attr('transform', d3.event.transform);
		});
		this.setZoom(zoom);
		svg.call(zoom);
        
        this.setEdgeSelection(g.append('g').attr('class', 'edges').selectAll('.edge'));
        this.setNodeSelection(g.append('g').attr('class', 'nodes').selectAll('.node'));
        this.setVis(g);
    },
    
    resetGraph: function() {
	    this.setNodeData([]);
		this.setEdgeData([]);
		this.refreshGraph();
    },
    
    refreshGraph: function() {
    	if (this.getVisLayout() === undefined) return;
    	
        var edgeData = this.getEdgeData();
        var nodeData = this.getNodeData();
        
        var nodeExtent = d3.extent(nodeData, function(d) { return d.value; });
        var nodeSum = d3.sum(nodeData, function(d) { return d.value; });
        var edgeExtent = d3.extent(edgeData, function(d) { return d.value; });
        var edgeSum = d3.sum(edgeData, function(d) { return d.value; });

        var edgeScaling = this.getEdgeScaling();
        if (edgeScaling.scalingFunction === undefined) {
        	edgeScaling.scalingFunction = d3.scaleLinear().domain(edgeExtent).range([edgeScaling.minSize, edgeScaling.maxSize]);
        }
        
        var nodeScaling = this.getNodeScaling();
        if (nodeScaling.scalingFunction === undefined) {
        	nodeScaling.scalingFunction = d3.scaleLog().domain(nodeExtent).range([nodeScaling.minSize, nodeScaling.maxSize]);
        }
        
        var edge = this.getEdgeSelection().data(edgeData, function(d) { return d.id; });
        edge.exit().remove();
        var edgeEnter = edge.enter().append('line')
        	.attr('class', 'edge')
        	.attr('id', function(d) { return d.id; })
        	.style('cursor', 'pointer')
        	.style('stroke-width', function(d) { return edgeScaling.scalingFunction(d.value); })
        	.on('mouseover', this.edgeMouseOver.bind(this))
            .on('mouseout', this.edgeMouseOut.bind(this))
        	.on('click', function(d) {
        		d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.setCurrentEdge(d);
				this.fireEvent('edgeclicked', this, d);
        	}.bind(this));
        
        this.setEdgeSelection(edgeEnter.merge(edge));
        
        var node = this.getNodeSelection().data(nodeData, function(d) { return d.id; });
        node.exit().remove();
        var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr('id', function(d) { return d.id; })
            .style('cursor', 'pointer')
            .on('mouseover', this.nodeMouseOver.bind(this))
            .on('mouseout', this.nodeMouseOut.bind(this))
            .on('click', function(d) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.setCurrentNode(d);
				this.fireEvent('nodeclicked', this, d);
			}.bind(this))
			.on('dblclick', function(d) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.fireEvent('nodedblclicked', this, d);
			}.bind(this))
			.on('contextmenu', function(d) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.fireEvent('nodecontextclicked', this, d);
			}.bind(this))
            .call(d3.drag()
                .on('start', function(d) {
                    if (!d3.event.active) this.getVisLayout().alphaTarget(0.3).restart();
                    if (this.getFixOnDrag()) {
	                    d.fx = d.x;
	                    d.fy = d.y;
                    }
                    this.fireEvent('nodedragstart', this, d);
            	}.bind(this))
                .on('drag', function(d) {
                	if (this.getFixOnDrag()) {
	                    d.fx = d3.event.x;
	                    d.fy = d3.event.y;
                	} else {
                		d.x = d3.event.x;
                		d.y = d3.event.y;
                	}
                    this.fireEvent('nodedrag', this, d);
                }.bind(this))
                .on('end', function(d) {
                	if (!d3.event.active) this.getVisLayout().alphaTarget(0);
                	this.fireEvent('nodedragend', this, d);
                }.bind(this))
            );

        nodeEnter.append('rect');
                
        nodeEnter.append('text')
            .text(function(d) { return d.term; })
//            .attr('font-family', function(d) { return this.getApplication().getFeatureForTerm('font', d.term); }.bind(this))
            .attr('font-size', function(d) {return nodeScaling.scalingFunction(d.value)+'px';})
//            .attr('text-anchor', 'middle')
			.attr('dominant-baseline', 'middle')
			.style('user-select', 'none')
            .each(function(d) { d.bbox = this.getBBox(); });
        
        this.setNodeSelection(nodeEnter.merge(node));
        
        this.getNodeSelection().selectAll('rect')
        	.attr('width', function(d) { return d.bbox.width+16; })
			.attr('height', function(d) { return d.bbox.height+8; })
			.attr('rx', function(d) { return Math.max(2, d.bbox.height * 0.2); })
			.attr('ry', function(d) { return Math.max(2, d.bbox.height * 0.2); });
        
        this.getNodeSelection().selectAll('text')
        	.attr('dx', 8)
			.attr('dy', function(d) { return d.bbox.height*0.5+4; });
        

        this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
        this.getNodeSelection().call(this.applyNodeStyle.bind(this));
        
        this.getVisLayout().nodes(nodeData);
        this.getVisLayout().force('link').links(edgeData);
        this.getVisLayout().alpha(1).restart();
    },
    
    zoomToFit: function(paddingPercent, transitionDuration) {
    	var bounds = this.getVis().node().getBBox();
    	var width = bounds.width;
    	var height = bounds.height;
    	var midX = bounds.x + width/2;
    	var midY = bounds.y + height/2;
    	var svg = this.getVis().node().parentElement;
    	var svgRect = svg.getBoundingClientRect();
        var fullWidth = svgRect.width;
        var fullHeight = svgRect.height;
    	var scale = (paddingPercent || 0.8) / Math.max(width/fullWidth, height/fullHeight);
    	var translate = [fullWidth/2 - scale*midX, fullHeight/2 - scale*midY];
    	d3.select(svg)
    		.transition()
    		.duration(transitionDuration || 500)
    		.call(this.getZoom().transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale));
    },
    
    nodeScaling: function(min, max, total, value) {
    	if (min === max) {
    		return 0.5;
    	} else {
    		var scale = 1 / (max - min);
    		return Math.max(0, (value-min)*scale);
    	}
    },
    
    applyNodeStyle: function(sel, nodeState) {
		var state = nodeState === undefined ? 'normal' : nodeState;
		var style = this.getGraphStyle().node[state];
    	sel.selectAll(':not(text)')
    		.style('fill', function(d) { return style.fill; }.bind(this))
    		.style('fill-opacity', function(d) { return style.fillOpacity; }.bind(this))
    		.style('stroke', function(d) { return style.stroke; }.bind(this))
    		.style('stroke-opacity', function(d) { return style.strokeOpacity; }.bind(this))
    		.style('stroke-width', function(d) { return style.strokeWidth; }.bind(this));
    },
    
    applyEdgeStyle: function(sel, edgeState) {
    	var state = edgeState === undefined ? 'normal' : edgeState;
    	var style = this.getGraphStyle().edge[state];
    	sel.style('stroke', function(d) { return style.stroke; }.bind(this))
	    	.style('stroke-opacity', function(d) { return style.strokeOpacity; }.bind(this));
//	    	.style('stroke-width', function(d) { return style.strokeWidth; }.bind(this));
    },

    edgeMouseOver: function(d) {
    	this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
    	this.getVis().select('#'+d.id).call(this.applyEdgeStyle.bind(this), 'highlight');
    },
    
    edgeMouseOut: function(d) {
    	this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
    },
    
    nodeMouseOver: function(d) {
    	this.setCurrentNode(d);
		
    	this.getNodeSelection().call(this.applyNodeStyle.bind(this));
		
		this.getEdgeSelection().each(function(link) {
			var id;
			if (link.source.id == d.id) {
				id = link.target.id;
			} else if (link.target.id == d.id) {
				id = link.source.id;
			}
			if (id !== undefined) {
				this.getVis().select('#'+id).call(this.applyNodeStyle.bind(this), 'highlight');
				this.getVis().select('#'+link.id).call(this.applyEdgeStyle.bind(this), 'highlight');
			}
		}.bind(this));
		
		this.getVis().select('#'+d.id).call(this.applyNodeStyle.bind(this), 'highlight');
    },
    
    nodeMouseOut: function(d) {
    	this.getNodeSelection().call(this.applyNodeStyle.bind(this));
    	this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
    }
});
Ext.define('Voyant.panel.Panel', {
	mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.util.Toolable','Voyant.util.DetailedError'],
	requires: ['Voyant.widget.QuerySearchField','Voyant.widget.StopListOption','Voyant.widget.CategoriesOption','Voyant.widget.TotalPropertyStatus'],
	alias: 'widget.voyantpanel',
	statics: {
		i18n: {
		},
		config: {
			corpusValidated: false
		},
		api: {
			corpus: undefined,
			input: undefined,
			inputFormat: undefined,
			subtitle: undefined
		}
	},
	config: {
		corpus: undefined
	},
	constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		this.mixins['Voyant.util.Toolable'].constructor.apply(this, arguments);
		if (!this.glyph) {
			this.glyph = Ext.ClassManager.getClass(this).glyph
		}
		
		this.on("afterrender", function() {
			if (this.getXType()!='facet' && this.getApiParam('subtitle') && this.getTitle()) {
				this.setTitle(this.getTitle()+" <i style='font-size: smaller;'>"+this.getApiParam('subtitle')+"</i>")
			}
			if (this.isXType("grid")) {
				this.getSelectionModel().on("selectionchange", function(store, records) {
//					console.warn(records, this.selectedRecordsToRemember)
//					this.selectedRecordsToRemember = records;
				}, this);
				this.getStore().on("beforeload", function() {
					this.selectedRecordsToRemember = this.getSelection();
				}, this)
				this.getStore().on("load", function(store, records) {
					if (Ext.Array.from(this.selectedRecordsToRemember).length>0) {
						// combine contents of store with contents of remembered items, filtering out duplicates
						var seen = {}
						var mergedRecords = Ext.Array.merge(this.selectedRecordsToRemember, records).filter(function(item) {
							if (!(item.getId() in seen)) {
								seen[item.getId()]=true;
								return true
							} else {
								return false;
							}
						});
						if (store.isBufferedStore) {
							if (store.currentPage==1) {
								store.data.addAll(mergedRecords);
								store.totalCount = mergedRecords.length;
								store.fireEvent('refresh', store);
							}
						} else {
							store.loadRecords(mergedRecords);
							this.getSelectionModel().select(this.selectedRecordsToRemember);
							store.fireEvent('refresh', store);
							this.selectedRecordsToRemember = [];
						}
					}
				}, this);
			}
		}, this);
		
		this.on({
			loadedCorpus: {
				fn: function(src, corpus) {
		    		// make sure API is updated if we had a corpus and it's changed, this should be registered first, so hopefully be fired before tools receive notification
		    		this.setApiParam("corpus", corpus.getAliasOrId());
					this.setCorpus(corpus);
				},
				priority: 999, // very high priority
				scope: this
			}
		});
	},
	
	getApplication: function() {
		return Voyant.application;
	},
	
	getBaseUrl: function() {
		return this.getApplication().getBaseUrl();
	},
	
	openUrl: function(url) {
		this.getApplication().openUrl.apply(this, arguments);
	},
	
	getTromboneUrl: function() {
		return this.getApplication().getTromboneUrl();
	},
	
	dispatchEvent: function() {
		var application = this.getApplication();
		application.dispatchEvent.apply(application, arguments);
	},
	
	showError: function(config, response) {
		if (Ext.isString(config)) {
			config = {
				message: config
			}
		}
		Ext.applyIf(config, {
			title: this.localize("error")+" ("+this.localize("title")+")"
		})
		this.getApplication().showError(config, response)
	},
	
	showResponseError: function(config, response) {
		this.getApplication().showResponseError(config, response)
	},
	
	toastError: function(config) {
		if (Ext.isString(config)) {
			config = {html: config}
		}
		Ext.applyIf(config, {
			glyph: 'xf071@FontAwesome',
			title: this.localize("error")
		})
		this.toast(config);
	},
	
	toastInfo: function(config) {
		if (Ext.isString(config)) {
			config = {html: config}
		}
		Ext.applyIf(config, {
			glyph: 'xf05a@FontAwesome',
			title: this.localize("info")
		})
		this.toast(config);
	},
	
	toast: function(config) {
		if (Ext.isString(config)) {
			config = {html: config}
		}
		Ext.applyIf(config, {
			 slideInDuration: 500,
			 shadow: true,
			 align: 'b',
			 anchor: this.getTargetEl()			
		})
		Ext.toast(config);
	},

	/**
	 * Checks to see if we have access to this corpus, first by checking the application's
	 * access setting for the corpus, then by checking the corpus setting.
	 * 
	 * Assumes we're only calling this from a non-consumptive tool.
	 */
	hasCorpusAccess: function(corpus) {
		var app = this.getApplication();
		if (app) {
			var corpusAccess = app.getCorpusAccess();
			if (corpusAccess=='ADMIN' || corpusAccess=='ACCESS') {return true;}
		}
		if (!corpus) {
			if (this.getCorpus) {
				corpus = this.getCorpus();
			}
			if (!corpus && app.getCorpus) {
				corpus = app.getCorpus();
			}
		}
		if (corpus) {
			return corpus.getNoPasswordAccess()!='NONCONSUMPTIVE' && corpus.getNoPasswordAccess()!='NONE';
		}
		return false; // don't know if we ever get here
	}
	
});

Ext.define('Voyant.panel.VoyantTabPanel', {
	extend: 'Ext.tab.Panel',
	alias: 'widget.voyanttabpanel',
	mixins: ['Voyant.panel.Panel'],
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	initComponent: function() {
    	this.callParent(arguments);
	},
	listeners: {
		tabchange: function(panel, newTab) {
			this.tools = [];
			this.getHeader().tools = [];
			this.query("toolmenu").forEach(function(toolMenu) {
				toolMenu.destroy();
			})
			this.addTool(newTab.tools)
			this.getApplication().dispatchEvent("panelChange", this)
		},
		afterrender: function(panel) {
			this.fireEvent("tabchange", this, this.getActiveTab())
		}
	},
	showOptionsClick: function(panel) {
		var tab = panel.getActiveTab();
		if (tab.showOptionsClick) {
			tab.showOptionsClick.apply(tab, arguments)
		}
	}
});
Ext.define('Voyant.widget.Facet', {
	extend: 'Ext.grid.Panel',
    mixins: ['Voyant.panel.Panel'],
    alias: 'widget.facet',
	statics: {
		i18n: {
		},
		api: {
			stopList: 'auto',
			query: undefined
		}
	},
	
	constructor: function(config) {
        this.callParent(arguments);
        Ext.applyIf(config || {}, {
        	includeTools: [], // don't show tools in header
        	rowLines: false,
        	columnLines: false, // ignored?
        	subtitle: undefined
        });
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, [config]);
	},
	
	rowLines: false,
	
    initComponent: function(){

    	var me = this;
    	if (!this.store) {
    		this.store = new Ext.create("Voyant.data.store.CorpusFacets", {
    			proxy: {
    				extraParams: {
    					facet: this.facet
    				}
    			},
    			parentPanel: this
    		})
    		this.store.getProxy().on("exception", function(proxy, request, operation, eOpts) {
		    	me.showResponseError("Unable to fetch facet: "+me.facet, response);
    		})
    	}
    	
        Ext.applyIf(this, {
        	emptyText: this.localize("emptyText"),
        	hideHeaders: true,
        	selType: 'checkboxmodel',
        	columns: [
        	          { renderer: function(value, metaData, record) {return "("+record.getInDocumentsCount()+") "+record.getLabel()}, flex: 1 }
        	]
        });
        this.callParent();
        
        if (this.corpus) {
        	this.setStoreCorpus(this.corpus);
        }
        
        this.on('loadedCorpus', function(src, corpus) {
        	this.setStoreCorpus(corpus);
        }, this);
        
        this.on("query", function(src, query) {
        	this.setApiParam("query", query);
        	// not getting set from beforeload, so set params here
        	this.store.load({
        		params: this.getApiParams()
        	})
        })
    },
    
    setStoreCorpus: function(corpus) {
//    	this.callParent(arguments)
    	if (this.getStore()) {
        	this.getStore().setCorpus(corpus);
        	this.getStore().load();
    	}
    }
});

// assuming Bubblelines library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Bubbles', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.bubbles',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		docIndex: 0,
    		
    		limit: 100,
    		
    		audio: false,
    		
    		speed: 30
    			
    			
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
    	options: {xtype: 'stoplistoption'},
    	audio: false
	},
	
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	Ext.apply(this, {
    		title: this.localize('title'),
			html: '<canvas style="width: 100%; height: 100%"></canvas>',
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					fieldLabel: this.localize('speed'),
					labelAlign: 'right',
					labelWidth: 40,
					width: 100,
					increment: 1,
					minValue: 1,
					maxValue: 60,
					value: 30,
					listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(parseInt(this.getApiParam("speed")));
	                		if (this.bubbles) {this.bubbles.frameRate(cmp.getValue())}
	                		this.setAudio(cmp.getValue());
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('speedTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    changecomplete: function(cmp, val) {
	                    	this.setApiParam('speed', val);
	                		if (this.bubbles) {this.bubbles.frameRate(val)}
	                    },
	                    scope: this
					}
				},{
	                xtype: 'checkbox',
	                boxLabel: this.localize('sound'),
	                listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(this.getApiParam("audio")===true ||  this.getApiParam("audio")=="true");
	                		this.setAudio(cmp.getValue());
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('soundTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    change: function(cmp, val) {
	                    	this.setApiParam('audio', val);
	                    	this.setAudio(val);
	                    },
	                    scope: this
	                }
	            },{xtype: 'tbfill'}, {
	    			xtype: 'tbtext',
	    			html: this.localize('adaptation') //https://www.m-i-b.com.ar/letters/en/
	    		}]
    		}]
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		var canvas = this.getTargetEl().dom.querySelector("canvas");
    		var me = this;
    		Ext.Ajax.request({
    			url: this.getBaseUrl()+'resources/voyant/current/bubbles/bubbles.pjs'
    		}).then(function(data) {
    			var canvas = me.getTargetEl().dom.querySelector("canvas");
    			me.bubbles = new Processing(canvas, data.responseText);
    			me.bubbles.size(me.getTargetEl().getWidth(),me.getTargetEl().getHeight());
    			me.bubbles.frameRate(me.getApiParam('speed'));
    			me.bubbles.bindJavascript(me);
    			me.bubbles.noLoop();
    			me.loadDocument();
    		})
    	}, this);
    	
    	this.on("resize", function() {
    		if (this.bubbles) {
    			this.bubbles.size(this.body.getWidth(),this.body.getHeight());
    		}
    	});
    	
    	this.on("documentselected", function(src, doc) {
    		this.setApiParam('docIndex', this.getCorpus().getDocument(doc).getIndex());
    		this.loadDocument();
    	})
    },
    
    setAudio: function(val) {
    	if (this.gainNode) {this.gainNode.gain.value=val ? 1 : 0;}
    	this.callParent(arguments)
    },

    handleCurrentTerm: function(term) {
    	if (this.oscillator) {this.oscillator.frequency.value = this.terms[term] ? parseInt((this.terms[term]-this.minFreq) * 2000 / (this.maxFreq-this.minFreq)) : 0;}
    },
    
    handleDocFinished: function() {
    	if (this.gainNode) {this.gainNode.gain.value = 0;}
    	var index = parseInt(this.getApiParam('docIndex'));
    	if (index+1<this.getCorpus().getDocumentsCount()) {
    		this.setApiParam('docIndex', index+1);
    		this.loadDocument();
    	}
    },
    
    loadDocument: function() {
    	var me = this, doc = this.getCorpus().getDocument(parseInt(this.getApiParam('docIndex')));
    	// if we're not in a tab panel, set the document title as part of the header
    	if (!this.up("tabpanel")) {
        	this.setTitle(this.localize('title') + " <span class='subtitle'>"+doc.getFullLabel()+"</span>");
    	}

    	doc.loadDocumentTerms(Ext.apply(this.getApiParams(["stopList"]), {
    		limit: 100
    	})).then(function(documentTerms) {
    		me.terms = {};
    		documentTerms.each(function(documentTerm) {
    			me.terms[documentTerm.getTerm()] = documentTerm.getRawFreq();
    		})
    		var values = Object.keys(me.terms).map(function(k){return me.terms[k]});
    		me.minFreq = Ext.Array.min(values);
    		me.maxFreq = Ext.Array.max(values);
    		me.getCorpus().loadTokens({whitelist: Object.keys(me.terms), noOthers: true, limit: 0, docIndex: me.getApiParam('docIndex')}).then(function(tokens) {
    			var words = [];
        		tokens.each(function(token) {
    				words.push(token.getTerm().toLowerCase());
        		})
        		me.bubbles.setLines([doc.getTitle(),words.join(" ")]);
        		me.bubbles.loop();
        		me.oscillator.frequency.value = 150;
        		me.gainNode.gain.value = me.getAudio() ? 1 : 0;
    		})
    	})
    },
    
    initComponent: function() {
    	// make sure to load script
		Ext.Loader.loadScript(this.getBaseUrl()+"resources/processingjs/processing.min.js");
		
		var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
		
		this.oscillator = audioCtx.createOscillator();
		this.gainNode = audioCtx.createGain();
		this.oscillator.connect(this.gainNode);
		this.gainNode.connect(audioCtx.destination);
		this.oscillator.frequency.value = 0;
		this.oscillator.start();
		this.gainNode.gain.value = 0;

    	this.callParent(arguments);
    }
});
// assuming Bubblelines library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Bubblelines', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.bubblelines',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property bins How many "bins" to separate a document into.
    		 * @type Integer
    		 * @private
    		 */
    		bins: 50,
        	/**
        	 * @property query A string to search for in a document.
        	 * @type String
    		 * @private
        	 */
    		query: null,
    		
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		/**
    		 * @property docId The document ID to restrict results to.
    		 * @type String
    		 * @private
    		 */
    		docId: undefined,
    		/**
    		 * @property docIndex The document index to restrict results to.
    		 * @type Integer
    		 * @private
    		 */
    		docIndex: undefined,
    		/**
    		 * @property maxDocs The maximum number of documents to show.
    		 * @type Integer
    		 * @private
    		 */
    		maxDocs: 50
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
		bubblelines: undefined,
		termStore: undefined,
		docTermStore: undefined,
		selectedDocs: undefined,
    	options: [{xtype: 'stoplistoption'},{xtype: 'colorpaletteoption'}]
	},
	
	termTpl: new Ext.XTemplate(
		'<tpl for=".">',
			'<div class="term" style="color: rgb({color});float: left;padding: 3px;margin: 2px;">{term}</div>',
		'</tpl>'
	),
    
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		this.setDocTermStore(corpus.getDocumentTerms({
    			proxy: {
	    			extraParams: {
						withDistributions: 'raw',
						withPositions: true
					}
    			},
				listeners: {
	   		    	 load: function(store, records, successful, options) {
	   		    		records.forEach(function(record) {
	   		    			var termData = this.processTerms(record);
	   		    			var docId = record.get('docId');
	   		    			var term = record.get('term');
	   		    			var termObj = {};
	   		    			termObj[term] = termData;
	   		    			this.getBubblelines().addTermsToDoc(termObj, docId);
	   		    		}, this);
	   		    		this.getBubblelines().doBubblelinesLayout();
	   				},
	   				scope: this
	   		     }
    		}));
    		
    		if (this.isVisible() && this.getBubblelines()) {
    			this.initLoad();
    		}
    	}, this);
    	
        this.on('activate', function() { // load after tab activate (if we're in a tab panel)
        	if (this.getCorpus()) {
				Ext.Function.defer(this.initLoad, 100, this);
			}
    	}, this);
        
        this.on('query', function(src, query) {
    		if (query !== undefined && query != '') {
    			this.getDocTermsFromQuery(query);
    		}
    	}, this);
        
        this.on('documentsSelected', function(src, docIds) {
        	this.setApiParam('docId', docIds);
        	this.getBubblelines().cache.each(function(d) {
        		d.hidden = docIds.indexOf(d.id) === -1;
        	});
        	this.getBubblelines().drawGraph();
        }, this);
    	
    	this.on('termsClicked', function(src, terms) {
    		if (src !== this) {
	    		var queryTerms = [];
	    		terms.forEach(function(term) {
        			if (Ext.isString(term)) {queryTerms.push(term);}
        			else if (term.term) {queryTerms.push(term.term);}
        			else if (term.getTerm) {queryTerms.push(term.getTerm());}
        		});
	    		this.getDocTermsFromQuery(queryTerms);
    		}
		}, this);
    	
    	this.on('documentTermsClicked', function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.getDocTermsFromQuery(queryTerms);
    	}, this);
    	
    	this.down('#granularity').setValue(parseInt(this.getApiParam('bins')));
    },
    
    initComponent: function() {
    	this.setTermStore(Ext.create('Ext.data.ArrayStore', {
            fields: ['term', 'color'],
            listeners: {
            	load: function(store, records, successful, options) {
            		var termsView = this.down('#termsView');
            		for (var i = 0; i < records.length; i++) {
            			var r = records[i];
            			termsView.select(r, true);
            		}
            	},
            	scope: this
            }
        }));
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                },{
	            	text: this.localize('clearTerms'),
					glyph: 'xf014@FontAwesome',
	            	handler: function() {
	            		this.down('#termsView').getSelectionModel().deselectAll(true);
	            		this.getTermStore().removeAll();
	            		this.setApiParams({query: null});
	            		this.getBubblelines().removeAllTerms();
	            		this.getBubblelines().drawGraph();
	            	},
	            	scope: this                			
        		},{
	            	xtype: 'documentselectorbutton'
        		},{
	            	xtype: 'slider',
	            	itemId: 'granularity',
	            	fieldLabel: this.localize('granularity'),
	            	labelAlign: 'right',
	            	labelWidth: 70,
	            	width: 150,
	            	increment: 10,
	            	minValue: 10,
	            	maxValue: 300,
	            	listeners: {
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({bins: newvalue});
	            			this.getBubblelines().bubbleSpacing = newvalue;
	            			this.reloadTermsData();
	            		},
	            		scope: this
	            	}
	            },{
	            	xtype: 'checkbox',
	            	boxLabel: this.localize('separateLines'),
	            	boxLabelAlign: 'before',
	            	checked: false,
	            	handler: function(checkbox, checked) {
	            		this.getBubblelines().SEPARATE_LINES_FOR_TERMS = checked;
	            		this.getBubblelines().lastClickedBubbles = {};
	            		this.getBubblelines().setCanvasHeight();
	    				this.getBubblelines().drawGraph();
	            	},
	            	scope: this
	            	
	            }]
    		}],
            border: false,
            layout: 'fit',
            items: {
            	layout: {
            		type: 'vbox',
            		align: 'stretch'
            	},
            	defaults: {border: false},
	            items: [{
	            	height: 30,
	            	itemId: 'termsView',
	            	xtype: 'dataview',
	            	store: this.getTermStore(),
	            	tpl: this.termTpl,
	            	itemSelector: 'div.term',
	            	overItemCls: 'over',
	            	selectedItemCls: 'selected',
	            	selectionModel: {
	            		mode: 'SIMPLE'
	            	},
//	            	cls: 'selected', // default selected
	            	focusCls: '',
	            	listeners: {
	            		beforeitemclick: function(dv, record, item, index, event, opts) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			dv.fireEvent('itemcontextmenu', dv, record, item, index, event, opts);
	            			return false;
	            		},
	            		beforecontainerclick: function() {
	            			// cancel deselect all
	            			event.preventDefault();
	            			event.stopPropagation();
	            			return false;
	            		},
	            		selectionchange: function(selModel, selections) {
	            			var dv = this.down('#termsView');
	            			var terms = [];
	            			
	            			dv.getStore().each(function(r) {
	            				if (selections.indexOf(r) !== -1) {
	            					terms.push(r.get('term'));
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('unselected').addCls('selected');
	            				} else {
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('selected').addCls('unselected');
	            				}
	            			});
	            			
	            			for (var index in this.getBubblelines().lastClickedBubbles) {
	            				var lcTerms = this.getBubblelines().lastClickedBubbles[index];
	            				for (var term in lcTerms) {
	            					if (terms.indexOf(term) == -1) {
	            						delete this.getBubblelines().lastClickedBubbles[index][term];
	            					}
	            				}
	            				
	            			}
	            			this.getBubblelines().termsFilter = terms;
	            			this.getBubblelines().setCanvasHeight();
	            			this.getBubblelines().drawGraph();
	            		},
	            		itemcontextmenu: function(dv, record, el, index, event) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			var isSelected = dv.isSelected(el);
	            			var menu = new Ext.menu.Menu({
	            				floating: true,
	            				items: [{
	            					text: isSelected ? this.localize('hideTerm') : this.localize('showTerm'),
	            					handler: function() {
	            						if (isSelected) {
	            							dv.deselect(index);
	            						} else {
	            							dv.select(index, true);
	            						}
	            					},
	            					scope: this
	            				},{
	            					text: this.localize('removeTerm'),
	            					handler: function() {
	            						dv.deselect(index);
	            						var term = this.getTermStore().getAt(index).get('term');
	            						this.getTermStore().removeAt(index);
	            						dv.refresh();
	            						
	            						this.getBubblelines().removeTerm(term);
	            						this.getBubblelines().setCanvasHeight();
	            						this.getBubblelines().drawGraph();
	            					},
	            					scope: this
	            				}]
	            			});
	            			menu.showAt(event.getXY());
	            		},
	            		scope: this
	            	}
	            },{
	            	flex: 1,
	            	xtype: 'container',
	            	autoEl: 'div',
	            	itemId: 'canvasParent',
	            	layout: 'fit',
	            	overflowY: 'auto',
	            	overflowX: 'hidden'
	            }],
	            listeners: {
	            	render: function(component) {
	            		var canvasParent = this.down('#canvasParent');
	                	this.setBubblelines(new Bubblelines({
	                		container: canvasParent,
	                		clickHandler: this.bubbleClickHandler.bind(this)
	                	}));
	                	this.getBubblelines().bubbleSpacing = parseInt(this.getApiParam('bins'));
	            	},
            		afterlayout: function(container) {
            			if (this.getBubblelines().initialized === false) {
            				this.getBubblelines().initializeCanvas();
            			}
            		},
	        		resize: function(cnt, width, height) {
	        			this.getBubblelines().doBubblelinesLayout();
	        		},
            		scope: this
            	}
            }
		});
    	
    	this.callParent(arguments);
    },
    
    initLoad: function() {
    	// get doc info
    	var docIds = [];
		this.getCorpus().getDocuments().each(function(doc, index, total) {
			var inLimit = index < this.getApiParam('maxDocs');
			this.getBubblelines().addDocToCache({
				id: doc.getId(),
				index: doc.getIndex(),
				title: doc.getShortTitle(),
				totalTokens: doc.get('tokensCount-lexical'),
				terms: {},
				hidden: !inLimit
			});
			if (inLimit) {
				docIds.push(doc.getId());
			}
		}, this);
		this.setApiParam('docId', docIds);
		
		// get top terms in corpus
		this.getCorpus().getCorpusTerms({autoload: false}).load({
			callback: function(records, operation, success) {
		    	var query = [];
		    	records.forEach(function(record, index) {
					query.push(record.get('term'));
				}, this);
		    	this.getDocTermsFromQuery(query);
		    },
		    scope: this,
		    params: {
		    	limit: this.getApiParam('query') ? undefined : 5,
		    	stopList: this.getApiParams('stopList'),
		    	query: this.getApiParam('query')
		    }
		});
    },
    
    /**
     * Get the results for the query(s) for each of the corpus documents.
     * @param query {String|Array}
     */
    getDocTermsFromQuery: function(query) {
    	if (query) {this.setApiParam('query', query);} // make sure it's set for subsequent calls
    	if (this.getCorpus() && this.isVisible()) {
			this.getDocTermStore().load({params: this.getApiParams()});
    	}
	},
    
	reloadTermsData: function() {
		var terms = [];
		for (var term in this.getBubblelines().currentTerms) {
			terms.push(term);
		}
		this.getDocTermsFromQuery(terms);
	},
	
    filterDocuments: function() {
		var docIds = this.getApiParam('docId');
		if (docIds == '') {
			docIds = [];
			this.getCorpus().getDocuments().each(function(item, index) {
				docIds.push(item.getId());
			});
			this.setApiParams({docId: docIds});
		}
		if (typeof docIds == 'string') docIds = [docIds];
		
		if (docIds == null) {
			this.setSelectedDocs(this.getCorpus().getDocuments().clone());
			var count = this.getSelectedDocs().getCount();
			if (count > 10) {
				for (var i = 10; i < count; i++) {
					this.getSelectedDocs().removeAt(10);
				}
			}
			docIds = [];
			this.getSelectedDocs().eachKey(function(docId, doc) {
				docIds.push(docId);
			}, this);
			this.setApiParams({docId: docIds});
		} else {
			this.setSelectedDocs(this.getCorpus().getDocuments().filterBy(function(doc, docId) {
				return docIds.indexOf(docId) != -1;
			}, this));
		}
	},
	
	processTerms: function(termRecord) {
		var termObj;
		var term = termRecord.get('term');
		var rawFreq = termRecord.get('rawFreq');
		var positions = termRecord.get('positions');
		if (rawFreq > 0) {
			var color = this.getApplication().getColorForTerm(term);
			if (this.getTermStore().find('term', term) === -1) {
				this.getTermStore().loadData([[term, color]], true);
				var index = this.getTermStore().find('term', term);
				this.down('#termsView').select(index, true); // manually select since the store's load listener isn't triggered
			}
			var distributions = termRecord.get('distributions');
			termObj = {positions: positions, distributions: distributions, rawFreq: rawFreq, color: color};
		} else {
			termObj = false;
		}
		
		return termObj;
	},
	
	bubbleClickHandler: function(data) {
		this.getApplication().dispatchEvent('termsClicked', this, data);
	}
});
Ext.define('Voyant.panel.Catalogue', {
	extend: 'Ext.panel.Panel',
	requires: ['Voyant.widget.Facet'],
	mixins: ['Voyant.panel.Panel','Voyant.util.Downloadable'],
	
	alias: 'widget.catalogue',
    statics: {
    	i18n: {
    	},
    	api: {
    		config: undefined,
    		stopList: 'auto',
    		facet: ['facet.title','facet.author','facet.language'],
    		title: undefined,
    		splash: undefined,
    		reader: "reader"
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	facets: {},
    	matchingDocIds: [],
    	customResultsHtml: undefined
    },
    
    constructor: function(config) {
    	config = config || {};
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
    	Ext.apply(this, {
    		title: this.localize('title'),
    		layout: 'hbox',
    		items: [
    		        {
    		        	layout: 'vbox',
    		        	height: '100%',
    		        	align: 'stretch',
    		        	itemId: 'facets',
    		        	defaults: {
    		        		width: 250,
    		        		flex: 1,
    		        		xtype: 'facet',
    		        		margin: 5,
    		        		border: true,
    		        		frame: true,
    		            	includeTools: {
    		            		close: {
    		            			type: 'close',
    		                		tooltip: this.localize('closeFacetTip'),
    		                		callback: function(facetCmp) {
    		                			delete this.facets[facetCmp.facet]; // remove from facets map
    		                			facetCmp.destroy(); // remove this facet
    		                			this.updateResults();
    		                		},
    		                		scope: this
    		            		},
    		            		add: {
    		            			type: 'plus',
    		                		tooltip: this.localize('plusFacetTip'),
    		                		callback: function() {
    		                			this.addFacet();
    		                		},
    		                		scope: this
    		            		}
    		            	}
    		        	},
    		        	items: []
    		        },
    		        {
    		        	xtype: 'panel',
    		        	html: config.customResultsHtml || '',
    		        	flex: 1,
    		        	itemId: 'results',
    		        	height: '100%',
    		        	align: 'stretch',
    		        	scrollable: true,
    		        	margin: 5,
    		        	getCorpus: function() { // for query search field
    		        		return this.findParentByType('panel').getCorpus();
    		        	},
    		        	listeners: {
    		        		query: function(src, query) {
    		        			this.findParentByType('panel').updateResults(Ext.isString(query) ? [query] : query)
    		        		}
    		        	},
    		    		dockedItems: [{
    		                dock: 'bottom',
    		                xtype: 'toolbar',
    		                overflowHandler: 'scroller',
    		                items: [{
	    		        		itemId: 'sendToVoyant',
	    		        		text: this.localize('sendToVoyantButton'),
	    		        		disabled: true,
	    		        		handler: function() {
	    		        			this.mask(this.localize("exportInProgress"));
	    		        			var catalogue = this;
	    		            		Ext.Ajax.request({
	    		            			url: this.getApplication().getTromboneUrl(),
	    		            			params: {
	    		            				corpus: this.getCorpus().getId(),
	    		            				tool: 'corpus.CorpusManager',
	    		            				keepDocuments: true,
	    		            				docId: this.getMatchingDocIds()
	    		            			},
	    		            		    success: function(response, opts) {
	    		            		    	catalogue.unmask();
	    		            		    	var json = Ext.JSON.decode(response.responseText);
		                    				var url = catalogue.getBaseUrl()+"?corpus="+json.corpus.id;
		                    				catalogue.openUrl(url);
	    		            		    },
	    		            		    failure: function(response, opts) {
	    		            		    	catalogue.unmask();
	    		            		    	me.showResponseError("Unable to export corpus: "+catalogue.getCorpus().getId(), response);
	    		            		    }
	    		            		})
	
	    		        		},
	    		        		scope: this
	    		        	},{
	    		        		itemId: 'export',
	    		        		text: this.localize('downloadButton'),
	    		        		disabled: true,
	    		        		handler: function() {
	    		        			this.mask(this.localize("exportInProgress"));
	    		        			var catalogue = this;
	    		            		Ext.Ajax.request({
	    		            			url: this.getApplication().getTromboneUrl(),
	    		            			params: {
	    		            				corpus: this.getCorpus().getId(),
	    		            				tool: 'corpus.CorpusManager',
	    		            				keepDocuments: true,
	    		            				docId: this.getMatchingDocIds()
	    		            			},
	    		            		    success: function(response, opts) {
	    		            		    	catalogue.unmask();
	    		            		    	var json = Ext.JSON.decode(response.responseText);
	    		            		    	catalogue.downloadFromCorpusId(json.corpus.id);
	    		            		    },
	    		            		    failure: function(response, opts) {
	    		            		    	catalogue.unmask();
	    		            		    	me.showResponseError("Unable to export corpus: "+catalogue.getCorpus().getId(), response);
	    		            		    }
	    		            		})
	
	    		        		},
	    		        		scope: this
	    		        	},{
	    		        		xtype: 'querysearchfield',
	    		        		width: 200,
	    		        		flex: 1
	    		        	},{
	    		        		itemId: 'status',
	    		        		xtype: 'tbtext'
	    		        	}]
    		    		}]
    		        }, {
    		        	xtype: this.getApiParam("reader"),
    		        	flex: 1,
    		        	height: '100%',
    		        	align: 'stretch',
    		        	header: false
    		        }]
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		this.queryById('status').update(new Ext.XTemplate(this.localize('noMatches')).apply([corpus.getDocumentsCount()]))
    		if (!this.getCustomResultsHtml()) {
    			if (this.getApiParam("splash")) {
        			this.setCustomResultsHtml(this.getApiParam("splash"));
        			this.updateResults();
        			return;
    			}
    			this.setCustomResultsHtml(new Ext.XTemplate(this.localize('noMatches')).apply([corpus.getDocumentsCount()]));
    			this.updateResults();
    	    	Ext.Ajax.request({
    	    	    url: this.getTromboneUrl(),
    	    	    params: {
    	        		tool: 'resource.StoredResource',
    	        		verifyResourceId: 'customhtml-'+corpus.getAliasOrId()
    	    	    },
    	    	    success: function(response, req) {
    	    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	    	if (json && json.storedResource && json.storedResource.id) {
    	        	    	Ext.Ajax.request({
    	        	    	    url: this.getTromboneUrl(),
    	        	    	    params: {
    	        	        		tool: 'resource.StoredResource',
    	        	        		retrieveResourceId: 'customhtml-'+corpus.getAliasOrId()
    	        	    	    },
    	        	    	    success: function(response, req) {
    	        	    	    	var json = Ext.util.JSON.decode(response.responseText);
    	        	    	    	if (json && json.storedResource && json.storedResource.resource) {
    	        	    	    		this.setCustomResultsHtml(json.storedResource.resource);
    	        	    	    		this.updateResults()
    	        	    	    	}
    	        	    	    },
    	        	    	    scope: this
    	        	    	})
    	    	    	}
    	    	    },
    	    	    scope: this
    	    	})

    		}
    	});
    	
    	this.on('afterrender', function(panel) {
    		
    		var facetsCmp = this.queryById('facets');
			this.addFacet({
				facet: 'lexical',
    			includeTools: {add: {
        			type: 'plus',
            		tooltip: this.localize('plusFacetTip'),
            		callback: function() {
            			this.addFacet();
            		},
            		scope: this
        		}},
				store: new Voyant.data.store.CorpusTerms({
					parentPanel: this,
    				proxy: {
    					extraParams: {
    	    				stopList: this.getApiParam("stopList")
    					}
    				}
				})
			}, facetsCmp)
    		
    		var facets = this.getApiParam('facet');
    		if (Ext.isString(facets)) {facets = facets.split(",")}
    		facets.forEach(function(facet) {
    			this.addFacet({facet: facet}, facetsCmp)
    			/*
    			facetCmp.getSelectionModel().on('selectionchange', function(model, selected) {
    				var labels = [];
    				selected.forEach(function(model) {
    					labels.push({facet: model.getFacet(), label: model.getLabel()})
    				})
    				panel.getFacets()[facet] = labels;
    				panel.updateResults();
    			})
    			facetCmp.on('query', function(model, selected) {
    				panel.getFacets()[facetCmp.facet] = [];
    				panel.updateResults();
    			})*/
    		}, this);
			

			
    		/*
			facetCmp.getSelectionModel().on('selectionchange', function(model, selected) {
				var labels = [];
				selected.forEach(function(model) {
					labels.push({facet: 'lexical', label: model.getTerm()})
				})
				panel.getFacets()['lexical'] = labels;
				panel.updateResults();
			})*/
    		
        	var title = this.getApiParam("title");
        	if (title) {this.setTitle(title)}
    	});
    	
    	
    },
    
    addFacet: function(config, facetsCmp) {
    	if (!config) {
    		// select first, then add
    		return this.selectFacet(function(facet) {
    			this.addFacet({facet: facet})
    		})
    	}
		facetsCmp = facetsCmp || this.queryById('facets');
    	var facet = config.facet,
    		itemTpl = '<span style="font-size: smaller;">(<span class="info-tip" data-qtip="'+this.localize('matchingDocuments')+'">{inDocumentsCount}</span>)</span> {term}'+'<span style="font-size: smaller;"> (<span class="info-tip" data-qtip="'+this.localize('rawFreqs')+'">{rawFreq}</span>)</span>'

		var title = this.localize(facet+"Title");
		if (title=="["+facet+"Title]") {
			title = facet.replace(/^facet\./,"").replace(/^extra./,"");
		}
		var matchingDocumentsLabel = this.localize('matchingDocuments');
		
		Ext.applyIf(config, {
			title: title,
			collapsible: true,
			facet: facet,
			columns: [{
				renderer: function(value, metaData, record) {
					return '<span style="font-size: smaller;">(<span class="info-tip" data-qtip="'+this.localize('matchingDocuments')+'">'+record.getInDocumentsCount()+"</span>) </span>"+
						(record.getLabel ? record.getLabel() : record.getTerm()+'<span style="font-size: smaller;"> (<span class="info-tip" data-qtip="'+this.localize('rawFreqs')+'">'+record.getRawFreq()+"</span>)</span>")
				},
				flex: 1
			}],
			bbar: [{
				xtype: 'querysearchfield',
				width: '100%',
				tokenType: facet.replace("facet.", ""),
				itemTpl: itemTpl
			}],
			corpus: this.getCorpus()
		})
		
		var facetCmp = facetsCmp.add(config);
		
		facetCmp.getSelectionModel().on('selectionchange', function(model, selected) {
			var labels = [];
			selected.forEach(function(model) {
				labels.push({facet: facetCmp.facet, label: model.getLabel ? model.getLabel() : model.getTerm()})
			})
			this.getFacets()[facet] = labels;
			this.updateResults();
		}, this)
		facetCmp.on('query', function(model, selected) {
			this.getFacets()[facetCmp.facet] = [];
			this.updateResults();
		}, this)
    	return facetCmp;
    },
    
    updateResults: function(queries) {
    	var facets = this.getFacets();
    	if (!queries) {
	    	var queries = [];
	    	for (facet in facets) {
	    		facets[facet].forEach(function(label) {
	        		queries.push(label.facet+":"+label.label);
	    		})
	    	}
	    	if (queries) {
		    	return this.updateResults(queries)
	    	}
    	}
		var results = this.queryById("results").getTargetEl();
		var catalogue = this;
		results.update(this.getCustomResultsHtml() ? this.getCustomResultsHtml() : new Ext.XTemplate(this.localize('noMatches')).apply([this.getCorpus().getDocumentsCount()]));
		this.queryById('status').update(new Ext.XTemplate(this.localize('noMatches')).apply([this.getCorpus().getDocumentsCount()]))
		this.queryById('sendToVoyant').setDisabled(true);
		this.queryById('export').setDisabled(true);
    	if (queries && queries.length>0) {
    		this.mask(this.localize("loading"));
    		var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
    		documentQueryMatches.load({
    			params: {query: queries, includeDocIds: true},
    			callback: function(records, operation, success) {
    				this.unmask();
    				if (records && records.length>0) {
    					this.queryById('status').setHtml(records.length)
    					var list = "<ul>";
    					var matchingDocIds = [];
    					records.forEach(function(record) {
    						record.getDocIds().forEach(function(docId) {
    							matchingDocIds.push(docId);
    							var doc = documentQueryMatches.getCorpus().getDocument(docId);
    							var item = "<li id='"+results.getId()+'_'+docId+"' class='cataloguedoc'>";
    							item += "<a href='#' class='cataloguedoctitle' data='"+docId+"'>"+doc.getTitle()+"</a>";
    							for (facet in facets) {
    								if (facets[facet].length==0) {continue;}
    								var labelItems = "";
    								if (facet!='facet.title') {
    									var suffix = facet.replace(/^.+?\./,"");
    									var label = doc.get(suffix);
    									if (label) {
    										var isArray = Ext.isArray(label);
    										if (isArray) {
    											labelItems+="<li>"+suffix+"<ul>"
    										} else {
    											label = [label];
    										}
    										label.forEach(function(l) {
    											var isMatch = false;
    											facets[facet].forEach(function(f) {
    												if (f.label==l) {isMatch=true}
    												else if (f.facet.indexOf('facet')==-1) {
    													f.label.split(/\W+/).forEach(function(part) {
    														if (part.trim().length>0 && l.toLowerCase().indexOf(part.toLowerCase())>-1) {
    															isMatch=true;
    														}
    													})
    												}
    											})
    											labelItems+="<li>"+(isArray ? '' : suffix.replace('extra.','')+": ")+(isMatch ? '<span class="keyword">'+l+'</span>' : l)+"</li>"
    										})
    										if (isArray) {
    											labelItems+="</ul></li>";
    										}
    									}
    								}
    								if (labelItems) {
    									item+="<ul>"+labelItems+"</ul>";
    								}
    							}
    							item += "</li>";
    							list += item;
    						})
    					})
    					list += "</ul>";
    					results.update(list);
    					var me = this;
    					var lnks = results.query(".cataloguedoctitle");
    					lnks.forEach(function(lnk) {
    						Ext.get(lnk).on("click", function(e,el) {
    							this.dispatchEvent("documentSelected", me, el.getAttribute("data"));
    						}, me)
    					});
    					if (lnks.length==1) {
    						this.dispatchEvent("documentSelected", me, lnks[0].getAttribute("data"));
    					}
    					this.queryById('status').update(new Ext.XTemplate(this.localize('queryMatches')).apply([matchingDocIds.length,this.getCorpus().getDocumentsCount()]))
    					this.setMatchingDocIds(Ext.Array.clone(matchingDocIds));
    					if (matchingDocIds.length>0) {
    						this.queryById('export').setDisabled(false);
    						this.queryById('sendToVoyant').setDisabled(false);
    					}
    					
    					// now try to load some snippets, if need be
    					if (facets['lexical']) {
    						var firstDocIds = matchingDocIds.splice(0,5);
    						this.loadSnippets(firstDocIds, results.first().first());
    						if (matchingDocIds && matchingDocIds.length>0) {
        						this.loadSnippets(matchingDocIds); // load the rest
    						}
    					}
    				}
    			},
    			scope: this
    		})    		
    	}
    },
    
    loadSnippets: function(docIds, elToMask) {
		var results = this.queryById("results").getTargetEl();
    	var facets = this.getFacets();
    	if (facets['lexical']) {
    		var queries = facets['lexical'].map(function(label) {return label.facet+":"+label.label});
    		var contexts = this.getCorpus().getContexts({buffered: false});
    		if (elToMask) {
    			elToMask.mask(this.localize("loadingSnippets"));
    		}
    		contexts.load({
    			method: 'POST',
    			params: {
                	stripTags: "all",
    				query: queries,
    				docId: docIds,
    				perDocLimit: 3,
    				limit: 100,
    				accurateTotalNotNeeded: true
    			},
    			scope: this,
    			callback: function(records, operation, success) {
    				if (elToMask) {
    					elToMask.unmask();
    				}
    				if (success && Ext.isArray(records) && records.length>0) {
    					var snippets = {};
    					records.forEach(function(record) {
    						if (!snippets[record.getDocIndex()]) {snippets[record.getDocIndex()]=[]}
    						snippets[record.getDocIndex()].push(record);
    					})
    					for (docIndex in snippets) {
    						var id = this.getCorpus().getDocument(docIndex).getId();
    						var html = '<li style="list-style-type: none; font-size: smaller;">'+snippets[docIndex].map(function(snippet) {
    							return snippet.getHighlightedContext();
    						}).join("  ")+'</li>'
    						var docItem = results.down("#"+results.getId()+"_"+id);
    						if (docItem.query("ul")) {
    							html="<ul>"+html+"</ul>";
    						}
    						docItem.insertHtml('beforeEnd', html)
    					}
    				}
    			}
        	})        		
    	}
	
    },
    
    selectFacet: function(callback) {
    	if (!this.facetsSelectionStore) {
    		var keys = {};
    		this.getCorpus().getDocuments().each(function(doc) {
    			for (var key in doc.getData()) {
    				if (key!="corpus" && key.indexOf("parent")!==0 && key.indexOf("-lexical")=="-1") {
        				keys[key] = true
    				}
    			}
    		});
    		keys = Object.keys(keys);
    		keys.sort();
    		this.facetsSelectionStore = Ext.create('Ext.data.ArrayStore', {
    		    fields: ['text'],
    		    data: keys.map(function(key) {return [key]})
    		});
    	}
    	
    	var existingFacets = {};
    	this.queryById('facets').items.each(function(cmp) {
    		existingFacets[cmp.facet]=true;
    	})

    	this.facetsSelectionStore.filterBy(function(record) {
    		return !("facet."+record.get('text') in existingFacets)
    	})
    	
		var win = Ext.create('Ext.window.Window', {
			title: this.localize("selectFacet"),
			modal: true,
			items: {
				xtype: 'form',
				width: 300,
				items: {
					xtype: 'combo',
					store: this.facetsSelectionStore,
					forceSelection: true,
					width: 300
				},
				buttons: [{
	            	text: this.localize("cancel"),
		            ui: 'default-toolbar',
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize("select"),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var facet = btn.up('window').down('combo').getValue();
	        			if (!facet) {
	        				return this.showError(this.localize('selectValidFacet'));
	        			} else {
	        				callback.call(this, "facet."+facet);
		        			btn.up('window').close();
	        			}
	        		},
	        		scope: this
	            }]
			},
			bodyPadding: 5
		}).show()
    }
    
});

// assuming Cirrus library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Cirrus', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.cirrus',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		categories: undefined,
    		whiteList: undefined, // specify a list of words to use
    		limit: 500,
    		visible: 50,
    		terms: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		
    		inlineData: undefined, // format should match CorpusTerm model, only term and rawFreq required

    		fontFamily: '"Palatino Linotype", "Book Antiqua", Palatino, serif',
    		cirrusForceFlash: false,
    		background: '0xffffff',
    		fade: true,
    		smoothness: 2,
    		diagonals: 'none' // all, bigrams, none
    	},
		glyph: 'xf06e@FontAwesome'
    },
    
    config: {
    	mode: undefined,
    	options: [
    		{xtype: 'stoplistoption'},
    		{
	    		xtype: 'listeditor',
	    		name: 'whiteList'
    	    },
    	    {xtype: 'categoriesoption'},
//    	    {
//    	    	// TODO this field does nothing
//    	        xtype: 'numberfield',
//    	        name: 'label',
//    	        fieldLabel: 'Max words',
//    	        labelAlign: 'right',
//    	        value: 500,
//    	        minValue: 50,
//    	        step: 50,
//    	        listeners: {
//        	        afterrender: function(field) {
//        	        	var win = field.up("window");
//        	        	if (win && win.panel) {field.setFieldLabel(win.panel.localize("maxTerms"))}
//        	        }
//    	        }
//    	    },
    	    {xtype: 'fontfamilyoption'},
    	    {xtype: 'colorpaletteoption'}

    	],
    	records: undefined,
    	terms: undefined,
    	cirrusId: undefined,
    	visLayout: undefined, // cloud layout algorithm
    	vis: undefined, // actual vis
    	tip: undefined,
    	sizeAdjustment: 100, // amount to multiply a word's relative size by
    	minFontSize: 12,
    	largestWordSize: 0,
    	smallestWordSize: 1000000
    },
    
    MODE_CORPUS: 'corpus',
    MODE_DOCUMENT: 'mode_document',
    
    layout: 'fit',
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.getApplication().addFeature('orientation', function() { return ~~(Math.random() * 2) * 90; });
    	
    	this.setCirrusId(Ext.id(null, 'cirrus_'));
    },
    
    initComponent: function (config) {
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			xtype: 'corpusdocumentselector',
        			singleSelect: true
        		},{
        			fieldLabel: this.localize('visibleTerms'),
        			labelWidth: 40,
        			width: 120,
        			xtype: 'slider',
	            	increment: 25,
	            	minValue: 25,
	            	maxValue: 500,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.maxValue = this.getApiParam("limit")
	            			slider.increment = parseInt(slider.maxValue/50)
	            			slider.setValue(this.getApiParam("visible"))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({visible: newvalue});
	            			this.loadFromTermsRecords();
	            		},
	            		scope: this
	            	}
                }]
    		}]
    	});

    	this.callParent(arguments);
    	
    	
    },
    
    listeners: {
    	boxready: function() {
			this.initVisLayout(); // force in case we've changed fontFamily from options

			var dataString = this.getApiParam('inlineData');
        	if (dataString !== undefined) {
        		if (dataString.charAt(0)=="[") {
            		var jsonData = Ext.decode(dataString, true);
        		} else {
        			if (dataString.indexOf(":")>-1) {
        				jsonData = [];
        				dataString.split(",").forEach(function(term) {
        					parts = term.split(":");
        					jsonData.push({
        						text: parts[0],
        						rawFreq: parseInt(parts[1])
        					})
        				})
        			} else {
        				var terms = {}
        				jsonData = [];
        				dataString.split(",").forEach(function(term) {
        					if (term in terms) {
        						terms[term]++;
        					} else {
        						terms[term] = 1;
        					}
        				});
        				for (term in terms) {
        					jsonData.push({
        						text: term,
        						rawFreq: terms[term]
        					})
        				}
        			}
        		}
        		if (jsonData !== null && jsonData.length>0) {
        			this.setApiParam('inlineData', jsonData);
	        	    this.setTerms(jsonData);
	        	    this.buildFromTerms();
        		}
        	}
    	},
    	resize: function(panel, width, height) {
    		if (this.getVisLayout() && this.getCorpus()) {
    			this.setAdjustedSizes();
    			
    			var el = this.getLayout().getRenderTarget();
    	    	width = el.getWidth();
    			height = el.getHeight();
    			
    			el.down('svg').set({width: width, height: height});
    			if (this.getTerms()) {
        			this.getVisLayout().size([width, height]).stop().words(this.getTerms()).start();
    			}
    		}
    	},
    	
    	loadedCorpus: function(src, corpus) {
    		this.initVisLayout(); // force in case we've changed fontFamily from options
    		if (this.getApiParam("docIndex")) {
    			this.fireEvent("documentSelected", this, corpus.getDocument(this.getApiParam("docIndex")));
    		} else if (this.getApiParam("docId")) {
    			this.fireEvent("documentSelected", this, corpus.getDocument(this.getApiParam("docId")));
    		} else {
        		this.loadFromCorpus(corpus);
    		}
    	},
    	
    	corpusSelected: function(src, corpus) {
    		this.loadFromCorpus(corpus);
    		
    	},
    	
    	documentSelected: function(src, document) {
    		if (document) {
        		var corpus = this.getCorpus();
        		var document = corpus.getDocument(document);
        		this.setApiParam('docId', document.getId());
        		var documentTerms = document.getDocumentTerms({autoload: false, corpus: corpus, pageSize: this.getApiParam("maxVisible"), parentPanel: this});
        		this.loadFromDocumentTerms(documentTerms);
    		}
    	},
    	
    	ensureCorpusView: function(src, corpus) {
    		if (this.getMode() != this.MODE_CORPUS) {this.loadFromCorpus(corpus);}
    	}
    },
    
    loadFromCorpus: function(corpus) {
    	var jsonData = this.getApiParam('inlineData');
    	if (jsonData === undefined) {
			this.setApiParams({docId: undefined, docIndex: undefined});
			this.loadFromCorpusTerms(corpus.getCorpusTerms({autoload: false, pageSize: this.getApiParam("maxVisible"), parentPanel: this}));
    	} else {
    		// if (jsonData !== undefined) {
    		// 	var records = [];
    		// 	for (var i = 0; i < jsonData.length; i++) {
			// 		var wordData = jsonData[i];
			// 		wordData.term = wordData.text; // inlineData/CorpusTerm format mismatch
    		// 		var record = Ext.create('Voyant.data.model.CorpusTerm', wordData);
    		// 		records.push(record);
    		// 	}
    		// 	this.setRecords(records);
    		// 	this.setMode(this.MODE_CORPUS);
    		// 	this.loadFromTermsRecords();
    		// }
    	}
    },
    
    loadFromDocumentTerms: function(documentTerms) {
    	documentTerms.load({
		    callback: function(records, operation, success) {
		    	this.setMode(this.MODE_DOCUMENT);
		    	this.setRecords(operation.getRecords()); // not sure why operation.records is different from records
		    	this.loadFromTermsRecords();
		    },
		    scope: this,
		    params: this.getApiParams()
    	});
    },
    
    loadFromCorpusTerms: function(corpusTerms) {
		corpusTerms.load({
		    callback: function(records, operation, success) {
		    	this.setMode(this.MODE_CORPUS);
		    	this.setRecords(operation.getRecords()); // not sure why operation.records is different from records
		    	this.loadFromTermsRecords();
		    },
		    scope: this,
		    params: this.getApiParams()
    	});
    },
    
    loadFromTermsRecords: function() {
    	var records = this.getRecords();
    	var visible = this.getApiParam("visible");
    	if (visible>records.length) {visible=records.length;}
    	var terms = [];
    	for (var i=0; i<visible; i++) {
    		if (records[i].get('rawFreq')>0) {
        		terms.push({text: records[i].get('term').replace(/"/g,''), rawFreq: records[i].get('rawFreq')});
    		}
    	}
    	this.setTerms(terms);
    	this.buildFromTerms();
    },
    
    initVisLayout: function(forceLayout) {
    	if (forceLayout || this.getVisLayout() == undefined) {
    		var cirrusForceFlash = this.getApiParam('cirrusForceFlash');
    		if (cirrusForceFlash == 'true' || cirrusForceFlash === true) {
    			this.setApiParam('cirrusForceFlash', true);
    			var id = this.getCirrusId();
    			var appVars = {
    				id: id
    			};
    			var keys = ['background','fade','smoothness','diagonals'];
    			for (var i = 0; i < keys.length; i++) {
    				appVars[keys[i]] = this.getApiParam(keys[i]);
    			}
    			
    			var swfscript = '<script type="text/javascript" src="'+this.getApplication().getBaseUrl()+'resources/swfobject/swfobject.js'+'"></script>';
    			var cirrusLinks = '<script type="text/javascript">'+
				'cirrusClickHandler'+id+' = function(word, value) {\n'+
				'\tif (window.console && console.info) console.info(word, value);\n'+
				'\tvar cirrusTool = Ext.getCmp("'+this.id+'");\n'+
				'\tcirrusTool.dispatchEvent("termsClicked", cirrusTool, [word]);\n'+
				'}\n'+
				'cirrusLoaded'+id+' = function() {\n'+
				'\tif (window.console && console.info) console.info("cirrus flash loaded");\n'+
				'}\n'+
				'cirrusPNGHandler'+id+' = function(base64String) {\n'+
				'\tvar cirrusTool = Ext.getCmp("'+this.id+'");\n'+
				'\tcirrusTool.cirrusPNGHandler(base64String);\n'+
				'}'+
				'</script>';
    			
    			this.update(swfscript+cirrusLinks, true, function() {
    				function loadFlash(component) {
    					if (typeof swfobject !== 'undefined') {
    						var el = component.getLayout().getRenderTarget();
    						var width = el.getWidth();
    						var height = el.getHeight();
    		    			
	        				var cirrusFlash = component.getApplication().getBaseUrl()+'resources/cirrus/flash/Cirrus.swf';
	        				component.add({
	        					xtype: 'flash',
	        					id: appVars.id,
	        					url: cirrusFlash,
	        					width: width,
	        					height: height,
	        					flashVars: appVars,
	        					flashParams: {
									menu: 'false',
									scale: 'showall',
									allowScriptAccess: 'always',
									bgcolor: '#222222',
									wmode: 'opaque'
	        		            }
	        				});
	        				
	        				component.cirrusFlashApp = Ext.get(appVars.id).first().dom;
    					} else {
    						setTimeout(loadFlash, 50, component);
    					}
        			}
    				loadFlash(this);
    				
    			}, this);
    		} else {
    			var el = this.getLayout().getRenderTarget();
    			el.update(""); // make sure to clear existing contents (especially for re-layout)
    	    	var width = el.getWidth();
				var height = el.getHeight();
				this.setVisLayout(
					d3.layoutCloud()
						.size([width, height])
						.overflow(true)
						.padding(1)
						.rotate(function(d) { return this.getApplication().getFeatureForTerm('orientation', d.text); }.bind(this))
						.spiral('archimedean')
						.font(function(d) { return this.getApplication().getFeatureForTerm('font', d.text); }.bind(this))
						.fontSize(function(d) {return d.fontSize; }.bind(this))
						.text(function(d) { return d.text; })
						.on('end', this.draw.bind(this))
				);
				
				var svg = d3.select(el.dom).append('svg').attr('id',this.getCirrusId()).attr('class', 'cirrusGraph').attr('width', width).attr('height', height);
				this.setVis(svg.append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')'));
				
				if (this.getTip() === undefined) {
					this.setTip(Ext.create('Ext.tip.Tip', {}));
				}
    		}
    	}
    },
    
    buildFromTerms: function() {
		var terms = this.getTerms();
    	if (this.rendered && terms) {
    		if (this.getApiParam('cirrusForceFlash') === true) {
    			if (this.cirrusFlashApp !== undefined && this.cirrusFlashApp.clearAll !== undefined) {
	    			var words = [];
	    			for (var i = 0; i < terms.length; i++) {
	    				var t = terms[i];
	    				if (!t.text && t.term) {t.text=t.term;}
	    				words.push({word: t.text, size: t.rawFreq, label: t.rawFreq});
	    			}
	    			this.cirrusFlashApp.clearAll();
	    			this.cirrusFlashApp.addWords(words);
	    			this.cirrusFlashApp.arrangeWords();
    			} else {
    				Ext.defer(this.buildFromTerms, 50, this);
    			}
    		} else {
	    		var minSize = 1000;
	    		var maxSize = -1;
	    		for (var i = 0; i < terms.length; i++) {
	    			var size = terms[i].rawFreq;
	    			if (size < minSize) minSize = size;
	    			if (size > maxSize) maxSize = size;
	    		}
	    		this.setSmallestWordSize(minSize);
	    		this.setLargestWordSize(maxSize);
	    		
	    		// set the relative sizes for each word (0.0 to 1.0), then adjust based on available area
	    		this.setRelativeSizes();
	    		this.setAdjustedSizes();

	//    		var fontSizer = d3.scalePow().range([10, 100]).domain([minSize, maxSize]);

	    		this.getVisLayout().words(terms).start();
    		}
    	} else {
    		Ext.defer(this.buildFromTerms, 50, this);
    	}
    },
    
    draw: function(words, bounds) {
    	var panel = this;
    	var el = this.getLayout().getRenderTarget();
    	var width = this.getVisLayout().size()[0];
    	var height = this.getVisLayout().size()[1];
    	
    	var scale = bounds ? Math.min(
			width / Math.abs(bounds[1].x - width / 2),
			width / Math.abs(bounds[0].x - width / 2),
			height / Math.abs(bounds[1].y - height / 2),
			height / Math.abs(bounds[0].y - height / 2)
    	) / 2 : 1;
    	
		var t = d3.transition().duration(1000);
			
		var nodes = this.getVis().selectAll('text').data(words, function(d) {return d.text;});
		
		nodes.exit().transition(t)
			.style('font-size', '1px')
			.remove();

		var nodesEnter = nodes.enter().append('text')
			.text(function(d) { return d.text; })
			.attr('text-anchor', 'middle')
			.attr('data-freq', function(d) { return d.rawFreq; })
			.attr('transform', function(d) { return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')'; })
			.style('font-family', function(d) { return panel.getApplication().getFeatureForTerm('font', d.text); })
			.style('fill', function(d) { return panel.getApplication().getColorForTerm(d.text, true); })
			.style('font-size', '1px')
			.on('click', function(obj) {panel.dispatchEvent('termsClicked', panel, [obj.text]);})
			.on('mouseover', function(obj) {
				this.getTip().show();
			}.bind(this))
			.on('mousemove', function(obj) {
				var tip = this.getTip();
				tip.update(obj.text+': '+obj.rawFreq);
				var container = Ext.get(this.getCirrusId()).dom;
				var coords = d3.mouse(container);
				coords[1] += 30;
				tip.setPosition(coords);
			}.bind(this))
			.on('mouseout', function(obj) {
				this.getTip().hide();
			}.bind(this));
		
		var nodesUpdate = nodes.merge(nodesEnter);
		
		nodesUpdate.transition(t)
			.style('font-family', function(d) { return panel.getApplication().getFeatureForTerm('font', d.text); })
			.style('fill', function(d) { return panel.getApplication().getColorForTerm(d.text, true); })
			.attr('transform', function(d) { return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')'; })
			.style('font-size', function(d) { return d.fontSize + 'px'; });
		
		this.getVis().transition(t).attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')scale(' + scale + ')');
    },
    
    map: function(value, istart, istop, ostart, ostop) {
		return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
	},
	
	calculateSizeAdjustment: function() {
		var terms = this.getTerms();
        if (terms !== undefined) {
			var el = this.getLayout().getRenderTarget();
			
	        var stageArea = el.getWidth() * el.getHeight();
	        if (stageArea < 100000) this.setMinFontSize(8);
	        else this.setMinFontSize(12);
        
	        var pixelsPerWord = stageArea / terms.length;
	        var totalWordsSize = 0;
	        for (var i = 0; i < terms.length; i++) {
	            var word = terms[i];
	            var wordArea = this.calculateWordArea(word);
	            totalWordsSize += wordArea;
	        }

	        this.setSizeAdjustment(stageArea / totalWordsSize);
        }
    },
    
    calculateWordArea: function(word) {
        var baseSize = Math.log(word.relativeSize * 10) * Math.LOG10E; // take the relativeSize (0.1 to 1.0), multiply by 10, then get the base-10 log of it
        var height = (baseSize + word.relativeSize) / 2; // find the average between relativeSize and the log
        var width = 0; //(baseSize / 1.5) * word.text.length;
        for (var i = 0; i < word.text.length; i++ ) {
            var letter = word.text.charAt(i);
            if (letter == 'f' || letter == 'i' || letter == 'j' || letter == 'l' || letter == 'r' || letter == 't') width += baseSize / 3;
            else if (letter == 'm' || letter == 'w') width += baseSize / (4 / 3);
            else width += baseSize / 1.9;
        }
        var wordArea = height * width;
        return wordArea;
    },
    
    setAdjustedSizes: function() {
    	this.calculateSizeAdjustment();
    	var terms = this.getTerms();
    	if (terms !== undefined) {
			for (var i = 0; i < terms.length; i++) {
				var term = terms[i];
				var adjustedSize = this.findNewRelativeSize(term);
				term.fontSize = adjustedSize > this.getMinFontSize() ? adjustedSize : this.getMinFontSize();
			}
    	}
    },
    
    setRelativeSizes: function() {
    	var terms = this.getTerms();
    	if (terms !== undefined) {
	    	for (var i = 0; i < terms.length; i++) {
	            var word = terms[i];
	            word.relativeSize = this.map(word.rawFreq, this.getSmallestWordSize(), this.getLargestWordSize(), 0.1, 1);
	        }
    	}
    },
    
    findNewRelativeSize: function(word) {
    	var areaMultiplier = this.getSizeAdjustment();
        var area = this.calculateWordArea(word) * areaMultiplier;
        // given the area = (x+6)*(2*x/3*y), solve for x
        var newRelativeSize = (Math.sqrt(6) * Math.sqrt(6 * Math.pow(word.text.length, 2) + area * word.text.length) - 6 * word.text.length) / (2 * word.text.length);
        return newRelativeSize;
    }
});
Ext.define('Voyant.panel.CollocatesGraph', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.collocatesgraph',
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		mode: undefined,
    		limit: 5,
    		stopList: 'auto',
    		terms: undefined,
    		context: 5,
    		centralize: undefined,
    		categories: undefined
    	},
		glyph: 'xf1e0@FontAwesome'
    },
    
    config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    	
    	nodeData: undefined,
    	linkData: undefined,
    	
    	visId: undefined,
    	vis: undefined,
    	visLayout: undefined,
    	nodes: undefined,
    	links: undefined,
    	zoom: undefined,
    	
    	dragging: false,
    	
    	contextMenu: undefined,
    	
    	currentNode: undefined,
    	
    	networkMode: undefined,
    	
    	graphStyle: {
    		keywordNode: {
    			normal: {
    				fill: '#c6dbef',
    				stroke: '#6baed6'
    			},
    			highlight: {
    				fill: '#9ecae1',
    				stroke: '#3182bd'
    			}
    		},
    		contextNode: {
    			normal: {
    				fill: '#fdd0a2',
    				stroke: '#fdae6b'
    			},
    			highlight: {
    				fill: '#fd9a53',
    				stroke: '#e6550d'
    			}
    		},
    		link: {
    			normal: {
    				stroke: '#000000',
    				strokeOpacity: 0.1
    			},
    			highlight: {
    				stroke: '#000000',
    				strokeOpacity: 0.5
    			}
    		}
    	},
    	
    	graphPhysics: {
    		defaultMode: {
	    		damping: 0.4, // 0 = no damping, 1 = full damping
	    		centralGravity: 0.1, // 0 = no grav, 1 = high grav
	    		nodeGravity: -50,  // negative = repel, positive = attract
				springLength: 100,
				springStrength: 0.25, // 0 = not strong, >1 = probably too strong
				collisionScale: 1.25 // 1 = default, 0 = no collision 
    		},
    		centralizedMode: {
    			damping: 0.4, // 0 = no damping, 1 = full damping
    			centralGravity: 0.1, // 0 = no grav, 1 = high grav
	    		nodeGravity: -1,  // negative = repel, positive = attract
				springLength: 200,
				springStrength: 1, // 0 = not strong, >1 = probably too strong
				collisionScale: 1 // 1 = default, 0 = no collision 
    		}
    	}
    },

    DEFAULT_MODE: 0,
    CENTRALIZED_MODE: 1,
    
    constructor: function(config) {
    	this.setNodeData([]);
    	this.setLinkData([]);
    	
    	this.setVisId(Ext.id(null, 'links_'));

    	this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        var me = this;
        Ext.apply(me, {
    		title: this.localize('title'),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                   xtype: 'querysearchfield'
                },{
                	text: me.localize('clearTerms'),
					glyph: 'xf014@FontAwesome',
                	handler: this.resetGraph,
                	scope: me
                },this.localize('context'),{
                	xtype: 'slider',
                	itemId: 'contextSlider',
                	minValue: 3,
                	value: 5,
                	maxValue: 30,
                	increment: 2,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getApiParam('context'));
                		},
                		changecomplete: function(slider, newValue) {
                			this.setApiParam('context', slider.getValue());
                			if (this.getNetworkMode() === this.DEFAULT_MODE) {
                    			var terms = this.getNodeData().map(function(node) { return node.term; });
                				if (terms.length > 0) {
                					this.setNodeData([]);
                					this.setLinkData([]);
                					this.refresh();
                					
                					this.loadFromQuery(terms);
                				}
                			}
                		},
                		scope: me
                	}
                }]
            }]
        });
        
        this.setContextMenu(Ext.create('Ext.menu.Menu', {
			renderTo: Ext.getBody(),
			items: [{
				xtype: 'box',
				itemId: 'label',
				margin: '5px 0px 5px 5px',
				html: ''
			},{
		        xtype: 'menuseparator'
			},{
				xtype: 'menucheckitem',
				text: 'Fixed',
				itemId: 'fixed',
				listeners: {
					checkchange: function(c, checked, e) {
						var node = this.getCurrentNode();
						if (node !== undefined) {
							var data = {
								fixed: checked
							};
							if (checked) {
								data.fx = node.x;
								data.fy = node.y;
							} else {
								data.fx = null;
								data.fy = null;
							}
							this.updateDataForNode(node.id, data);
						}
					},
					scope: this
				}
			},{
				xtype: 'button',
				text: 'Fetch Collocates',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
						if (this.getNetworkMode() === this.CENTRALIZED_MODE) {
							this.resetGraph();
							this.setNetworkMode(this.DEFAULT_MODE);
							this.setApiParam('centralize', undefined);
							node.start = 0;
							node.limit = this.getApiParam('limit');
						}
		    			this.fetchCollocatesForNode(node);
		    		}
				},
				scope: this
			},{
				xtype: 'button',
				text: 'Centralize',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
		    			this.doCentralize(node.term);
		    		}
					this.getContextMenu().hide();
				},
				scope: this
			},{
				xtype: 'button',
				text: 'Remove',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
						this.removeNode(node.id);
					}
					b.up('menu').hide();
				},
				scope: this
			}]
		}));
        
        this.on('loadedCorpus', function(src, corpus) {
			if (this.isVisible()) {
				this.initLoad();
			}
        }, this);
        
        this.on('activate', function() { // load after tab activate (if we're in a tab panel)
			if (this.getCorpus()) {
			    if (this.getNodeData().length === 0) { // only initLoad if there isn't already data
			        Ext.Function.defer(this.initLoad, 100, this);
			    }
			}
    	}, this);
        
        this.on('query', function(src, query) {this.loadFromQuery(query);}, this);
        
        this.on('resize', function(panel, width, height) {
        	var vis = Ext.get(this.getVisId());
        	if (vis) {
        		var el = this.body;//this.getLayout().getRenderTarget();
            	var elHeight = el.getHeight();
            	var elWidth = el.getWidth();
            	
        		vis.el.dom.setAttribute('width', elWidth);
        		vis.el.dom.setAttribute('height', elHeight);
        		this.getVisLayout()
        			.force('x', d3.forceX(elWidth/2))
	    			.force('y', d3.forceY(elHeight/2));
//        			.alpha(0.5).restart(); // restarting physics messes up zoomToFit
        		
        		Ext.Function.defer(this.zoomToFit, 100, this);
 //       		this.zoomToFit();
        	}
		}, this);
        
        me.callParent(arguments);

    },
    
    initLoad: function() {
		this.initGraph();
		this.setNetworkMode(this.DEFAULT_MODE);
		
		if (this.getApiParam('centralize')) {
			this.setNetworkMode(this.CENTRALIZED_MODE);
			var term = this.getApiParam('centralize');
			this.doCentralize(term);
		} else {
			var limit = 3;
			var query = this.getApiParam('query');
			if (query !== undefined) {
				limit = Ext.isArray(query) ? query.length : query.split(',').length;
			}
			this.getCorpus().getCorpusTerms({autoLoad: false}).load({
				params: {
					limit: limit,
					query: query,
					stopList: this.getApiParam('stopList')
				},
			    callback: function(records, operation, success) {
			    	if (success) {
			    		this.loadFromCorpusTermRecords(records);
			    	}
			    },
			    scope: this
	    	});
		}
    },
    
    resetGraph: function() {
		this.setNodeData([]);
    	this.setLinkData([]);
		this.setNetworkMode(this.DEFAULT_MODE);
		this.refresh();
    },
    
    loadFromQuery: function(query) {
    	if (Ext.isArray(query) && query.length==0) {
    		this.setApiParam("query", undefined);
    		this.resetGraph();
    		return;
    	}
    	this.setApiParams({
    		mode: 'corpus',
    		query: query
    	});
    	var params = this.getApiParams();
    	(Ext.isString(query) ? [query] : query).forEach(function(q) {
        	this.getCorpus().getCorpusCollocates({autoLoad: false}).load({
        		params: Ext.apply(Ext.clone(params), {query: q}),
        		callback: function(records, operations, success) {
        			if (success) {
        				this.loadFromCorpusCollocateRecords(records);
        			}
        		},
        		scope: this
        	});
    	}, this);
    },
    
    loadFromCorpusTermRecords: function(corpusTerms) {
    	if (Ext.isArray(corpusTerms) && corpusTerms.length>0) {
    		var terms = [];
    		corpusTerms.forEach(function(corpusTerm) {
    			terms.push(corpusTerm.getTerm());
    		});
    		this.loadFromQuery(terms);
    	}
    },
    
    loadFromCorpusCollocateRecords: function(records, keywordId) {
    	if (Ext.isArray(records)) {
    		var start = this.getApiParam('limit');
    		
    		var el = this.getLayout().getRenderTarget();
    		var cX = el.getWidth()/2;
    		var cY = el.getHeight()/2;
    		
    		var existingKeys = {};
    		this.getNodeData().forEach(function(item) {
    			existingKeys[item.id] = true;
    		}, this);
    		
    		var newNodes = [];
    		var newLinks = [];
    		
    		records.forEach(function(corpusCollocate, index) {
    			var term = corpusCollocate.getTerm();
    			var contextTerm = corpusCollocate.getContextTerm();
    			var termFreq = corpusCollocate.getKeywordRawFreq();
    			var contextFreq = corpusCollocate.getContextTermRawFreq();
    			
    			var termValue = termFreq;
    			var contextValue = contextFreq;
    			if (this.getNetworkMode() === this.CENTRALIZED_MODE) {
    				termValue = 0;
    				contextValue = Math.log(contextFreq);
    			}
    			
    			var termEntry = undefined;
    			var contextTermEntry = undefined;
    			
    			if (index == 0) { // only process keyword once
    				if (keywordId === undefined) keywordId = this.idGet(term);
	    			if (existingKeys[keywordId] !== undefined) {
	    				this.updateDataForNode(keywordId, {
	    					title: term+' ('+termFreq+')',
	    					type: 'keyword',
	    					value: termValue
	    				});
	    			} else {
	    				existingKeys[keywordId] = true;
	    				
	    				termEntry = {
		    				id: keywordId,
	    					term: term,
	    					title: term+' ('+termFreq+')',
	    					type: 'keyword',
	    					value: termValue,
	    					start: start,
	    					fixed: false,
	    					x: cX,
	    					y: cY
						};
	    				newNodes.push(termEntry);
	    			}
				}
    			
    			if (term != contextTerm) {
	    			var contextId = this.idGet(contextTerm);
	    			if (existingKeys[contextId] !== undefined) {
	    			} else {
	    				existingKeys[contextId] = true;
	    				
	    				contextTermEntry = {
    	    				id: contextId,
    	    				term: contextTerm,
        					title: contextTerm+' ('+contextFreq+')',
        					type: 'context',
        					value: contextValue,
        					start: 0,
        					fixed: false,
	    					x: cX,
	    					y: cY
    					};
	    				newNodes.push(contextTermEntry);
	    			}
	    			
	    			var existingLink = null;
	    			var linkData = this.getLinkData();
	    			for (var i = 0; i < linkData.length; i++) {
	    				var link = linkData[i];
	    				if ((link.source.id == keywordId && link.target.id == contextId) || (link.source.id == contextId && link.target.id == keywordId)) {
	    					existingLink = link;
	    					break;
	    				}
	    			}

	    			var linkValue = corpusCollocate.getContextTermRawFreq();
	    			if (existingLink === null) {
	    				newLinks.push({source: keywordId, target: contextId, value: linkValue, id: keywordId+'-'+contextId});
	    			} else if (existingLink.value < linkValue) {
//	    				existingLink.value = linkValue;
	    			}
    			}
    		}, this);
    		
    		this.setNodeData(this.getNodeData().concat(newNodes));
    		this.setLinkData(this.getLinkData().concat(newLinks));
    		
    		this.refresh();		
    	}
    },
    
    idGet: function(term) {
    	return term.replace(/\W/g, '_');
    },
    
    updateDataForNode: function(nodeId, dataObj) {
    	var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				Ext.apply(data[i], dataObj);
				break;
			}
		}
    },
    
    removeNode: function(nodeId, removeOrphans) {
    	var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				data.splice(i, 1);
				break;
			}
		}
		
		data = this.getLinkData();
		for (var i = data.length-1; i >= 0; i--) {
			if (data[i].source.id === nodeId || data[i].target.id === nodeId) {
				data.splice(i, 1);
			}
		}
		
		
		this.setApiParam("query", Ext.Array.remove(Ext.Array.from(this.getApiParam("query")), nodeId));
		
		if (removeOrphans) {
			// TODO
		}
		
		this.refresh();
    },
    
    doCentralize: function(term) {
    	this.setApiParam("centralize",term);
    	this.resetGraph();
    	
    	this.setNetworkMode(this.CENTRALIZED_MODE);
    	
    	var data = {
			id: this.idGet(term),
			term: term,
			title: term+' ('+1+')',
			type: 'keyword',
			value: 1000,
			start: 0
		};
		this.setNodeData([data]);
		this.refresh();
		
		var centralizeLimit = 150;
		var limit = this.getApiParam('limit');
		this.setApiParam('limit', centralizeLimit);
		this.fetchCollocatesForNode(data);
		this.setApiParam('limit', limit);
    },
    
    // called by setNetworkMode
    applyNetworkMode: function(mode) {
    	if (this.getVisLayout()) {
	    	if (mode === this.DEFAULT_MODE) {
	    		var physics = this.getGraphPhysics().defaultMode;
	    		this.getVisLayout()
	    			.velocityDecay(physics.damping)
		    		.force('link', d3.forceLink().id(function(d) { return d.id; }).distance(physics.springLength).strength(physics.springStrength))
					.force('charge', d3.forceManyBody().strength(physics.nodeGravity))
					.force('collide', d3.forceCollide(function(d) { return Math.sqrt(d.bbox.width * d.bbox.height) * physics.collisionScale; }));
	    		this.getVisLayout().force('x').strength(physics.centralGravity);
	    		this.getVisLayout().force('y').strength(physics.centralGravity);
	    	} else {
	    		var physics = this.getGraphPhysics().centralizedMode;
	    		this.getVisLayout()
	    			.velocityDecay(physics.damping)
		    		.force('link', d3.forceLink().id(function(d) { return d.id; }).distance(physics.springLength).strength(physics.springStrength))
					.force('charge', d3.forceManyBody().strength(function(d) {
						if (d.type === 'keyword') {
							return -10000;
						} else {
							return 0;
						}
					}))
					.force('collide', d3.forceCollide(function(d) {
						if (d.type === 'keyword') {
							return d.value;
						} else {
							return Math.sqrt(d.bbox.width * d.bbox.height) * physics.collisionScale;
						}
					}));
	    		this.getVisLayout().force('x').strength(physics.centralGravity);
	    		this.getVisLayout().force('y').strength(physics.centralGravity);
	    	}
    	}
    	
    	return mode; // need to return mode for it to actually be set
    },
    
    initGraph: function() {
    	var el = this.getLayout().getRenderTarget();
    	el.update('');
    	var width = el.getWidth();
    	var height = el.getHeight();
    	
    	this.setVisLayout(d3.forceSimulation()
    		.force('x', d3.forceX(width/2))
    		.force('y', d3.forceY(height/2))
			.on('tick', function() {
	    		this.getLinks()
	    			.attr('x1', function(d) { return d.source.x; })
	    			.attr('y1', function(d) { return d.source.y; })
	    			.attr('x2', function(d) { return d.target.x; })
	    			.attr('y2', function(d) { return d.target.y; });
	//    		this.getLinks().attr('d', function(d) {
	//				return 'M' + d[0].x + ',' + d[0].y
	//						+ 'S' + d[1].x + ',' + d[1].y
	//						+ ' ' + d[2].x + ',' + d[2].y;
	//			});
	    		this.getNodes().attr('transform', function(d) {
	    			var x = d.x;
	    			var y = d.y;
	    			if (this.getNetworkMode() === this.DEFAULT_MODE || d.type !== 'keyword') {
		    			x -= d.bbox.width*0.5;
		    			y -= d.bbox.height*0.5;
	    			} else {
	    				
	    			}
	    			return 'translate('+x+','+y+')';
	    		}.bind(this));
	    		
	    		if (!this.getDragging() && this.getVisLayout().alpha() < 0.075) {
	    			this.getVisLayout().alpha(-1); // trigger end event
	    		}
	    	}.bind(this))
	    	.on('end', function() {
        		Ext.Function.defer(this.zoomToFit, 100, this);
	    	}.bind(this))
		);
    	
    	var svg = d3.select(el.dom).append('svg').attr('id',this.getVisId()).attr('class', 'linksGraph').attr('width', width).attr('height', height);
    	var g = svg.append('g');
    	
    	var zoom = d3.zoom()
    		.scaleExtent([1/4, 4])
    		.on('zoom', function() {
				g.attr('transform', d3.event.transform);
			});
    	this.setZoom(zoom);
		svg.call(zoom);
		
		svg.on('click', function() {
    		this.getContextMenu().hide();
    	}.bind(this));
    	
    	this.setLinks(g.append('g').attr('class', 'links').selectAll('.link'));
    	this.setNodes(g.append('g').attr('class', 'nodes').selectAll('.node'));
		this.setVis(g);
    },
    
    resetGraph: function() {
	    this.setNodeData([]);
		this.setLinkData([]);
		this.refresh();
    },
    
    refresh: function() {
    	var me = this;
    	
    	var nodeData = this.getNodeData();
    	var linkData = this.getLinkData();
    	
//    	var nodeMap = d3.map(nodeData, function(d) { return d.id; });
//    	var bilinks = [];
//    	linkData.forEach(function(link) {
//    		var s = link.source = nodeMap.get(link.source);
//    		var t = link.target = nodeMap.get(link.target);
//    		var i = {};
//    		nodeData.push(i);
//    		linkData.push({source: s, target: i}, {source: i, target: t});
//    		bilinks.push([s,i,t]);
//    	});
    	
    	var link = this.getLinks().data(linkData, function(d) { return d.id; });
    	link.exit().remove();
		var linkEnter = link.enter().append('line')
			.attr('class', 'link')
			.attr('id', function(d) { return d.id; })
			.on('mouseover', me.linkMouseOver.bind(me))
			.on('mouseout', me.linkMouseOut.bind(me))
			.on('click', function(data) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.dispatchEvent('termsClicked', this, ['"'+data.source.term+' '+data.target.term+'"~'+this.getApiParam('context')]);
			}.bind(me))
//			.style('fill', 'none')
			.style('cursor', 'pointer')
			.style('stroke-width', function(d) {
				if (me.getNetworkMode() === me.DEFAULT_MODE) {
					return Math.max(1, Math.min(15, Math.sqrt(d.value)));
				} else {
					return 1;
				}
			});
			
		this.setLinks(linkEnter.merge(link));

    	var node = this.getNodes().data(nodeData, function(d) { return d.id; });
    	node.exit().remove();
    	var nodeEnter = node.enter().append('g')
			.attr('class', function(d) { return 'node '+d.type; })
			.attr('id', function(d) { return d.id; })
			.on('mouseover', me.nodeMouseOver.bind(me))
			.on('mouseout', me.nodeMouseOut.bind(me))
			.on('click', function(data) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.dispatchEvent('termsClicked', this, [data.term]);
			}.bind(me))
			.on('dblclick', function(data) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.fetchCollocatesForNode(data);
			}.bind(me))
			.on('contextmenu', function(d, i) {
				d3.event.preventDefault();
//				me.getTip().hide();
				var menu = me.getContextMenu();
				menu.queryById('label').setHtml(d.term);
    			menu.queryById('fixed').setChecked(d.fixed);
				menu.showAt(d3.event.pageX+10, d3.event.pageY-50);
			})
			.call(d3.drag()
				.on('start', function(d) {
					me.setDragging(true);
					if (!d3.event.active) me.getVisLayout().alpha(0.3).restart();
					d.fx = d.x;
					d.fy = d.y;
					d.fixed = true;
				})
				.on('drag', function(d) {
					me.getVisLayout().alpha(0.3); // don't let simulation end while the user is dragging
					d.fx = d3.event.x;
					d.fy = d3.event.y;
					if (me.isMasked()) {
			    		if (!me.isOffCanvas(d3.event.x, d3.event.y)) {
			    			me.unmask();
			    		}
			    	} else if (me.isOffCanvas(d3.event.x, d3.event.y)) {
			    		me.mask(me.localize('releaseToRemove'));
			    	}
				})
				.on('end', function(d) {
					me.setDragging(false);
//					if (!d3.event.active) me.getVisLayout().alpha(0);
					if (d.fixed != true) {
						d.fx = null;
						d.fy = null;
					}
					if (me.isOffCanvas(d3.event.x, d3.event.y)) {
	    	    		me.unmask();
	    	    		me.mask(me.localize('cleaning'));
	    	    		me.removeNode(d.id);
	    	    		me.unmask();
	    	    	}
				})
			);
    	
    	nodeEnter.append('title').text(function(d) { return d.title; });
    	
    	if (this.getNetworkMode() === this.DEFAULT_MODE) {
    		nodeEnter.append('rect')
				.style('stroke-width', 1)
				.style('stroke-opacity', 1);
    	} else {
    		nodeEnter.filter(function(d) { return d.type === 'keyword'; }).append('circle')
    			.style('stroke-width', 1)
    			.style('stroke-opacity', 1);
    	}
    	
    	nodeEnter.append('text')
			.attr('font-family', function(d) { return me.getApplication().getFeatureForTerm('font', d.term); })
			.attr('font-size', function(d) { return Math.max(10, Math.sqrt(d.value)); })
			.text(function(d) { return d.term; })
			.each(function(d) { d.bbox = this.getBBox(); }) // set bounding box for later use
			.style('cursor', 'pointer')
			.style('user-select', 'none')
			.attr('dominant-baseline', 'middle');
    	
    	this.setNodes(nodeEnter.merge(node));
    	
    	if (this.getNetworkMode() === this.DEFAULT_MODE) {
	    	this.getVis().selectAll('rect')
	    		.attr('width', function(d) { return d.bbox.width+16; })
				.attr('height', function(d) { return d.bbox.height+8; })
				.attr('rx', function(d) { return Math.max(2, d.bbox.height * 0.2); })
				.attr('ry', function(d) { return Math.max(2, d.bbox.height * 0.2); })
				.call(this.applyNodeStyle.bind(this));
	    	this.getVis().selectAll('text')
		    	.attr('dx', 8)
				.attr('dy', function(d) { return d.bbox.height*0.5+4; });
    	} else {
    		this.getVis().selectAll('circle')
    			.attr('r', function(d) { return Math.min(150, d.bbox.width); })
    			.call(this.applyNodeStyle.bind(this));
    		this.getVis().selectAll('text')
		    	.attr('dx', function(d) {
		    		if (d.type === 'keyword') {
		    			return -d.bbox.width*0.5;
			    	} else {
			    		return 8;
			    	}
	    		})
				.attr('dy', function(d) {
					if (d.type === 'keyword') {
						return 0;
					} else {
						return d.bbox.height*0.5+4;
					}
				});
    	}
    	this.getVis().selectAll('line').call(this.applyLinkStyle.bind(this));
    	
    	
    	this.getVisLayout().nodes(nodeData);
    	this.getVisLayout().force('link').links(linkData);
    	this.getVisLayout().alpha(1).restart();
    },
    
    isOffCanvas: function(x, y) {
    	var vis = Ext.get(this.getVisId());
    	return x < 0 || y < 0 || x > vis.getWidth() || y > vis.getHeight();
    },
    
    zoomToFit: function(paddingPercent, transitionDuration) {
    	var bounds = this.getVis().node().getBBox();
    	var width = bounds.width;
    	var height = bounds.height;
    	var midX = bounds.x + width/2;
    	var midY = bounds.y + height/2;
    	var svg = this.getVis().node().parentElement;
    	var svgRect = svg.getBoundingClientRect();
    	var fullWidth = svgRect.width;
    	var fullHeight = svgRect.height;
    	var scale = (paddingPercent || 0.8) / Math.max(width/fullWidth, height/fullHeight);
    	var translate = [fullWidth/2 - scale*midX, fullHeight/2 - scale*midY];
    	if (width<1) {return} // FIXME: something strange with spyral
     	
    	d3.select(svg)
    		.transition()
    		.duration(transitionDuration || 500)
    		.call(this.getZoom().transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale));
    },
 
    applyNodeStyle: function(sel, nodeState) {
		var state = nodeState === undefined ? 'normal' : nodeState;
    	sel.style('fill', function(d) { var type = d.type+'Node'; return this.getGraphStyle()[type][state].fill; }.bind(this));
    	sel.style('stroke', function(d) { var type = d.type+'Node'; return this.getGraphStyle()[type][state].stroke; }.bind(this));
    },
    
    applyLinkStyle: function(sel, linkState) {
    	var state = linkState === undefined ? 'normal' : linkState;
    	sel.style('stroke', function(d) { return this.getGraphStyle().link[state].stroke; }.bind(this));
    	sel.style('stroke-opacity', function(d) { return this.getGraphStyle().link[state].strokeOpacity; }.bind(this));
    },
    
    linkMouseOver: function(d) {
    	this.getVis().selectAll('line').call(this.applyLinkStyle.bind(this));
    	this.getVis().select('#'+d.id).call(this.applyLinkStyle.bind(this), 'highlight');
    },
    
    linkMouseOut: function(d) {
    	this.getVis().selectAll('line').call(this.applyLinkStyle.bind(this));
    },
    
    nodeMouseOver: function(d) {
    	this.setCurrentNode(d);
		
		this.getVis().selectAll('rect').call(this.applyNodeStyle.bind(this));
		
		this.getLinks().each(function(link) {
			var id;
			if (link.source.id == d.id) {
				id = link.target.id;
			} else if (link.target.id == d.id) {
				id = link.source.id;
			}
			if (id !== undefined) {
				this.getVis().select('#'+id+' rect').call(this.applyNodeStyle.bind(this), 'highlight');
				this.getVis().select('#'+link.id).call(this.applyLinkStyle.bind(this), 'highlight');
			}
		}.bind(this));
		
		this.getVis().select('#'+d.id+' rect')
			.style('stroke-width', 3)
			.call(this.applyNodeStyle.bind(this), 'highlight');
    },
    
    nodeMouseOut: function(d) {
    	if (!this.getContextMenu().isVisible()) {
			this.setCurrentNode(undefined);
		}
		
		this.getVis().selectAll('rect')
			.style('stroke-width', 1)
			.call(this.applyNodeStyle.bind(this));
		
		this.getVis().selectAll('line')
			.call(this.applyLinkStyle.bind(this));
    },
    
    fetchCollocatesForNode: function(d) {
    	var limit = this.getApiParam('limit');
    	var query = this.getApiParam("query");
    	
    	var query = Ext.Array.from(this.getApiParam("query"));
    	Ext.Array.include(query, d.term)
		this.setApiParam("query", query);

    	var corpusCollocates = this.getCorpus().getCorpusCollocates({autoLoad: false});
    	corpusCollocates.load({
    		params: Ext.apply(this.getApiParams(), {query: d.term, start: d.start, limit: limit}),
    		callback: function(records, operation, success) {
    			if (success) {
    				this.updateDataForNode(d.id, {
    					start: d.start+limit
    				});
    	    		
    	    		this.loadFromCorpusCollocateRecords(records, d.id);
    			}
    		},
    		scope: this
    	});
    }
    
});
Ext.define('Voyant.panel.Contexts', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Voyant.data.store.Contexts'],
	alias: 'widget.contexts',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		stopList: 'auto',
    		context: 5,
    		expand: 50
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        var me = this;

        Ext.apply(me, { 
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : Ext.create("Voyant.data.store.ContextsBuffered", {
            	parentPanel: this,
            	proxy: {
            		extraParams: {
                    	stripTags: "all"            			
            		}
            	}
//            	sortOnLoad: true,
//            	sorters: {
//                    property: 'position',
//                    direction: 'ASC'
//            	}
            }),
    		selModel: {
    			type: 'rowmodel',
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		this.getApplication().dispatchEvent('termLocationClicked', this, selections);
                    	},
                    	scope: this
                    }
                }
            },
            plugins: [{ // the expander slider assumes there's only one plugin, needs to be updated if changed
                ptype: 'rowexpander',
                rowBodyTpl : new Ext.XTemplate('')
            }],
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }, this.localize('context'), {
                	xtype: 'slider',
                	minValue: 5,
                	value: 5,
                	maxValue: 50,
                	increment: 5,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(me.getApiParam('context'));
                		},
                		changecomplete: function(slider, newValue) {
                			me.setApiParam("context", slider.getValue());
           		        	me.getStore().clearAndLoad({params: me.getApiParams()});
                		}
                	}
                }, this.localize('expand'), {
                	xtype: 'slider',
                	minValue: 5,
                	value: 5,
                	maxValue: 500,
                	increment: 10,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(me.getApiParam('expand'));
                		},
                		changecomplete: function(slider, newValue) {
                			me.setApiParam('expand', newValue);
                			var view = me.getView();
                			var recordsExpanded = me.plugins[0].recordsExpanded;
                			var store = view.getStore();
                			for (var id in recordsExpanded) {
                				var record = store.getByInternalId(id);
            					var row = view.getRow(record);
            					var expandRow = row.parentNode.childNodes[1];
                				if (recordsExpanded[id]) {
                					view.fireEvent("expandbody", row, record, expandRow, {force: true});
                				} else {
                					Ext.fly(expandRow).down('.x-grid-rowbody').setHtml('');
                				}
                			}
                		}
                	}
                },{
        			xtype: 'corpusdocumentselector'
        		}]
            }],
    		columns: [{
    			text: this.localize("document"),
    			toolTip: this.localize("documentTip"),
                width: 'autoSize',
        		dataIndex: 'docIndex',
                sortable: true,
                renderer: function (value, metaData, record, rowIndex, colIndex, store) {
                	return store.getCorpus().getDocument(value).getTinyLabel();
                }
            },{
    			text: this.localize("left"),
    			tooltip: this.localize("leftTip"),
    			align: 'right',
        		dataIndex: 'left',
                sortable: true,
                flex: 1
            },{
    			text: this.localize("term"),
    			tooltip: this.localize("termTip"),
        		dataIndex: 'term',
                sortable: true,
                width: 'autoSize'
            },{
    			text: this.localize("right"),
    			tooltip: this.localize("rightTip"),
        		dataIndex: 'right',
                sortable: true,
                flex: 1
            },{
    			text: this.localize("position"),
    			tooltip: this.localize("positionTip"),
        		dataIndex: 'position',
                sortable: true,
                hidden: true,
                flex: 1
            }],
            listeners: {
            	scope: this,
				corpusSelected: function() {
					if (this.getStore().getCorpus()) {
						this.setApiParams({docId: undefined, docIndex: undefined})
						this.getStore().clearAndLoad()
					}
				},
				
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined})
					this.getStore().clearAndLoad()
				},

            	documentSegmentTermClicked: {
	           		 fn: function(src, documentSegmentTerm) {
	           			 if (!documentSegmentTerm.term) {return;}
	           			 params = {query: documentSegmentTerm.term};
	           			 if (documentSegmentTerm.docId) {
	           				 params.docId = documentSegmentTerm.docId;
	           			 }
	           			 else {
	           				 // default to first document
	           				 params.docIndex = documentSegmentTerm.docIndex ?  documentSegmentTerm.docIndex : 0;
	           			 }
	           			 this.setApiParams(params);
	       	        	if (this.isVisible()) {
	       		        	this.getStore().clearAndLoad()
	       	        	}
	           		 },
	           		 scope: this
            	},
	           	 documentIndexTermsClicked: {
	           		 fn: function(src, documentIndexTerms) {
	           			// this isn't quite right, since we want every term associated with a docIndex, but for now it will do
	           			var queriesHash = {};
	           			var queries = [];
	           			var docIndexHash = {};
	           			var docIndex = [];
	           			documentIndexTerms.forEach(function(item) {
	           				if (!queriesHash[item.term]) {
	           					queries.push(item.term);
	           					queriesHash[item.term]=true;
	           				}
	           				if (!docIndexHash[item.docIndex]) {
	           					docIndex.push(item.docIndex);
	           					docIndexHash[item.docIndex]=true;
	           				}
	           			});
	       	        	this.setApiParams({
	       	        		docId: undefined,
	       	        		docIndex: docIndex,
	       	        		query: queries
	       	        	});
	       	        	if (this.isVisible()) {
	       		        	this.getStore().clearAndLoad({params: this.getApiParams()});
	       	        	}
	           		 },
	           		 scope: this
	           	 },
                 afterrender: function(me) {
                	 me.getView().on('expandbody', function( rowNode, record, expandRow, eOpts ) {
                		 if (expandRow.innerText==="" || (eOpts && eOpts.force)) {
                	            var store = Ext.create("Voyant.data.store.Contexts", {
                	            	stripTags: "all",
                	            	corpus: me.getStore().getCorpus()
                	            });
                	            var data = record.getData();
                	            store.load({
                	            	params: {
                    	            	query: data.query,
                    	            	docIndex: data.docIndex,
                    	            	position: data.position,
                    	            	limit: 1,
                    	            	context: me.getApiParam('expand')
                	            	},
                	                callback: function(records, operation, success) {
                	                	if (success && records.length==1) {
                	                		data = records[0].getData();
                	                		Ext.fly(operation.expandRow).down('.x-grid-rowbody').setHtml(data.left + " <span class='word keyword'>" + data.middle + "</span> " + data.right);
                	                	}
                	                },
                	                expandRow: expandRow
                	            });
                	            
                		 }
                	 });
                 }

            }
        });
        
        me.on("loadedCorpus", function(src, corpus) {
        	if (this.hasCorpusAccess(corpus)==false) {
        		this.mask(this.localize('limitedAccess'), 'mask-no-spinner');
        	}
        	else {
        		var corpusTerms = corpus.getCorpusTerms({autoLoad: false});
        		corpusTerms.load({
        		    callback: function(records, operation, success) {
        		    	if (success && records.length>0) {
        		    		this.setApiParam("query", [records[0].getTerm()]);
        		    		this.getStore().clearAndLoad({params: this.getApiParams()});
        		    	}
        		    },
        		    scope: me,
        		    params: {
        				limit: 1,
        				query: this.getApiParam("query"),
        				stopList: this.getApiParam("stopList"),
        				forTool: 'contexts'
        			}
            	});
        	}
        });
        
        me.on("query", function(src, query) {
        	this.setApiParam('query', query);
        	this.getStore().clearAndLoad({params: this.getApiParams()});
        }, me);
        
        me.on("documentTermsClicked", function(src, documentTerms) {
        	var documentIndexTerms = [];
        	documentTerms.forEach(function(documentTerm) {
        		documentIndexTerms.push({
        			term: documentTerm.getTerm(),
        			docIndex: documentTerm.getDocIndex()
        		});
        	});
        	this.fireEvent("documentIndexTermsClicked", this, documentIndexTerms);
        });
        
        me.on("termsClicked", function(src, terms) {
        	var documentIndexTerms = [];
        	if (Ext.isString(terms)) {terms = [terms];}
        	terms.forEach(function(term) {
        		if (term.docIndex !== undefined) {
            		documentIndexTerms.push({
            			term: term.term,
            			docIndex: term.docIndex
            		});
        		}
        	});
        	if (documentIndexTerms.length > 0) {
        		this.fireEvent("documentIndexTermsClicked", this, documentIndexTerms);
        	}
        });

    	me.callParent(arguments);
     }
     
});
Ext.define('Voyant.panel.CorpusCollocates', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.corpuscollocates',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		context: 5,
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		sort: 'contextTermRawFreq'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	options: {xtype: 'stoplistoption'}
    },
    constructor: function(config) {
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.isVisible()) {
    			this.loadFromApis();
    		}
    	});
    	
    	if (config.embedded) {
//    		var cls = Ext.getClass(config.embedded).getName();
//    		if (cls=="Voyant.data.store.DocumentTerms" || cls=="Voyant.data.model.Document") {
//    			this.fireEvent('loadedCorpus', this, config.embedded.getCorpus())
//    		}
    	}
    	else if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus)
    	}
    	
    	this.on("corpusTermsClicked", function(src, terms) {
    		if (this.getStore().getCorpus()) { // make sure we have a corpus
        		var query = [];
        		terms.forEach(function(term) {
        			query.push(term.get("term"));
        		})
        		this.setApiParams({
        			query: query,
        			docId: undefined,
        			docIndex: undefined
        		});
        		if (this.isVisible()) {
            		this.loadFromApis();
        		}
    		}
    	});
    	
    	this.on("documentsClicked", function(src, documents) {
    		var docIds = [];
    		documents.forEach(function(doc) {docIds.push(doc.get('id'))});
    		this.setApiParams({
    			docId: docIds,
    			docid: undefined,
    			query: undefined
    		})
    		if (this.isVisible()) {
        		this.loadFromApis();
    		}
    	});
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {this.loadFromApis()}
    	}, this)
    	
    	this.on("query", function(src, query) {
    		this.setApiParam("query", query);
    		this.getStore().getProxy().setExtraParam("query", query);
    		this.loadFromApis();
    	}, this)
    },
    
    loadFromApis: function() {
    	if (this.getStore().getCorpus()) {
    		if (this.getApiParam('query')) {
    			this.getStore().clearAndLoad({params: this.getApiParams()});
    		}
    		else {
				var corpusTerms = this.getStore().getCorpus().getCorpusTerms({
					leadingBufferZone: 0,
					autoLoad: false
				});
        		corpusTerms.load({
        		    callback: function(records, operation, success) {
        		    	if (success) {
        		    		var terms = [];
        		    		records.forEach(function(term) {
        		    			terms.push(term.getTerm());
        		    		})
        		    		this.getStore().getProxy().setExtraParam("query", terms);
        		    		this.setApiParam('query', terms);
        		    		this.loadFromApis();
        		    	}
        		    },
        		    scope: this,
        		    params: {
        				limit: 10,
        				stopList: this.getApiParam("stopList")
        			}
            	});

    		}
    	}
    },
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.CorpusCollocatesBuffered", {parentPanel: this});
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		var terms = [];
                    		var context = this.getApiParam("context")
                    		selections.forEach(function(selection) {
                    			terms.push('"'+selection.getKeyword()+" "+selection.getContextTerm()+'"~'+context)
                    		})
                    		this.getApplication().dispatchEvent('termsClicked', this, terms);
                    	},
                    	scope: this
                    }
                }
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }, this.localize('context'), {
                	xtype: 'slider',
                	minValue: 1,
                	value: 5,
                	maxValue: 30,
                	increment: 2,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(me.getApiParam('context'))
                		},
                		changecomplete: function(slider, newValue) {
                			me.setApiParam("context", slider.getValue());
							me.loadFromApis();
                		}
                	}
                },{
        			xtype: 'corpusdocumentselector'
        		}]
            }],
    		columns: [{
    			text: this.localize("term"),
        		dataIndex: 'term',
            	tooltip: this.localize("termTip"),
                sortable: true,
                flex: 1
            },{
    			text: this.localize("rawFreq"),
        		dataIndex: 'rawFreq',
            	tooltip: this.localize("termRawFreqTip"),
                sortable: true,
                width: 'autoSize',
                hidden: true
            },{
            	text: this.localize("contextTerm"),
            	dataIndex: 'contextTerm',
            	tooltip: this.localize("contextTermTip"),
            	flex: 1,
            	sortable: true
            },{
            	text: this.localize("contextTermRawFreq"),
            	tooltip: this.localize("contextTermRawFreqTip"),
            	dataIndex: 'contextTermRawFreq',
            	width: 'autoSize',
            	sortable: true
            }/*,{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize('trendTip'),
                width: 120,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline'
                }
            }*/],
            
            listeners: {
				scope: this,
            	termsClicked: function(src, terms) {
					if (this.getStore().getCorpus()) { // make sure we have a corpus
						var queryTerms = [];
						terms.forEach(function(term) {
							if (Ext.isString(term)) {queryTerms.push(term);}
							else if (term.term) {queryTerms.push(term.term);}
							else if (term.getTerm) {queryTerms.push(term.getTerm());}
						});
						if (queryTerms.length > 0) {
							this.setApiParams({
								docIndex: undefined,
								docId: undefined,
								query: queryTerms
							});
							if (this.isVisible()) {
								this.loadFromApis();
							}
						}
					}
				},

				corpusSelected: function() {
					if (this.getStore().getCorpus()) {
						this.setApiParams({docId: undefined, docIndex: undefined})
						this.loadFromApis();
					}
				},
				
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined});
					this.loadFromApis();
				}
            }
        });

        me.callParent(arguments);
        
        me.getStore().getProxy().setExtraParam("withDistributions", true);
        
    }
    
})
Ext.define('Voyant.widget.CorpusTermSummary', {
    extend: 'Ext.panel.Panel',
    mixins: ['Voyant.panel.Panel'],
    alias: 'widget.corpustermsummary',
    statics: {
        i18n: {
        },
        api: {
            stopList: 'auto',
            query: undefined,
            limit: 5
        }
    },
    config: {
        corpus: undefined,
        record: undefined, // Voyant.data.model.CorpusTerm
        collocatesStore: undefined,
        correlationsStore: undefined,
        phrasesStore: undefined,
        documentTermsStore: undefined
    },
    cls: 'corpus-term-summary',

    constructor: function(config) {
        if (config.record === undefined) {
            console.warn('CorpusTermSummary: no config.record!');
            return false;
        }
        
        Ext.apply(this, {
            items: {
                itemId: 'main',
                minHeight: 200,
                scrollable: true,
                margin: 5
            },
            dockedItems: {
                dock: 'bottom',
                xtype: 'toolbar',
                items: {
                    fieldLabel: this.localize('items'),
                    labelWidth: 40,
                    width: 120,
                    xtype: 'slider',
                    increment: 5,
                    minValue: 5,
                    maxValue: 59,
                    listeners: {
                        boxready: function(slider) {
                            slider.setValue(this.getApiParam('limit'));
                        },
                        changecomplete: function(slider, newvalue) {
                            this.setApiParam('limit', newvalue);
                            this.loadStuff();
                        },
                        scope: this
                    }
                }
            },
            listeners: {
                boxready: function() {
                    this.body.on('click', function(e) {
                        var target = e.getTarget(null, null, true);
                        if (target && target.dom.tagName == 'A') {
                            if (target.hasCls('corpus-type')) {
                                this.dispatchEvent('termsClicked', this, [target.getHtml()]);
                            }
                        }
                    }, this, {stopPropagation: true});
                    
                    this.getDockedItems().forEach(function(i) {
                       i.getEl().on('click', null, this, {stopPropagation: true}); // stop owner container from receiving clicks
                    });
                    
                    this.loadStuff();
                },
                scope: this
            }
        });
        
        Ext.applyIf(config, {
            title: this.localize('title')+config.record.getTerm()
        });

        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        
        var corpus = this.getRecord().store.getCorpus();
        this.setCorpus(corpus);

        this.setApiParam('query', this.getRecord().getTerm());
        
        this.setCollocatesStore(Ext.create('Voyant.data.store.CorpusCollocates', { corpus: corpus }));
        this.setCorrelationsStore(Ext.create('Voyant.data.store.TermCorrelations', { corpus: corpus }));
        this.setPhrasesStore(Ext.create('Voyant.data.store.CorpusNgrams', { corpus: corpus }));
        this.setDocumentTermsStore(Ext.create('Voyant.data.store.DocumentTerms', { corpus: corpus }));
        
    },

    loadStuff: function() {
        this.getComponent('main').removeAll();
        
        var docIndexes = [];
        for (var i = 0; i < this.getCorpus().getDocumentsCount(); i++) {
            docIndexes[i] = i;
        }
        this.getComponent('main').add({
            xtype: 'container',
            cls: 'section',
            layout: 'hbox',
            align: 'bottom',
            items: [{
                xtype: 'container',
                html: '<div class="header">'+this.localize('distribution')+'</div>'
            },{
                itemId: 'distLine',
                xtype: 'sparklineline',
                values: [],
                height: 20,
                width: 200
            }],
            listeners: {
                afterrender: function(container) {
                    container.mask(this.localize('loading'));
                    // TODO make distribution bins reflective of doc sizes
                    this.getDocumentTermsStore().load({
                        params: {
                            query: this.getApiParam('query'),
                            docIndex: docIndexes,
                            withDistributions: true,
                            bins: parseInt(this.getApiParam('limit'))*2
                        },
                        callback: function(records, op, success) {
                            if (success && records && records.length>0) {
                                var arrays = records.map(function(r) { return r.getDistributions(); });
                                var values = arrays.reduce(function(a,b) { return a.concat(b); });
                                this.down('#distLine').setValues(values);
                                container.unmask();
                            }
                        },
                        scope: this
                    });
                },
                scope: this
            }
        });
        
        this.addSection(
            this.localize('collocates'), this.getCollocatesStore(), this.getApiParams(),
            '<tpl for="." between="; "><a href="#" onclick="return false" class="corpus-type keyword" voyant:recordId="{term}">{term}</a><span style="font-size: smaller"> ({val})</span></tpl>',
            function(r) {
                return {term: r.getContextTerm(), val: r.getContextTermRawFreq()}
            }
        );
        
        this.addSection(
            this.localize('correlations'), this.getCorrelationsStore(), this.getApiParams(),
            '<tpl for="." between="; "><a href="#" onclick="return false" class="corpus-type keyword" voyant:recordId="{term}">{term}</a><span style="font-size: smaller"> ({val})</span></tpl>',
            function(r) {
                return {term: r.get('source-term'), val: r.get('source').rawFreq}
            }
        );
        
        this.addSection(
            this.localize('phrases'), this.getPhrasesStore(), Ext.apply({minLength: 3, sort: 'length'}, this.getApiParams()),
            '<tpl for="."><div>&ldquo;{phrase}&rdquo;</div></tpl>',
            function(r) {
                return {phrase: r.getTerm()}
            }
        );
    },
    
    addSection: function(title, store, params, template, mapping) {
        return this.getComponent('main').add({
            xtype: 'container',
            html: '<div class="header">'+title+'</div>',
            cls: 'section',
            listeners: {
                afterrender: function(container) {
                    container.mask(this.localize('loading'));
                    store.load({
                        params: params,
                        callback: function(records, op, success) {
                            if (success && records && records.length>0) {
                                container.unmask();
                                Ext.dom.Helper.append(container.getTargetEl().first().first(),
                                    new Ext.XTemplate('<div class="contents">'+template+'</div>').apply(records.map(mapping))
                                );
                            }
                        }
                    });
                },
                scope: this
            }
        });
    }
});

Ext.define('Voyant.panel.Correlations', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.correlations',
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		stopList: 'auto',
    		minInDocumentsCountRatio: 100
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	
    },
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        var me = this;

        Ext.apply(me, { 
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
    		store: Ext.create("Voyant.data.store.TermCorrelationsBuffered", {
            	parentPanel: this
	        }),

    		columns: [{
    			text: this.localize("source"),
    			tooltip: this.localize("sourceTip"),
        		dataIndex: 'source-term',
        		sortable: false
    		},{
                xtype: 'widgetcolumn',
                tooltip: this.localize("trendTip"),
                width: 100,
                dataIndex: 'source-distributions',
                widget: {
                    xtype: 'sparklineline'
                },
                text: ''
            },{
                xtype: 'widgetcolumn',
                tooltip: this.localize("trendTip"),
                width: 100,
                dataIndex: 'target-distributions',
                widget: {
                    xtype: 'sparklineline'
                },
                text: '',
                align: 'right'
            },{
    			text: this.localize("target"),
    			tooltip: this.localize("targetTip"),
        		dataIndex: 'target-term',
        		sortable: false
    		},{
    			text: this.localize("correlation"),
    			tooltip: this.localize("correlationTip"),
        		dataIndex: 'correlation'
    		},{
    			text: this.localize("significance"),
    			tooltip: this.localize("significanceTip"),
        		dataIndex: 'significance'
    		}],
    		

            listeners: {
            	scope: this,
				corpusSelected: function() {
					this.setApiParams({docIndex: undefined, docId: undefined});
	        		this.getStore().getProxy().setExtraParam('tool', 'corpus.CorpusTermCorrelations');
	        		this.getStore().load();
				},
				
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined})
	        		this.getStore().getProxy().setExtraParam('tool', 'corpus.DocumentTermCorrelations');
	        		this.getStore().load();
				}

            },
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                },{
                    xtype: 'totalpropertystatus'
                }, {
                	xtype: 'tbspacer'
                }, {
                	xtype: 'tbtext',
                	itemId: 'minInDocumentsCountRatioLabel',
                	text: me.localize('minInDocumentsCountRatioLabel')
                }, {
        			xtype: 'slider',
	            	increment: 5,
	            	minValue: 0,
	            	maxValue: 100,
	            	width: 75,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam("minInDocumentsCountRatio"))
	            			slider.up('toolbar').getComponent("minInDocumentsCountRatioLabel").setText(new Ext.XTemplate(me.localize("minInDocumentsCountRatioLabel")).apply([this.getApiParam("minInDocumentsCountRatio")]));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({minInDocumentsCountRatio: newvalue});
	            			slider.up('toolbar').getComponent("minInDocumentsCountRatioLabel").setText(new Ext.XTemplate(me.localize("minInDocumentsCountRatioLabel")).apply([newvalue]));
	            			this.getStore().load();
	            		},
	            		scope: this
	            	}
                },{
        			xtype: 'corpusdocumentselector'
        		}]
            }]
        });
        
        me.on("loadedCorpus", function(src, corpus) {
        	if (corpus.getDocumentsCount()==1) { // switch to documents mode
        		this.getStore().getProxy().setExtraParam('tool', 'corpus.DocumentTermCorrelations');
        	}
        	if (this.isVisible()) {
        		this.getStore().load();
        	}
        });
        
    	me.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {this.getStore().load();}
    	}, this)

    	me.on("query", function(src, query) {
        	this.setApiParam("query", query);
        	this.getStore().load();
        }, me);
        
        me.callParent(arguments);
     }
     
});
Ext.define('Voyant.panel.CorpusCreator', {
	extend: 'Ext.form.Panel',
	requires: ['Ext.form.field.File'],
	requires: ['Voyant.data.model.Corpus'],
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.corpuscreator',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		inputFormat: undefined,
    		language: undefined,
    		xmlDocumentsXpath: undefined,
    		xmlGroupByXpath: undefined,
    		xmlContentXpath: undefined,
    		xmlTitleXpath: undefined,
    		xmlAuthorXpath: undefined,
    		htmlGroupByQuery: undefined,
    		htmlDocumentsQuery: undefined,
    		htmlContentQuery: undefined,
    		htmlTitleQuery: undefined,
    		htmlAuthorQuery: undefined,
    		tokenization: undefined,
    		adminPassword: undefined,
    		accessPassword: undefined,
    		noPasswordAccess: undefined,
    		tableDocuments: undefined,
    		tableContent: undefined,
    		tableTitle: undefined,
    		tableAuthor: undefined,
    		title: undefined,
    		subTitle: undefined,
    		inputRemoveFrom: undefined,
    		inputRemoveFromAfter: undefined,
    		inputRemoveUntil: undefined,
    		inputRemoveUntilAfter: undefined
    	}
    },
    
    constructor: function(config) {
        this.callParent(arguments);
        config = config || {};
        var me = this;
    	this.mixins['Voyant.panel.Panel'].constructor.call(this, 
    			Ext.apply(config, {
    				includeTools: {
    					gear: true,
    					help: true,
    					language: this.getLanguageToolMenu()
    				}
    			})
    	);
    	
    },
    
    initComponent: function() {
        var me = this;

        Ext.apply(me, {
    		title: this.localize('title'),
    		width: 800,
    		frame: true,
    		padding: 10,
    		style: {
    		    borderColor: '#aaa',
    		    borderStyle: 'solid'
    		},
    		frameHeader: true,
    		layout: {
    			type: 'vbox',
    			align: 'stretch'
    		},
	    	dockedItems: [{
	    		xtype: 'toolbar',
                overflowHandler: 'scroller',
                dock: 'bottom',
    	    	buttonAlign: 'right',
//    	    	defaultButtonUI : 'default',
	    		items: [{
	    			text: me.localize('Open'),
                    glyph: 'xf115@FontAwesome', // not visible
	    			tooltip: me.localize('SelectExisting'),
	    			hidden: this.getCorpus()!=undefined,
	    			handler: function() {
	    				Ext.create('Ext.window.Window', {
	    				    title: me.localize('Open'),
	    				    layout: 'fit',
	    				    modal: true,
	    				    items: {  // Let's put an empty grid in just to illustrate fit layout
	    				        xtype: 'form',
	    				        submitEmptyText: false,
	    				        margin: '5,5,5,5',
	    				        items: {
	    				        	xtype: 'corpusselector'
//	    				            xtype:'combo',
//	    				            labelWidth: 150,
//	    				            fieldLabel:'Choose a corpus:',
//	    				            name:'corpus',
//	    				            queryMode:'local',
//	    				            store:[['shakespeare',"Shakespeare's Plays"],['austen',"Austen's Novels"]],				            
//	    				            forceSelection:true
	    				        },
	    				        buttons: [
	    				        	{
	    				        		text: me.localize('Open'),
	    			                    glyph: 'xf00c@FontAwesome',
	    				        		handler: function(btn) {
	    				        			var form = btn.up('form').getForm();
	    				        			var corpus = btn.up('form').getForm().getValues().corpus;
	    				        			if (corpus!='') {
	    				        				me.loadCorpus({corpus: corpus});
		    				        			btn.up('window').close();
	    				        			}
	    				        			else {
	    				    	        		Ext.Msg.show({
	    				    	        		    title: me.localize('SelectExisting'),
	    				    	        		    message: me.localize('PleaseSelectExisting'),
	    				    	        		    buttons: Ext.Msg.OK,
	    				    	        		    icon: Ext.Msg.ERROR
	    				    	        		});
	    				        			}
	    				        		},
	    				        		flex: 1
	    				            },{
	    				        		text: me.localize('cancel'),
	    			                    glyph: 'xf00d@FontAwesome',
	    				        		flex: 1,
	    				        		handler: function(btn) {
	    				        			btn.up('window').close();
	    				        		}
	    				        	}
	    				        ]
	    				    }
	    				}).show();
	    			}
	    		},{
    	        	xtype: 'fileuploadfield',
                    glyph: 'xf093@FontAwesome',
    	        	name: 'upload',
        	    	buttonOnly: true,
        	    	hideLabel: true,
		            ui: 'default-toolbar',
        	    	buttonText: me.localize('Upload'),
        	    	listeners: {
        	    		render: function(filefield) {
        	    			filefield.fileInputEl.dom.setAttribute('multiple', true);
        		        	Ext.tip.QuickTipManager.register({
       		                 target: filefield.getEl(),
       		                 text: me.localize('UploadLocal')
       		             	});
        	            },
        	            beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
        	            change: function(filefield, value) {
        	            	if (value) {
            	            	var form = filefield.up('form').getForm();
            	            	if (form.isValid()) {
            	            		var files = filefield.fileInputEl.dom.files;
            	            		var badFilesRe = /\.(png|gif|jpe?g|xls|mp[234a]|mpeg|exe|wmv|avi|ppt|mpg|tif|wav|mov|psd|wma|ai|bmp|pps|aif|pub|dwg|indd|swf|asf|mbd|dmg|flv)$/i;
            	            		var goodFilesRe = /\.(txt|pdf|html?|xml|docx?|rtf|pages|epub|odt|zip|jar|tar|gz|ar|cpio|bzip2|bz2|gzip|xlsx?)$/i;
            	            		var badFiles = [];
            	            		var unknownFiles = [];
            	            		for (var i = 0, len = files.length; i<len; i++) {
            	            			var filename = files[i].name;
            	            			if (badFilesRe.test(filename)) {
            	            				badFiles.push(filename.split("/").pop());
            	            			}
            	            			else if (!goodFilesRe.test(filename)) {
            	            				unknownFiles.push(filename.split("/").pop());
            	            			}
            	            		}
            	            		if (badFiles.length>0 || unknownFiles.length>0) {
            	            			var file = filefield;
            	            			Ext.Msg.show({
            	            				title: me.localize("fileTypesWarning"),
            	            				icon: Ext.MessageBox.ERROR,
            	            				message: me.localize('fileTypesMessage')+'<ul>' +
            	            					(badFiles.length > 0 ? ('<li>'+me.localize("badFiles") + badFiles.slice(0, 5).join(", ") + (badFiles.length>5 ? '' : '') + '</li>') : '') +
            	            					(unknownFiles.length>0 ? ('<li>' +me.localize("unknownFiles") + unknownFiles.slice(0, 5).join(", ") + (unknownFiles.length>5 ? '' : '') +'</li>') : '')+
            	            					'</ul>'+me.localize('sureContinue'),
            	            				buttons: Ext.Msg.YESNO,
            	            				fn: function(btn) {
            	            			        if (btn === 'yes') {
            	            			        	me.loadForm(form);
            	            			        }
            	            			        else {
            	            			        	file.reset(); // make sure we can trigger a change next time
            	            			        	file.fileInputEl.dom.setAttribute('multiple', true);
            	            			        }
            	            			    },
            	            				scope: form
            	            			});
            	            		}
            	            		else {
            	            			me.loadForm(form);
            	            		}
            	            	}
        	            	}
        	            }
        	    	}
	    		},'->', {
	    	    	xtype: 'button',
	    	    	scale: 'large',
        			glyph: 'xf00d@FontAwesome',
	    	    	text: this.localize('cancel'),
	    	    	hidden: this.getCorpus()==undefined,
	    	    	handler: function(btn) {
	    	        	var win = this.up("window");
	    	        	if (win && win.isFloating()) {
	    	        		win.close();
	    	        	}
	    	    	}
	    	    }, {
	    	    	xtype: 'button',
	    	    	scale: 'large',
                    glyph: 'xf00c@FontAwesome',
	    	    	text: this.localize('reveal'),
	    	    	ui: 'default',
	    	    	width: 200,
	    	    	handler: function(btn) {
	    	        	var input = btn.up('form').down('#input').getValue();
	    	        	if (input !== '') {
	    	        		var api = me.getApiParams();
	    	            	delete api.view;
	    	            	delete api.stopList;
	    	        		if (api.inputFormat && input.trim().indexOf("<")!==0) {
	    	        			Ext.Msg.confirm(me.localize('error'), me.localize('errorNotXmlContinue'), function(buttonId) {
	    	        				if (buttonId=='yes') {
				    	        		me.loadCorpus(Ext.apply(api, {input: input}));
	    	        				}
	    	        			}, me);
	    	        		}
	    	        		else {
		    	        		me.loadCorpus(Ext.apply(api, {input: input}));
	    	        		}
	    	        	}
	    	        	else {
	    	        		Ext.Msg.show({
	    	        		    title: me.localize('noTextProvided'),
	    	        		    message: me.localize('pleaseProvideText'),
	    	        		    buttons: Ext.Msg.OK,
	    	        		    icon: Ext.Msg.ERROR
	    	        		});
	    	        	}
	    	    	}
	    	    }]
	    	}],
	    	items: [{
	    		html: this.getInitialConfig().addTextLabel,
	    		hidden: this.getInitialConfig().addTextLabel==undefined
	    	},{
//	    		layout: 'fit',
	    		height: 100,
    	    	xtype: 'textareafield',
    	    	itemId: 'input',
    	    	emptyText: this.localize('emptyInput')
	    	}]
        });
        
        me.on("boxready", function(panel) {
        	var app = this.getApplication();
        	if (app.getAllowInput && app.getAllowInput()=="false") {
        		if (app.getNoAllowInputText && app.getNoAllowInputText().trim().length>0) {
        			Ext.defer(function() {
            			var parent = panel.up("container");
            			parent.removeAll(); // input box and copyright message
            			parent.add({
            	    		frame: false,
            	    		padding: 10,
            	    		style: {
            	    		    borderColor: '#aaa',
            	    		    borderStyle: 'solid'
            	    		},
            				html: app.getNoAllowInputText()
            			})
        			}, 100);
        		} else {
            		panel.hide();
            		Ext.create('Ext.window.Window', {
            		    layout: 'fit',
            		    header: false,
            		    modal: true,
            		    bodyPadding: 10,
            		    items: {  // Let's put an empty grid in just to illustrate fit layout
            		        html: "<p style='color: red;'>"+panel.localize('noAllowInputMessage')+"</p>"
            		    }
            		}).show();
        		}
        	}
        })

        me.callParent(arguments);
        
    },
    
    loadForm: function(form) {
    	var params = {tool: this.getCorpus() ? 'corpus.CorpusMetadata' : 'corpus.CorpusCreator'};
    	if (this.getCorpus()) {
    		Ext.apply(params, {
    			corpus: this.getCorpus().getId(),
    			addDocuments: true
    		})
    	};
    	var apiParams = this.getApiParams();
    	delete apiParams.view;
    	delete apiParams.stopList;
    	Ext.apply(params, apiParams);
    	var view = this.getApplication().getViewport();
		view.mask(this.localize('uploadingCorpus'));
		form.submit({
			url: this.getTromboneUrl(),
			params: params,
			failure: function(form, action) { // we always fail because of content-type
            	view.unmask();
				if (action.result && (action.result.corpus || action.result.stepEnabledCorpusCreator)) {
					var corpusParams = {corpus: action.result.corpus ? action.result.corpus.metadata.id : action.result.stepEnabledCorpusCreator.storedId};
					Ext.applyIf(corpusParams, apiParams); // adding title & subTitle here
					this.setCorpus(undefined)
					this.loadCorpus(corpusParams);
				} else {
					
					this.showResponseError("Unable to load corpus.", action.response)
				}
			},
			scope: this
		});
    },
   
    loadCorpus: function(params) {
    	if (this.getCorpus()) {
    		Ext.apply(params, {
    			corpus: this.getCorpus().getId(),
    			addDocuments: true
    		})
    	};
    	
    	var win = this.up("window");
    	if (win && win.isFloating()) {
    		win.close();
    	}
    	
		this.getApplication().loadCorpusFromParams(params);
    },
    
    showOptionsClick: function(panel) {
    	var me = panel;
    	if (me.optionsWin === undefined) {
    		me.optionsWin = Ext.create('Ext.window.Window', {
    			title: me.localize('gearWinTitle'),
    			closeAction: 'hide',
//    			width: 500,
    			layout: 'fit',
    			bodyPadding: 10,
    			items: [{
    				xtype: 'form',
    				defaultType: 'textfield',
        			maxHeight: me.getApplication().getViewport().getHeight()-300,
        			scrollable: true,
    				fieldDefaults: {
    					labelAlign: 'right',
    					labelWidth: 110,
    					width: 350
    				},
    				items: [
						{
						    xtype:'combo',
						    fieldLabel: me.localize('inputFormat'),
						    labelWidth: 90, // try to align with fieldset
						    name: 'inputFormat',
						    queryMode:'local',
						    store:[['',me.localize('inputFormatAuto')],['dtoc','DToC: Dynamic Table of Contexts'],['TEI',"TEI: Text Encoding Initative"],['TEI',"TEI Corpus"],['RSS',"Really Simple Syndication: RSS"]],
						    value: '',
						    listeners: {
						    	afterrender: {
						    		fn: function(combo) {
						    			var inputFormat = this.getApiParam('inputFormat');
						    			if (inputFormat) {
						    				combo.setValue(inputFormat);
						    			}
						    		},
						    		scope: me
						    	}
						    }
						},{
							xtype: 'container',
							html: '<p><i>'+new Ext.Template(me.localize('advancedOptionsText')).applyTemplate([me.getBaseUrl()+'docs/#!/guide/corpuscreator-section-xml'])+'</i></p>',
							width: 375
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-titles' target='voyantdocs'>"+me.localize('corpusOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('corpusTitle'),
									name: 'title'
								},{
									fieldLabel: me.localize('corpusSubTitle'),
									name: 'subTitle'
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-text' target='voyantdocs'>"+me.localize('textOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("textOptionsText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('inputRemoveUntil'),
									name: 'inputRemoveUntil'
								},{
									fieldLabel: me.localize('inputRemoveUntilAfter'),
									name: 'inputRemoveUntilAfter'
								},{
									fieldLabel: me.localize('inputRemoveFrom'),
									name: 'inputRemoveFrom'
								},{
									fieldLabel: me.localize('inputRemoveFromAfter'),
									name: 'inputRemoveFromAfter'
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-xml' target='voyantdocs'>"+me.localize('xmlOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("xmlOptionsText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('xpathContent'),
									name: 'xmlContentXpath'
								},{
									fieldLabel: me.localize('xpathTitle'),
									name: 'xmlTitleXpath'
								},{
									fieldLabel: me.localize('xpathAuthor'),
									name: 'xmlAuthorXpath'
								},{
									fieldLabel: me.localize('xpathDocuments'),
									name: 'xmlDocumentsXpath'
								},{
									fieldLabel: me.localize('xpathGroupBy'),
									name: 'xmlGroupByXpath'
								}
							]
						},,{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-html' target='voyantdocs'>"+me.localize('htmlOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+new Ext.Template(me.localize('htmlOptionsText')).applyTemplate([me.getBaseUrl()+'docs/#!/guide/corpuscreator-section-html'])+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('xpathContent'),
									name: 'htmlContentQuery'
								},{
									fieldLabel: me.localize('xpathTitle'),
									name: 'htmlTitleQuery'
								},{
									fieldLabel: me.localize('xpathAuthor'),
									name: 'htmlAuthorQuery'
								},{
									fieldLabel: me.localize('xpathDocuments'),
									name: 'htmlDocumentsQuery'
								},{
									fieldLabel: me.localize('xpathGroupBy'),
									name: 'htmlGroupByQuery'
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-tables' target='voyantdocs'>"+me.localize('tableOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [{
	    							xtype: 'container',
	    							html: '<p><i>'+new Ext.Template(me.localize('tableOptionsText')).applyTemplate([me.getBaseUrl()+'docs/#!/guide/corpuscreator-section-tables'])+'</i></p>',
	    							width: 375
	                        	},{
								    xtype:'combo',
									fieldLabel: me.localize('tableDocuments'),
								    name: 'tableDocuments',
								    queryMode:'local',
								    store:[['',me.localize('tableDocumentsTable')],['rows',me.localize('tableDocumentsRows')],['columns',me.localize("tableDocumentsColumns")]],
								    forceSelection:true,
								    value: ''
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("tableNoHeadersRowText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize("tableNoHeadersRow"),
									xtype: 'checkboxfield',
									name: 'tableNoHeadersRow',
									inputValue: "true"
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("tableContentText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('tableContent'),
									validator: function(val) {return me.validatePositiveNumbersCsv.call(me, val)},
									name: 'tableContent'
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("tableMetadataText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('tableAuthor'),
									validator: function(val) {return me.validatePositiveNumbersCsv.call(me, val)},
									name: 'tableAuthor'
								},{
									fieldLabel: me.localize('tableTitle'),
									validator: function(val) {return me.validatePositiveNumbersCsv.call(me, val)},
									name: 'tableTitle'
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-processing' target='voyantdocs'>"+me.localize('processingOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        items: [
								{
								    xtype:'combo',
								    fieldLabel: me.localize("language"),
								    name: 'language',
								    queryMode:'local', //?
								    store:[['',me._localizeClass(Voyant.widget.StopListOption, "auto")],['cn',me._localizeClass(Voyant.widget.StopListOption, "cn")],['bo',me._localizeClass(Voyant.widget.StopListOption, "bo")],['grc',me._localizeClass(Voyant.widget.StopListOption, "grc")]],
								    forceSelection:true,
								    value: ''
								},{
								    xtype:'combo',
								    fieldLabel: me.localize('tokenization'),
								    name: 'tokenization',
								    queryMode:'local', //?
								    store:[['',me.localize('tokenizationAuto')],['wordBoundaries',me.localize("tokenizationWordBoundaries")],['whitespace',me.localize("tokenizationWhitespace")]],
								    forceSelection:true,
								    value: ''
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-access-management' target='voyantdocs'>"+me.localize('accessOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("accessOptionsText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('adminPassword'),
									name: 'adminPassword'
								},{
									fieldLabel: me.localize('accessPassword'),
									name: 'accessPassword'
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("accessModeWithoutPasswordText")+'</i></p>',
	    							width: 375
	                            },{
								    xtype:'combo',
									fieldLabel: me.localize('accessModeWithoutPassword'),
								    name: 'noPasswordAccess',
								    queryMode:'local',
								    store:[['',me.localize('accessModeNonConsumptive')],['none',me.localize("accessModeNone")]],
								    forceSelection:true,
								    value: ''
								}
							]
						}
						
					]
    			}],
    			buttons: [{
    				text: me.localize('ok'),
    				handler: function(button, event) {
    					var win = button.findParentByType('window');
    					var form = win.down('form');
    					if (form.isValid()) {
        					var params = form.getValues();
        					me.setApiParams(params);
        					win.hide();
    					}
    					else {
    						me.showError({
    							message: me.localize("invalidForm")
    						})
    					}
    				}
    			},{
    				text: me.localize('cancel'),
    				handler: function(button, event) {
    					button.findParentByType('window').hide();
    				}
    			}]
    		});
    	}
    	me.optionsWin.show();
    },
    
    validatePositiveNumbersCsv: function(val) {
    	val = val.trim();
    	if (val.length>0) {
        	if (/[^\d,+ ]/.test(val)) {
        		return this.localize("numbersCommasOnly");
        	}
        	if (/\d\s+\d/.test(val)) {
        		return this.localize("numbersNeedCommas");
        	}
        	var numbers = val.split(/\s*[,+]\s*/), number;
        	for (var i=0, len=numbers.length; i<len; i++) {
        		number = numbers[i];
        		if (number.length==0) {
        			return this.localize("numberEmpty")
        		}
        		if (parseInt(number)==0) {
        			return this.localize("numberZero")
        		}
        	}
    	}
    	return true;
	}
    
});
Ext.define('Voyant.panel.DreamScape', {
    extend: 'Ext.Panel',
    xtype: 'dreamscape',
    mixins: ['Voyant.panel.Panel'],
    statics: {
        i18n: {
        },
        api: {
            stopList: 'auto',
            hide: [],
            author: undefined,
            title: undefined,
            keyword: undefined,
            pubDate: undefined,
            citiesMaxCount: 500,
            minPopulation: 10000,
            citiesMinFreq: 1,
            connectionsMaxCount: 2500,
            connectionsMinFreq: 1,
            millisPerAnimation: 2000,
            annotationsId: undefined,
            source: undefined,
            overridesId: undefined,
            filterHasLowerCaseForm: true,
            filterIsPersonName: true,
            preferredCoordinates: undefined
        },
        glyph: 'xf124@FontAwesome'
    },
    config: {
        map: undefined, // OL object, should be set during init
        overlay: undefined, // OL object, should be set during init
        contentEl: undefined, // EXTJS Element, where info is shown
        isOpenLayersLoaded: false,
        isArcLoaded: false,
        animationDelay: 25, // determines the delay between animation calls
        isProj4Loaded: false,
        projection: undefined,
        filterWidgets: new Ext.util.MixedCollection(),
        drawInteraction: undefined,
        drawMode: false,
        //currentAnnotation: undefined,
        baseLayers: {},
        annotations: undefined, // set during init if any values are stored, shouldn't be looked up (getAnnotations) after init
        annotationsLoadedIfAvailable: false, // check api and local storage,
        overrides: {}
    },

    html: '<div class="map"></div><div class="ticker"></div>',

    cls: 'dreamscape',

    constructor: function(config) {
        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        Ext.Loader.loadScript({
            url: this.getBaseUrl()+"resources/openlayers/ol.js",
            onLoad: function() {
                // Utility function to get layer by id
                if (ol.Map.prototype.getLayer === undefined) {
                    ol.Map.prototype.getLayer = function (id) {
                        var layer = undefined;
                        this.getLayers().forEach(function(lyr) {
                            if (id === lyr.get('id')) {
                                layer = lyr;
                            }
                        });
                        return layer;
                    }
                }
                this.setIsOpenLayersLoaded(true);
            },
            scope: this
        });
        Ext.Loader.loadScript({
            url: this.getBaseUrl()+"resources/dreamscape/arc.js",
            onLoad: function() {
                this.setIsArcLoaded(true);
            },
            scope: this
        });
        Ext.Loader.loadScript({
            url: "https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.4.4/proj4.js",
            onLoad: function() {
                this.setIsProj4Loaded(true);
            },
            scope: this
        });
        var annotationsId = this.getApiParam("annotationsId");
        if (annotationsId) {
            var me = this;
            Ext.Ajax.request({
                url: this.getTromboneUrl(),
                params: {
                    tool: 'resource.StoredResource',
                    retrieveResourceId: annotationsId
                },
                scope: this
            }).then(function(response) {
                var data = Ext.JSON.decode(response.responseText);
                if (data.storedResource.resource) {
                    var annotations = Ext.JSON.decode(data.storedResource.resource)
                    if (Ext.isString(annotations)) {
                        annotations = Ext.JSON.decode(annotations);
                        me.setAnnotations(annotations)
                    }
                }
                if (!me.getAnnotations()) {
                    me.showError(me.localize("annotationsLoadFailed"));
                }
                me.setAnnotationsLoadedIfAvailable(true);
            }, function(response) {
                me.showResponseError(me.localize("annotationsLoadFailed"), response);
                me.setAnnotationsLoadedIfAvailable(true);
            });
        } else {
            this.setAnnotationsLoadedIfAvailable(true);
        }
    },
    initComponent: function() {
        var me = this;
        this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
        var hide = this.getApiParam("hide");
        if (Ext.isString(hide)) {
            hide = hide.split(',');
            this.setApiParam('hide');
        }
        var iconBase = this.getApplication().getBaseUrl()+"resources/dreamscape/";
        Ext.apply(this, {
            title: this.localize('title'),
            bodyBorder: true,
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                itemId: 'bottomToolbar',
                overflowHandler: 'scroller',
                items: [
                    {
                        text: this.localize('display'),
                        tooltip: this.localize('displayTip'),
                        glyph: 'xf013@FontAwesome',
                        menu: {
                            defaults: { // these are intended for the radiogroups after the separator (and should be ignored by the menu items above the separator)
                                xtype: 'menucheckitem',
                                checkHandler: function(item, checked) {
                                    var map = this.getMap(), id = item.getItemId();
                                    this.getFilterWidgets().each(function(filter) {
                                        map.getLayer(filter.getId()+"-"+id).setVisible(checked);
                                    })
                                    var hide = Ext.Array.from(this.getApiParam('hide'));
                                    if (checked) {
                                        hide = Ext.Array.remove(hide, id);
                                    } else {
                                        hide.push(id);
                                        hide = Ext.Array.unique(hide);
                                    }
                                    this.setApiParam("hide", hide);
                                    item.getMenu().setDisabled(checked==false);
                                },
                                scope: this,
                                checked: true
                            },
                            items: [{
                                xtype: 'menuitem',
                                text: this.localize('baseLayer'),
                                tooltip: this.localize('baseLayerTip'),
                                glyph: 'xf279@FontAwesome',
                                menu: {
                                    items: [{
                                        xtype: 'radiogroup',
                                        columns: 1,
                                        vertical: true,
                                        defaults: {
                                            cls: 'map-menu-item',
                                            handler: function(item, checked) {
                                                if(checked){
                                                    var panel = this;
                                                    id = item.getItemId();
                                                    var layer = this.getBaseLayers()[id];
                                                    if (layer) {
                                                        layer.setOpacity(1);
                                                        this.getMap().getLayers().setAt(0, layer);
                                                    }
                                                    if(id == 'osm' || id == 'arcGIS') {
                                                        this.getMap().getLayer("overlayLayer").setVisible(false);
                                                    } else {
                                                        this.getMap().getLayer("overlayLayer").setVisible(true);
                                                    }
                                                }
                                            },
                                            listeners: {
                                                afterrender: function(item) {
                                                    Ext.create('Ext.tip.ToolTip', {
                                                        target: item,
                                                        html: '<div class="map-menu-item-tooltip '+item.getItemId()+'"></div>',
                                                        anchor: 'right'
                                                    });
                                                }
                                            },
                                            scope: this
                                        },
                                        items: [
                                            {
                                                boxLabel: this.localize('watercolor'),
                                                itemId: 'watercolor',
                                                cls: ['map-menu-item','watercolor'],
                                                checked: true
                                            },{
                                                boxLabel: this.localize('wms4326'),
                                                cls: ['map-menu-item','wms4326'],
                                                itemId: 'wms4326'
                                            },{
                                                boxLabel: this.localize('osm'),
                                                cls: ['map-menu-item','osm'],
                                                itemId: 'osm'
                                            },{
                                                boxLabel: this.localize('arcGIS'),
                                                cls: ['map-menu-item','arcGIS'],
                                                itemId: 'arcGIS'
                                            }
                                        ]
                                    }]
                                }
                            },{
                                xtype: 'menuitem',
                                text: this.localize('projection'),
                                tooltip: this.localize('projectionTip'),
                                glyph: 'xf0ac@FontAwesome',
                                menu: {
                                    items: [{
                                        xtype: 'radiogroup',
                                        columns: 1,
                                        vertical: true,
                                        defaults: {
                                            handler: function(item, checked) {
                                                if(checked){
                                                    var panel = this;
                                                    id = item.getItemId();
                                                    var view = undefined
                                                    if (id === "webMercatorProjection") {
                                                        this.setProjection(ol.proj.get('EPSG:3857'));
                                                    } else if (id === "mercatorProjection") {
                                                        this.setProjection(ol.proj.get('EPSG:4326'));
                                                    } else if (id === "gallPetersProjection") {
                                                        proj4.defs('cea',"+proj=cea +lon_0=0 +lat_ts=45 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs");
                                                        var gallPetersProjection = ol.proj.get('cea');
                                                        this.setProjection(gallPetersProjection);
                                                    } else if (id === "sphereMollweideProjection") {
                                                        proj4.defs('ESRI:54009', '+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs');
                                                        var sphereMollweideProjection = ol.proj.get('ESRI:54009');
                                                        sphereMollweideProjection.setExtent([-18e6, -9e6, 18e6, 9e6]);
                                                        this.setProjection(sphereMollweideProjection);
                                                    }
                                                    var newProjExtent = this.getProjection().getExtent();
                                                    // If using Mercator projection, earth with is measured in degrees, otherwise it's in meters
                                                    var earthWidth = this.getProjection() == ol.proj.get("EPSG:4326") ? 360 : 40075016.68557849;
                                                    var newView = new ol.View({
                                                        projection: this.getProjection(),
                                                        center: ol.extent.getCenter(newProjExtent || [0, 0, 0, 0]),
                                                        maxResolution: earthWidth / panel.body.dom.offsetWidth,
                                                        zoom: 0
                                                    });
                                                    var map = this.getMap();
                                                    var layers = map.getLayers();
                                                    layers.forEach(function(layer) {
                                                        if(layer.getSource().getFeatures){
                                                            var features = layer.getSource().getFeatures();
                                                            features.forEach(function(feature){
                                                                var newGeometry = feature.getGeometry().transform(map.getView().getProjection(), panel.getProjection());
                                                                feature.setGeometry(newGeometry);
                                                            })
                                                        }
                                                    });

                                                    map.setView(newView);
                                                }
                                            },
                                            listeners: {
                                                afterrender: function(item) {
                                                    Ext.create('Ext.tip.ToolTip', {
                                                        target: item,
                                                        html: '<div class="map-menu-item-tooltip '+item.getItemId()+'"></div>',
                                                        anchor: 'right'
                                                    });
                                                }
                                            },
                                            scope: this
                                        },
                                        items: [
                                            {
                                                boxLabel: this.localize('webMercatorProjection'),
                                                itemId: 'webMercatorProjection',
                                                cls: ['map-menu-item','webMercatorProjection'],
                                                checked: true
                                            },{
                                                boxLabel: this.localize('mercatorProjection'),
                                                cls: ['map-menu-item','mercatorProjection'],
                                                itemId: 'mercatorProjection'
                                            },{
                                                boxLabel: this.localize('gallPetersProjection'),
                                                cls: ['map-menu-item','gallPetersProjection'],
                                                itemId: 'gallPetersProjection'
                                            },{
                                                boxLabel: this.localize('sphereMollweideProjection'),
                                                cls: ['map-menu-item','sphereMollweideProjection'],
                                                itemId: 'sphereMollweideProjection'
                                            }
                                        ]
                                    }]

                                }
                            },'-',{
                                text: this.localize('cities'),
                                checked: Ext.Array.contains(hide, "cities")==false,
                                itemId: 'cities',
                                menu: {
                                    defaults: {
                                        labelAlign: 'right',
                                        labelWidth: 140
                                    },
                                    items: [{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('citiesMaxCount'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('citiesMaxCount')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('citiesMaxCount', newVal);
                                                    var currentCitiesCount = filter.getGeonames().getCitiesCount();
                                                    if (newVal<oldVal || newVal<=currentCitiesCount) {
                                                        this.filterUpdate(filter);
                                                    } else if (filter.getGeonames().hasMoreCities()) {
                                                        filter.loadGeonames()
                                                    } else {
                                                        cmp.setValue(currentCitiesCount); // will call change
                                                        this.toastInfo(new Ext.XTemplate(this.localize("allNCitiesShown")).apply([currentCitiesCount]))
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    },{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('citiesMinPopulation'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('minPopulation')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.setApiParam('minPopulation', newVal);
                                                this.getFilterWidgets().each(function(filter) {
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    },{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('citiesMinFreq'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('citiesMinFreq')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('citiesMinFreq', newVal);
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    }]
                                }
                            },{
                                text: this.localize('connections'),
                                checked: Ext.Array.contains(hide, "connections")==false,
                                itemId: 'connections',
                                menu: {
                                    defaults: {
                                        labelWidth: 140,
                                        labelAlign: 'right'
                                    },
                                    items: [{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('connectionsMaxCount'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('connectionsMaxCount')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('connectionsMaxCount', newVal);
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    },{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('connectionsMinFreq'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('connectionsMinFreq')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('connectionsMinFreq', newVal);
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    }]
                                }

                            },{
                                xtype: 'menucheckitem',
                                checked: Ext.Array.contains(hide, "animation")==false,
                                text: this.localize('animations'),
                                itemId: 'animation',
                                menu: {
                                    defaults: {
                                        labelWidth: 170,
                                        labelAlign: 'right',
                                        width: 280
                                    },
                                    items: [{
                                        xtype: 'sliderfield',
                                        fieldLabel: this.localize('millisPerAnimation'),
                                        value: parseInt(this.getApiParam('millisPerAnimation')),
                                        minValue: this.getAnimationDelay(),
                                        maxValue: 10000,
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    filter.setMillisPerAnimation(newVal);
                                                    filter.animate();
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    }]
                                }
                            }]
                        }
                    }, '-', {
                        text: this.localize('add'),
                        itemId: 'addFilter',
                        glyph: 'xf067@FontAwesome',
                        handler: function(cmp) {
                            var colors = this.getApplication().getColorPalette(undefined, true),
                                color = colors[0]; // default to first

                            // find an available color
                            for (var i=0, len=colors.length; i<len; i++) {
                                var hasMatch = false;
                                this.getFilterWidgets().each(function(filter) {
                                    if (filter.getColor()==colors[i]) {
                                        hasMatch = true;
                                        return false;
                                    }
                                })
                                if (hasMatch==false) {
                                    color = colors[i];
                                    break;
                                }
                            }
                            var filter = cmp.ownerCt.add({
                                xtype: 'geonamesfilter',
                                corpus: this.getCorpus(),
                                color: color,
                                listeners: {
                                    removeFilterWidget: function(filter) {
                                        var map = this.getMap(), id = filter.getItemId(), filters = this.getFilterWidgets();
                                        ["connections","cities","animation"].forEach(function(layer) {
                                            map.removeLayer(map.getLayer(id+"-"+layer));
                                        })
                                        filters.remove(filter);
                                        if (filters.getCount()==0) { // we always want at least one filter
                                            // simulate adding a filter
                                            this.getDockedComponent('bottomToolbar').getComponent('addFilter').click();
                                        }
                                    },
                                    filterUpdate: this.filterUpdate,
                                    scope: this
                                }
                            })
                            this.getFilterWidgets().add(filter.getId(), filter);

                            var map = this.getMap();

                            var connectionsLayer = new ol.layer.Vector({
                                source: new ol.source.Vector({
                                    wrapX: false,
                                    useSpatialIndex: true // needed to call getExtent()
                                }),
                                id: filter.getId()+"-connections",
                                visible: true,
                                opacity: 0.2,
                                style: this.travelStyleFunction.bind(this),
                                updateWhileAnimating: true, // optional, for instant visual feedback
                                updateWhileInteracting: true // optional, for instant visual feedback
                            });
                            map.addLayer(connectionsLayer);

                            var citiesLayer = new ol.layer.Vector({
                                source: new ol.source.Vector({
                                    wrapX: false,
                                    useSpatialIndex: true // needed to call getExtent()
                                }),
                                id: filter.getId()+"-cities",
                                opacity: 0.5,
                                style: this.cityStyleFunction.bind(this)
                            });
                            map.addLayer(citiesLayer);

                            var animationLayer = new ol.layer.Vector({
                                source: new ol.source.Vector({
                                    wrapX: false,
                                    useSpatialIndex: true // needed to call getExtent()
                                }),
                                id: filter.getId()+"-animation",
                                style:  this.animationStyleFunction.bind(this)
                            });
                            map.addLayer(animationLayer);
                        },
                        scope: this
                    }]
            }]
        });

        this.on("loadedCorpus", function(src, corpus) {
            this.tryInit();
        }, this);

        this.callParent();
    },

    tryInit: function() {
        if (this.getIsOpenLayersLoaded() && this.getIsArcLoaded() && this.getIsProj4Loaded() && this.getAnnotationsLoadedIfAvailable()) {
            var el = this.body.down('.map').setId(Ext.id());
            /*
            var overlayEl = this.body.down('.ol-popup');
            var overlay = new ol.Overlay({
                element: overlayEl.dom,
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                }
            });
            this.setOverlay(overlay);
            */
            var panel = this;
            // Add a click handler to hide the popup
            /*
            var closer = overlayEl.down(".ol-popup-closer").dom;
            closer.onclick = function() {
                overlay.setPosition(undefined);
                closer.blur();
                panel.getMap().getLayer("preview").getSource().clear();

//                if(panel.getDrawMode()) {
//                    panel.getDockedComponent('bottomToolbar').getComponent('annotate').click();
//                }
                return false;
            };
            */

            var baseLayers = this.getBaseLayers();
            baseLayers['wms4326'] = new ol.layer.Tile({
                preload: Infinity,
                source: new ol.source.TileWMS({
                    url: 'https://ahocevar.com/geoserver/wms',
                    crossOrigin: '',
                    params: {
                        'LAYERS': 'ne:NE1_HR_LC_SR_W_DR',
                        'TILED': true
                    },
                    projection: 'EPSG:4326'
                })
            });

            baseLayers['watercolor'] =  new ol.layer.Tile({
                preload: Infinity,
                source: new ol.source.Stamen({
                    //cacheSize: 2048,
                    layer: 'watercolor',
                    projection: "EPSG:3857"
                })
            });

            baseLayers['osm'] = new ol.layer.Tile({
                preload: Infinity,
                source: new ol.source.OSM({
                    projection: "EPSG:3857"
                })
            });

            baseLayers['arcGIS'] = new ol.layer.Tile({
                preload: Infinity,
                source: new ol.source.TileArcGISRest({
                    url: "https://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer",
                    projection: "EPSG:3857"
                })
            });

//            this.setContentEl(overlayEl.down('.popup-content'));
            var map = new ol.Map({
                layers: [
                    baseLayers['watercolor'],

                    new ol.layer.Tile({
                        preload: Infinity,
                        source: new ol.source.Stamen({
                            cacheize: 2048,
                            layer: 'toner-hybrid',
                            projection: "EPSG:3857"
                        }),
                        id: 'overlayLayer'
                    })
                ],
//                overlays: [overlay],
                target: el.getId(),
                loadTilesWhileInteracting: true,
                view: new ol.View({
                    center: [0, 0],
                    maxResolution: 40075016.68557849 / panel.body.dom.offsetWidth,
                    zoom: 0
                })
            });

            map.on('singleclick', this.handleSingleClick, this);
            // Add a click handler to the map to render the popup
            map.on('singleclicking', function(event) {
                var pixel = event.pixel;
                var features = map.getFeaturesAtPixel(pixel);
                if (features) {
                		for (var i=0; i<features.length; i++) {
                			var feature = features[i];
                			if (feature.get("type")=='city') {
                				this.handleLocationClick(feature);
                			}
                		}
                		var feature = features[0];
                		debugger
                }
                
                if(features) {
                    var foundFeature = false;
                    features.forEach( function(feature) {
                        if( feature.get("type") === "city" && feature.get("selected")) { // city
                            panel.dispatchEvent("termsClicked", panel, [feature.get("forms").join("|")])
                            foundFeature = true;
                        } else if (feature.get("type") === "connection" && feature.get("selected") && !foundFeature) { // connection
                            panel.getFilterWidgets().each(function (filter) {
                                var geonames = filter.getGeonames();
                                if (geonames != null) {
                                    var occurrences = geonames.getAllConnectionOccurrences(feature.get("source"), feature.get("target"));
                                    var infos = "<ul>";
                                    var docIndex = -1;
                                    occurrences.forEach(function(occ) {
                                        if(occ.docIndex != docIndex) {
                                            docIndex = occ.docIndex;
                                            infos += '<h4>' + panel.getCorpus().getDocument(docIndex).getFullLabel() + ':</h4>';
                                        }
                                        infos += '<li>'+ occ.source.left+'<a href="http://www.geonames.org/' + occ.source.id + '" target="_blank" docIndex='+occ.docIndex +' offset='+occ.source.position+
                                            ' location='+occ.source.form + ' cityId=' + occ.source.id + ' coordinates=' + JSON.stringify(sourceCoordinates) + ' class="termLocationLink">' + occ.source.form + '</a> '+occ.source.right + ' [...] ' +
                                            occ.target.left+'<a href="http://www.geonames.org/' + occ.target.id + '" target="_blank" docIndex='+occ.docIndex+' offset='+occ.target.position+
                                            ' location='+occ.target.form+ ' cityId=' + occ.target.id + ' coordinates=' + JSON.stringify(targetCoordinates) + ' class="termLocationLink">' + occ.target.form + '</a> '+occ.target.right + '</li>';
                                    });
                                    var header = feature.get("text");
                                    infos += "</ul>";
                                    panel.getContentEl().setHtml('<h3>' + header + '</h3>' + infos);
                                    panel.getOverlay().setPosition(event.coordinate);
                                    var links = Ext.select('.termLocationLink');

//                                    function contextMenuListener(el) {
//                                        el.addEventListener( "contextmenu", function(e) {
//                                            e.preventDefault();
//                                            panel.openContextMenu(e.layerX, e.layerY, el);
//                                            return false;
//                                        }, false);
//                                    }

                                    links.elements.forEach(function(link) {
//                                        contextMenuListener(link);
                                        link.onmouseover = function(){panel.showTermInCorpus(link.getAttribute("docIndex"), link.getAttribute("offset"), link.getAttribute('location'))};
                                    });
                                }
                            });
                            foundFeature = true
                        } /*else if (feature.get("type") === "annotation" && !foundFeature) { //annotation
                            panel.setCurrentAnnotation(feature);
                            panel.getContentEl().setHtml('<textarea class="annotation-text" rows="5" cols="60">'+(feature.get("text")?feature.get("text"):"")+'</textarea>' +
                                '<button class="saveAnnotation">Save</button><button class="deleteAnnotation">Delete</button>');
                            panel.getOverlay().setPosition(event.coordinate);
                            panel.getContentEl().down('.deleteAnnotation').dom.onclick = function() {panel.deleteAnnotation()};
                            panel.getContentEl().down('.saveAnnotation').dom.onclick = function() {panel.saveAnnotation()};
                            panel.getContentEl().down('.annotation-text').dom.focus();
                        } */
                    }, this);
                }
            });

            // Layer for selected vector
            var selectedLayer = new ol.layer.Vector({
                map: map,
                source: new ol.source.Vector({
                    wrapX: false,
                    useSpatialIndex: false // optional, might improve performance
                }),
                zIndex: 10,
                selected: true,
                style: function(feature) {
                    if(feature.get("type") === "city")
                    {
                        return panel.cityStyleFunction(feature, map.getView().getResolution());
                    } else if(feature.get("type") === "connection") {
                        return panel.travelStyleFunction(feature, map.getView().getResolution());
                    }
                },
                updateWhileAnimating: true, // optional, for instant visual feedback
                updateWhileInteracting: true // optional, for instant visual feedback
            });

            // Layer for edit preview
            var previewLayer = new ol.layer.Vector({
                map: map,
                source: new ol.source.Vector({
                    wrapX: false,
                    useSpatialIndex: false // optional, might improve performance
                }),
                preview: true,
                zIndex: 15,
                id: "preview",
                style: function(feature) {
                    if(feature.get("type") === "city")
                    {
                        return panel.cityStyleFunction(feature, map.getView().getResolution());
                    } else if(feature.get("type") === "connection") {
                        return panel.travelStyleFunction(feature, map.getView().getResolution());
                    }
                },
                updateWhileAnimating: true, // optional, for instant visual feedback
                updateWhileInteracting: true // optional, for instant visual feedback
            });
            map.addLayer(previewLayer);

            // Add handler to update selected vector when mouse is moved
            map.on('pointermove', function(event) {
            	
            	// set cursoe to pointer if we have a feature
            	  var pixel = map.getEventPixel(event.originalEvent);
            	  var hit = map.hasFeatureAtPixel(pixel);
            	  map.getViewport().style.cursor = hit ? 'pointer' : '';
            	  
                if(!panel.getDrawMode()) {
                    selectedLayer.getSource().clear();
                    var coordinate = event.coordinate;
                    var pixel = event.pixel;
                    var features = map.getFeaturesAtPixel(pixel);
                    if(features) {
                        var i = 0;
                        while(features[i].get("selected")){
                            i++;
                            if (i === features.length) break;
                        }
                        if (i < features.length) {
                            var feature = features[i];

                            var baseTextStyle = {
                                font: '12px Calibri,sans-serif',
                                textAlign: 'center',
                                offsetY: -15,
                                fill: new ol.style.Fill({
                                    color: [0,0,0,1]
                                }),
                                stroke: new ol.style.Stroke({
                                    color: [255,255,255,0.5],
                                    width: 4
                                })
                            };

                            baseTextStyle.text = feature.get("text");

                            var textOverlayStyle = new ol.style.Style({
                                text: new ol.style.Text(baseTextStyle),
                                zIndex: 1
                            });

                            if (!(feature.get("type") === "annotation")) {
                                var selectedFeature = new ol.Feature({
                                    text: feature.get("text"),
                                    geometry: feature.getGeometry(),
                                    forms: feature.get("forms"),
                                    selected: true,
                                    coordinates: feature.get("coordinates"),
                                    width: feature.get("width"),
                                    visible: feature.get("visible"),
                                    color: feature.get("color"),
                                    type: feature.get("type"),
                                    confidence: feature.get("confidence"),
                                    source: feature.get("source"),
                                    target: feature.get("target"),
                                    cityId: feature.get("cityId")
                                });
                                selectedLayer.getSource().addFeature(selectedFeature);
                            }
                            var geometry = feature.getGeometry();
                            var point = event.coordinate;
                            var textFeature = new ol.Feature({
                                geometry: new ol.geom.Point(point),
                                selected: true
                            });
                            textFeature.setStyle(textOverlayStyle);
                            selectedLayer.getSource().addFeature(textFeature);

                            // Highlight all connection where selected city is source or target

                            if(feature.get("type") === "city") {
                                var layers = panel.getMap().getLayers();
                                layers.forEach(function (layer) {
                                    var layerId = layer.get("id");
                                    if (layerId && layerId.indexOf("connections") !== -1) {
                                        connections = layer.getSource().getFeatures();
                                        connections.forEach(function (connection) {
                                            if(connection.get("target") === feature.get("cityId") || connection.get("source") === feature.get("cityId")) {
                                                selectedLayer.getSource().addFeature(new ol.Feature({
                                                    geometry: connection.getGeometry(),
                                                    selected: true,
                                                    coordinates: connection.get("coordinates"),
                                                    width: connection.get("width"),
                                                    visible: connection.get("visible"),
                                                    color: connection.get("color"),
                                                    type: connection.get("type")
                                                }));
                                            }
                                        })
                                    }
                                })
                            }
                        }
                    }
                }
            });
            var source = new ol.source.Vector({wrapX: false});

            var annotations = new ol.layer.Vector({
                source: source,
                id: "annotations"
            });

            var annotationsObj = this.getAnnotations();
            if (annotationsObj) {
                var geojson = new ol.format.GeoJSON();
                var features = geojson.readFeatures(annotationsObj);
                source.addFeatures(features);
            }

            map.addLayer(annotations);

            this.setDrawInteraction(
                new ol.interaction.Draw({
                    source: source,
                    type: "Polygon",
                    freehand: true,
                    alias: "draw"
                })
            );
            this.getDrawInteraction().on('drawend', function (evt) {
                evt.feature.set('type', 'annotation');
//                panel.setCurrentAnnotation(evt.feature);
                panel.editAnnotation(evt.feature);
//                panel.getContentEl().setHtml('<textarea class="annotation-text" rows="5" cols="60"></textarea>'+
//                    '<button class="saveAnnotation">Save</button><button class="deleteAnnotation">Cancel</button>');
//                panel.getContentEl().down('.deleteAnnotation').dom.onclick = function() {panel.deleteAnnotation()};
//                panel.getContentEl().down('.saveAnnotation').dom.onclick = function() {panel.saveAnnotation()};
//                panel.getOverlay().setPosition(evt.feature.getGeometry().getLastCoordinate());
//                panel.getContentEl().down('.annotation-text').dom.focus();
            });

            /*
            map.getViewport().addEventListener('contextmenu', function (e) {
                e.preventDefault();
                panel.openContextMenu(e.layerX, e.layerY);
                return false;
            }, false);
            */

            this.setMap(map);

            var zoom = this.getTargetEl().down(".ol-zoom");
            Ext.create('Ext.Button', {
                glyph:'xf075@FontAwesome',
                cls: 'annotate',
                renderTo: this.getTargetEl().down(".ticker").parent(),
                tooltip: this.localize('annotateTip'),
                enableToggle: true,
                toggleHandler: function(cmp, state) {
                    if (state) {
                        this.getMap().addInteraction(this.getDrawInteraction());
                    } else {
                        this.getMap().removeInteraction(this.getDrawInteraction());
                    }
                },
                scope: this
            })

            // simulate adding a filter
            this.getDockedComponent('bottomToolbar').getComponent('addFilter').click();
        } else {
            Ext.defer(this.tryInit, 500, this); // try again in a half second
        }
    },
    
    editAnnotation: function(feature) {
    		var text = feature.get("text"), buttons = [];
    		Ext.Msg.show({
    			title: this.localize("editAnnotation"),
    			message: this.localize("editAnnotationMessage"),
    			buttons: Ext.Msg.OKCANCEL,
            multiline: true,
            value: text,
            scope: this,
            callback: function(btn, val) {
            		if (btn=='ok') {
            			if (val=="") {
            				this.getMap().getLayer("annotations").getSource().removeFeature(feature);
            			} else {
            				feature.set("text", val);
            			}
            	        var geojson  = new ol.format.GeoJSON;
            	        var features = this.getMap().getLayer("annotations").getSource().getFeatures();
            	        var transformedFeatures = [];
            	        var projection = this.getProjection();
            	        features.forEach(function (feature) {
            	            transformedFeature = feature.clone();
            	            transformedFeature.getGeometry().transform(projection?projection:'EPSG:3857', 'EPSG:3857');
            	            transformedFeatures.push(transformedFeature);
            	        })
            	        var json = geojson.writeFeatures(transformedFeatures);
            	        this.storeAnnotations(json);
            		}
            }
    		})

    },

    /*
    deleteAnnotation: function() {
        this.body.down('.ol-popup').down(".ol-popup-closer").dom.click();
        this.getMap().getLayer("annotations").getSource().removeFeature(this.getCurrentAnnotation());
        var geojson  = new ol.format.GeoJSON;
        var features = this.getMap().getLayer("annotations").getSource().getFeatures();
        var transformedFeatures = [];
        var projection = this.getProjection();
        features.forEach(function (feature) {
            transformedFeature = feature.clone();
            transformedFeature.getGeometry().transform(projection?projection:'EPSG:3857', 'EPSG:3857');
            transformedFeatures.push(transformedFeature);
        })
        var json = geojson.writeFeatures(transformedFeatures);
        this.storeAnnotations(json);
//        localStorage['annotations'] = JSON.stringify(json);
    },
    */

    storeAnnotations: function(json) {
        this.mask("storingAnnotations");
        var me = this;
        Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                storeResource: JSON.stringify(json)
            },
            scope: this
        }).then(function(response) {
            me.unmask();
            var data = Ext.JSON.decode(response.responseText);
            me.setApiParam("annotationsId", data.storedResource.id);
            me.toastInfo(me.localize('annotationsUpdated'));
        }, function(response) {
            me.unmask();
            me.showResponseError(me.localize("annotationsUpdateFailed"), response);
        });
    },

    /*
    saveAnnotation: function() {
        this.getCurrentAnnotation().set("text", this.getContentEl().down('.annotation-text').dom.value);
        this.getOverlay().setPosition(undefined);
//        if(this.getDrawMode()) {
//            this.getDockedComponent('bottomToolbar').getComponent('annotate').click();
//        }
        var geojson  = new ol.format.GeoJSON;
        var features = this.getMap().getLayer("annotations").getSource().getFeatures();
        var transformedFeatures = [];
        var projection = this.getProjection();
        features.forEach(function (feature) {
            transformedFeature = feature.clone();
            transformedFeature.getGeometry().transform(projection?projection:'EPSG:3857', 'EPSG:3857');
            transformedFeatures.push(transformedFeature);
        })
        var json = geojson.writeFeatures(transformedFeatures);
        this.storeAnnotations(json);
//        localStorage['annotations'] = JSON.stringify(json);
    },
    */

    // Style for vector after animation
    travelStyleFunction: function(feature, resolution) {

        var stroke = new ol.style.Stroke({
            color: feature.get('color'),
            width: feature.get('width')
        });

        var styles = [
            new ol.style.Style({
                stroke: stroke
            })];

        // Add arrow at the end of vectors
        var geometry = feature.getGeometry();
        var end = geometry.getLastCoordinate();
        var beforeEnd = geometry.getCoordinateAt(0.9);
        var dx = end[0] - beforeEnd[0];
        var dy = end[1] - beforeEnd[1];
        var rotation = Math.atan2(dy, dx);

        var lineStr1 = new ol.geom.LineString([end, [end[0] - 10 * resolution, end[1] + 10 * resolution]]);
        lineStr1.rotate(rotation, end);
        var lineStr2 = new ol.geom.LineString([end, [end[0] - 10 * resolution, end[1] - 10 * resolution]]);
        lineStr2.rotate(rotation, end);

        styles.push(new ol.style.Style({
            geometry: lineStr1,
            stroke: stroke
        }));
        styles.push(new ol.style.Style({
            geometry: lineStr2,
            stroke: stroke
        }));

        return styles;
    },

    // Style for cities
    cityStyleFunction: function(feature, resolution) {
        if(feature.get("visible")) {
            var diameter = Math.PI * 2 * feature.get("width");
            var confArc = feature.get("confidence") ? diameter * feature.get("confidence") : diameter;
            return (new ol.style.Style({
                image: new ol.style.Circle({
                    radius: feature.get("width"),
                    fill: new ol.style.Fill({
                        color: feature.get("color")
                    }),
                    stroke: new ol.style.Stroke({
                        lineDash: [confArc, diameter - confArc],
                        color: 'rgb(255, 255, 255)',
                        width: 2
                    })
                })
            }));
        } else {
            return false;
        }
    },

    // Style for vector during animation
    animationStyleFunction: function (feature) {
        return [new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: feature.get("color"),
                width: 5
            })
        }), new ol.style.Style({
            geometry: new ol.geom.Circle(feature.getGeometry().getFirstCoordinate()),
            stroke: new ol.style.Stroke({
                color: "white",
                width: 10
            })
        }), new ol.style.Style({
            geometry: new ol.geom.Circle(feature.getGeometry().getLastCoordinate()),
            stroke: new ol.style.Stroke({
                color: "white",
                width: 10
            })
        })];
    },

    showTermInCorpus: function(docIndex, position, location) {
        var term = Ext.create("Voyant.data.model.Context", {
            docIndex: docIndex,
            position: position,
            term: location
        });
        this.getApplication().dispatchEvent('termLocationClicked', this, [term]);
    },
   
    /**
     * Update all filters
     */
    reloadFilters: function() {
        this.getFilterWidgets().each(function(filter) {
        		filter.loadGeonames();
        }, this);
    },

    filterUpdate: function(filter) {
        var panel = this;
        filter.clearAnimation();

        var map = this.getMap(), color = filter.getColor();

        var citiesMaxCount = parseInt(this.getApiParam("citiesMaxCount"));

        // determine max rawFreq for sizing
        var max = 0;
        filter.getGeonames().eachCity(function(city) {if (city.rawFreq>max) {max=city.rawFreq;}}, this, citiesMaxCount);

        // generate cities
        var layerSource = map.getLayer(filter.getId()+"-cities").getSource();

        var hide = Ext.Array.from(this.getApiParam("hide"));

        layerSource.clear();
        var minPopulation = parseInt(this.getApiParam("minPopulation"));
        var citiesMinFreq = parseInt(this.getApiParam("citiesMinFreq"));
        var validCitiesHash = {};

        filter.getGeonames().eachCity(function(city) {

            if ((!minPopulation || city.population>=minPopulation) && (!citiesMinFreq || city.rawFreq>=citiesMinFreq)) {
                validCitiesHash[city.id]=true;
                var coordinates = [parseFloat(city.lng), parseFloat(city.lat)]
                var feature = new ol.Feature({

                    geometry: new ol.geom.Point(coordinates).transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857')),
                    text: city.label + " ("+city.rawFreq+")",
                    description: city.label,
                    color: color,
                    selected: false,
                    width: 3+ (Math.sqrt(city.rawFreq/max)*20),
                    visible: true,
                    coordinates: coordinates,
                    forms: city.forms,
                    cityId: city.id,
                    type: "city",
                    confidence: city.confidence ? city.confidence*100 : undefined
                });
                layerSource.addFeature(feature);
            }
        }, this, citiesMaxCount);

        if (layerSource.getFeatures().length>0) {
            map.getView().fit(layerSource.getExtent());
        }

        map.getLayer(filter.getId()+"-cities").setVisible(Ext.Array.contains(hide, "cities")==false);

        layerSource = map.getLayer(filter.getId()+"-connections").getSource();
        layerSource.clear();

        if (Object.keys(validCitiesHash).length==0) {
            this.toastInfo("No cities available for current criteria.");
        }

        max = 0;
        filter.getGeonames().eachConnection(function(connection) {
            if (connection.rawFreq>max) {max=connection.rawFreq;}
        }, this);

        // we'll go through all collections to see if we have valid cities
        var counter = 0,
            maxConnectionsCount = parseInt(this.getApiParam('connectionsMaxCount')),
            connectionsMinFreq = parseInt(this.getApiParam('connectionsMinFreq'));
        filter.getGeonames().eachConnection(function(connection) {
            if ((!connectionsMinFreq || connection.rawFreq>=connectionsMinFreq) && (!maxConnectionsCount || counter<maxConnectionsCount) && connection.source.id in validCitiesHash && connection.target.id in validCitiesHash && (!minPopulation || (connection.source.population>=minPopulation && connection.target.population>=minPopulation))) {
                var arcGenerator = new arc.GreatCircle(
                    {x: connection.source.lng, y: connection.source.lat},
                    {x: connection.target.lng, y: connection.target.lat});
                var arcLine = arcGenerator.Arc(100, {offset: 100});
                var label = connection.source.label+" -> "+connection.target.label + " ("+connection.rawFreq+")"
                arcLine.geometries.forEach(function(geometry) {
                    var line = new ol.geom.LineString(geometry.coords);
                    line.transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857'));
                    var feature = new ol.Feature({
                        geometry: line,
                        text: label,
                        color: color,
                        width: 3+ (Math.sqrt(connection.rawFreq/max)*10),
                        source: connection.source.id,
                        target: connection.target.id,
                        type: "connection"
                    });
                    layerSource.addFeature(feature);
                }, this);
                counter++;
            }
        }, this);

        map.getLayer(filter.getId()+"-connections").setVisible(Ext.Array.contains(hide, "connections")==false)

        filter.animate();

    },
    
    handleSingleClick: function(event) {
        var features = this.getMap().getFeaturesAtPixel(event.pixel);
        if (features) {
        		for (var i=0; i<features.length; i++) {
        			var feature = features[i];
        			var featureType = feature.get("type")
        			if (featureType=='city') {
        				this.handleLocationClick(event, feature);
        				break;
        			} else if (featureType=="connection") {
        				this.handleConnectionClick(feature, event.pixel[0], event.pixel[1]);
        				break;
        			}else if (featureType=="annotation") {
        				this.editAnnotation(feature);
        				break;
        			}
        		}
        }

    },
    
    handleConnectionClick: function(feature, x, y) {
		Ext.create('Ext.menu.Menu', {
			items: [{
    				text: this.localize("viewConnections"),
    				tooltip: this.localize("viewConnectionsTip"),
    				glyph: 'xf02d@FontAwesome',
    				handler: function() {
    					this.mask("loadingConnections");
    					var me = this;
    		            Ext.Ajax.request({
    		                url: this.getTromboneUrl(),
    		                params: {
    		                    tool: 'corpus.Dreamscape',
    		                    corpus: this.getCorpus().getId(),
    		                    suppressLocations: true,
    		                    suppressConnections: true,
    		                    sourceId: feature.get("source"),
    		                    targetId: feature.get("target"),
    		                    context: 2,
    		                    limit: 25
    		                },
    		                scope: this
    		            }).then(function(response) {
	                		me.unmask();
    		                var data = Ext.JSON.decode(response.responseText);
    		                if (data && data.dreamscape && data.dreamscape.connectionOccurrences) {
    		                		var out = "<table style='font-size:smaller'>";
    		                		data.dreamscape.connectionOccurrences.connectionOccurrences.forEach(function(occurrence) {
    		                			out+="<tr><td style='text-align: right'>"+occurrence.source.left+"</td><td class='keyword' style='text-align: center'>"+
    		                				occurrence.source.term+"</td><td>"+occurrence.source.right+"</td><td></td><td style='text-align: right'>"+occurrence.target.left+"</td><td class='keyword' style='text-align: center'>"+
    		                				occurrence.target.term+"</td><td>"+occurrence.target.right+"</td></tr>";
    		                		})
    		                		out += "</table>";
    		                		Ext.Msg.alert(me.localize("occurrences"), out);
    		                }
    		            }, function(response) {
	                		me.unmask();
                			return me.showError(me.localize("occurrencesNotLoaded"))	    		                			
    		            });
    				},
    				scope: this
				}]
		}).showAt(x, y)
    },
    
    
    handleLocationClick: function(event, feature) {
		var currentGeonameId = feature.get("cityId");
		var e = Ext.create('Ext.menu.Menu', {
			items: [{
    				text: this.localize("viewOccurrences"),
    				tooltip: this.localize("viewOccurrencesTip"),
    				glyph: 'xf02d@FontAwesome',
    				handler: function() {
    					this.mask("loadingOccurrences");
    					var me = this;
    		            Ext.Ajax.request({
    		                url: this.getTromboneUrl(),
    		                params: {
    		                    tool: 'corpus.Dreamscape',
    		                    corpus: this.getCorpus().getId(),
    		                    suppressLocations: true,
    		                    suppressConnections: true,
    		                    suppressConnectionOccurrences: true,
    		                    locationId: currentGeonameId,
    		                    limit: 25
    		                },
    		                scope: this
    		            }).then(function(response) {
	                		me.unmask();
    		                var data = Ext.JSON.decode(response.responseText);
    		                if (data && data.dreamscape && data.dreamscape.occurrences) {
    		                		var out = "<table style='font-size:smaller'>";
    		                		data.dreamscape.occurrences.occurrences.forEach(function(occurrence) {
    		                			out+="<tr><td style='text-align: right'>"+occurrence.left+"</td><td class='keyword' style='text-align: center'>"+occurrence.term+"</td><td>"+occurrence.right+"</td></tr>";
    		                		})
    		                		out += "</table>";
    		                		Ext.Msg.alert(me.localize("occurrences"), out);
    		                }
    		            }, function(response) {
	                		me.unmask();
                			return me.showError(me.localize("occurrencesNotLoaded"))	    		                			
    		            });
    				},
    				scope: this
				},{
    				text: this.localize("openInVoyant"),
    				tooltip: this.localize("openInVoyantTip"),
    				glyph: 'xf08e@FontAwesome',
    				handler: function() {
    					this.dispatchEvent('termsClicked', this, feature.get("forms"));
    				},
    				scope: this
				},{
    				text: this.localize("editLocation"),
    				tooltip: this.localize("editLocationTip"),
    				glyph: 'xf124@FontAwesome',
    				handler: function() {
    					this.mask("loadingAlternatives");
    					var me = this;
    		            Ext.Ajax.request({
    		                url: this.getTromboneUrl(),
    		                params: {
    		                    tool: 'util.Geonames',
    		                    query: feature.get("forms")
    		                },
    		                scope: this
    		            }).then(function(response) {
	                		me.unmask();
    		                var data = Ext.JSON.decode(response.responseText);
    		                if (data && data.geonames && data.geonames.locations) {
    		                		var items = []; 		 
    		                		Object.values(data.geonames.locations.locations).forEach(function(location) {
    		                			items.push({
    		                				boxLabel: location.label+" ("+location.population+")",
    		                				name: 'id',
    		                				inputValue: location.id,
    		                				checked: location.id==currentGeonameId
    		                			})
    		                		})
    		                		if (items.length==0) {
    		                			return me.showError(me.localize("editLocationNoLocationsFound"))
    		                		} else if (items.length==1 && items[0].inputValue==currentGeonameId) {
    		                			return me.showError(me.localize("editLocationNoAlternativesFound"))	    		                			
    		                		}
	    		                	Ext.create('Ext.window.Window', {
								title: me.localize("editLocation"),
								modal: true,
								items: {
									xtype: 'form',
									items: [{
								        xtype: 'radiogroup',
								        columns: 1,
								        vertical: true,
								        items: items
								    }],
									listeners: {
										afterrender: function(form) {
										},
										scope: this
									},
									buttons: [{
										text: me.localize("cancel"),
							            ui: 'default-toolbar',
						                glyph: 'xf00d@FontAwesome',
						        			flex: 1,
						        			handler: function(btn) {
						        				btn.up('window').destroy();
						        			}
									},{
										text: me.localize("confirmTitle"),
										glyph: 'xf00c@FontAwesome',
					            			flex: 1,
					            			handler: function(btn) {
					            				var newId = btn.up("form").getValues().id;
					            				if (newId && newId!=currentGeonameId) {
					    							var config = {};
					    							config[currentGeonameId] = newId;
					    							me.appendOverrides(config);
					            				}
						        				btn.up('window').destroy();
					            			}
									}]
								}
							}).show();
    		                }
    		            }, function(response) {
	                		me.unmask();
    		                me.showResponseError(me.localize("editLocationServerError"), response);

    		            });
    				},
    				scope: this
			},{
    				text: this.localize("removeLocation"),
    				tooltip: this.localize("removeLocationTip"),
    				glyph: 'xf00d@FontAwesome',
    				handler: function() {
    					Ext.Msg.confirm(
	    					this.localize("removeLocationConfirmTitle"),
	    					this.localize("removeLocationConfirm"),
	    					function(btn) {
	    						if (btn=="yes") {
	    							var config = {};
	    							config[currentGeonameId] = "";
	    							this.appendOverrides(config);
	    						}
	    					},
	    					this
    					)
    				},
    				scope: this
			}    				

			],
			listeners: {
				focusleave : function(menu) {
					menu.destroy();
				}
			}
		}).showAt(event.pixel[0], event.pixel[1])    		
    },
    
    appendOverrides: function(config, isAll) {
    		// if we have overridesId defined but we haven't loaded all IDs yet
    		if (this.getApiParam("overridesId") && !isAll) {
    			var me = this;
    			Ext.Ajax.request({
                url: this.getTromboneUrl(),
                params: {
                    tool: 'resource.StoredResource',
                    retrieveResourceId: this.getApiParam("overridesId")
                },
                scope: this
            }).then(function(response) {
                var data = Ext.JSON.decode(response.responseText);
                if (data && data.storedResource && data.storedResource.resource) {
                		var newConfig = Ext.decode(data.storedResource.resource);
                		Ext.apply(newConfig, config);
                		// call again, this time specifying that we have all
                		me.appendOverrides(newConfig, true);
                } else {
                    me.showResponseError(me.localize("overidesRetrieveError"), response);
                }
            	
            }, function(response) {
                me.showResponseError(me.localize("overidesRetrieveError"), response);
            });
    		} else {
    			var me = this;
    			Ext.Ajax.request({
                url: this.getTromboneUrl(),
                params: {
                    tool: 'resource.StoredResource',
                    storeResource: Ext.encode(config)
                },
                scope: this
            }).then(function(response) {
                var data = Ext.JSON.decode(response.responseText);
                if (data && data.storedResource && data.storedResource.id) {
                    me.setApiParam("overridesId", data.storedResource.id);
                    me.reloadFilters();
                } else {
                    me.showResponseError(me.localize("overidesRetrieveError"), response);
                }
            }, function(response) {
                me.showResponseError(me.localize("overidesStorageError"), response);
            });
    		}
    }    

});

Ext.define('Voyant.widget.GeonamesFilter', {
    extend: 'Ext.Button',
    xtype: 'geonamesfilter',
    mixins: ['Voyant.util.Localization'],
    statics: {
        i18n: {
            filter: 'Filter',
            authorLabel: 'authors',
            titleLabel: 'titles',
            keywordLabel: 'full text',
            pubDateLabel: "dates",
            loading: "Loading geographical information",
//            loadedAll: "All available cities and connections have been loaded (see options under the <i>Show</i> menu in the toolbar).",
//            loadedSome: "Loaded {currentCitiesCount} of {totalCitiesCount} available locations and {currentConnectionsCount} of {totalConnectionsCount} available connections (see options under the <b>Show</b> menu in the toolbar).",
//            disclaimer: "Please note that geographical information is generated automatically and may be inaccurate (<a href='{url}' target='_blank'>more information</a>).</p>",
            disclaimer: "This is an experimental tool and the accuracy of the data is variable (<a href='{url}' target='_blank'>see help</a>).",
            noDataForField: "No data seems to be available for this field so it will be disabled.",
            close: "Close"
        }
    },
    config: {
        corpus: undefined, // used by querysearchfields among other things
        geonames: undefined,
        color: "#f00",
        timeout: undefined,
        currentConnectionOccurrence: undefined,
        animationLayer: undefined,
        millisPerAnimation: 2000,
        stepByStepMode: false,
        keepAnimationInFrame: false
    },
    constructor: function(config) {
        config = config || {};
        var geonames = new Voyant.data.util.Geonames({
            corpus: config.corpus
        });
        this.setGeonames(geonames);
        var me = this;
        Ext.applyIf(config,
            {
                tooltip: this.localize('filterTip'),
                style: "background-color: white; color: "+config.color,
                glyph: 'xf0b0@FontAwesome',
                menu: {
                    defaults: {
                        xtype: 'querysearchfield',
                        labelWidth: 60,
                        labelAlign: 'right',
                        width: 250,
                        maxWidth: 250,
                        padding: 2,
                        listeners: { // don't set scope to this so that load keeps the widget scope
                            change: function(cmp, vals) {
                                me.loadGeonames();
                            },
                            load: function(store, records, success, operation) {
                                if (records.length==0 && operation.getParams().query=="") {
                                    Ext.Msg.show({
                                        buttonText: {ok: me.localize('close')},
                                        icon: Ext.MessageBox.INFO,
                                        message: me.localize("noDataForField"),
                                        buttons: Ext.Msg.OK
                                    });
                                    this.disable();
                                }
                            }
                        }

                    },
                    items: [{
                        fieldLabel: this.localize('authorLabel'),
                        tokenType: 'author',
                        itemId: 'author'
                    },{
                        fieldLabel: this.localize('titleLabel'),
                        itemId: 'title',
                        tokenType: 'title'
                    },{
                        fieldLabel: this.localize('keywordLabel')
                    },{
                        xtype: 'multislider',
                        fieldLabel: this.localize('pubDateLabel'),
                        itemId: 'pubDate',
                        tokenType: 'pubDate',
                        values: [0,1],
                        hidden: true,
                        listeners: {
                            afterrender: function(cmp) {
                                this.getCorpus().getCorpusTerms().load({
                                    params: {
                                        tokenType: 'pubDate',
                                        limit: 1,
                                        sort: "TERMASC"
                                    },
                                    callback: function(records) {
                                        if (records.length==0) {
                                            // no pubDate, see if we can parse from titles
                                            var vals = [];
                                            this.getCorpus().each(function(doc) {
                                                var val = parseInt(doc.getTitle());
                                                if (isNaN(val)==false) {
                                                    vals.push(parseInt(doc.getTitle()))
                                                }
                                            }, this);
                                            if (vals.length>1) {
                                                cmp.setMinValue(vals[0]);
                                                cmp.setMaxValue(vals[vals.length-1]);
                                                cmp.tokenType = 'title';
                                                cmp.suspendEvent('changecomplete');
                                                cmp.setValue([vals[0], vals[vals.length-1]]);
                                                cmp.resumeEvent('changecomplete');
                                                cmp.setVisible(true);
                                            }
                                        } else {
                                            cmp.setMinValue(parseInt(records[0].getTerm()))
                                            this.getCorpus().getCorpusTerms().load({
                                                params: {
                                                    tokenType: 'pubDate',
                                                    limit: 1,
                                                    sort: "TERMDESC"
                                                },
                                                callback: function(records) {
                                                    cmp.setMaxValue(parseInt(records[0].getTerm())),
                                                        cmp.setVisible(true);
                                                },
                                                scope: this
                                            });
                                        }
                                    },
                                    scope: this
                                })
                            },
                            changecomplete: function(cmp, newVal) {
                                this.loadGeonames();
                            },
                            scope: this
                        }
                    }, {
                        xtype: 'fieldset',
                        title: "Animation",
                        items: [{
                            xtype: 'container',
                            layout: 'hbox',
                            defaults: {
                                xtype: 'button',
                                text: "",
                                ui: 'default-toolbar'
                            },
                            items: [{
                                glyph: 'xf048@FontAwesome', // step back
                                handler: function() {
                                    this.getAnimationLayer().getSource().clear();
                                    this.clearAnimation();
                                    var currentConnectionOccurrence = this.getCurrentConnectionOccurrence();
                                    currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence ? currentConnectionOccurrence.index-1 : 0);
                                    this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                                    this.animate();
                                },
                                scope: this
                            },{
                                glyph: 'xf04c@FontAwesome', // play
                                handler: function(cmp) {
                                    if (cmp.getGlyph().glyphConfig=="xf04b@FontAwesome") {
                                        this.clearAnimation();
                                        cmp.setGlyph(new Ext.Glyph('xf04c@FontAwesome'));
                                        this.setStepByStepMode(false);
                                        this.animate();
                                    } else {
                                        cmp.setGlyph(new Ext.Glyph('xf04b@FontAwesome'));
//                                         this.clearAnimation();
//                                         this.getAnimationLayer().getSource().clear();
                                        this.setStepByStepMode(true);
                                    }
//                                     this.setCurrentConnectionOccurrence(this.getGeonames().getConnectionOccurrence(0));
                                },
                                scope: this

                            },{
                                glyph: 'xf051@FontAwesome', // step forward
                                handler: function() {
                                    this.getAnimationLayer().getSource().clear();
                                    this.clearAnimation();
                                    var currentConnectionOccurrence = this.getCurrentConnectionOccurrence();
                                    currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence ? currentConnectionOccurrence.index+1 : 0);
                                    this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                                    this.animate();
                                },
                                scope: this
                            }, {
                                xtype: 'tbtext',
                                text: "&nbsp;&nbsp;"
                            }, {
                                glyph: 'xf01e@FontAwesome', // reset
                                handler: function() {
                                    this.getAnimationLayer().getSource().clear();
                                    this.clearAnimation();
                                    this.setCurrentConnectionOccurrence(this.getGeonames().getConnectionOccurrence(0));
                                    this.animate();
                                },
                                scope: this
                            }]
                        }, {
                            xtype: 'checkbox',
                            checked: false,
                            handler: function(item, checked) {
                                me.setKeepAnimationInFrame(checked);
                            },
                            boxLabel: "Keep animation in frame"
                        }]

                    },{
                        xtype: "container",
                        text: "&nbsp;"
                    },{
                        xtype: 'button',
                        text: 'remove',
                        scope:this,
                        //margin: 3,
                        handler: function(cmp) {
                            // assumes coupling with dreamscape
                            this.fireEvent("removeFilterWidget", this);
                            cmp.ownerCt.ownerCmp.destroy();
                        }
                    }]
                }
            });
        this.callParent([config]);
        this.on("afterrender", function(cmp) {
            cmp.getTargetEl().down('.x-btn-glyph').setStyle('color', this.getColor());
            var panel = cmp.up("panel")
            panel.mask(cmp.localize("loading"));
            cmp.loadGeonames().then(function(geonames) {
                panel.unmask();
                if (panel.getFilterWidgets().getCount()==1) {
                    var currentCitiesCount = geonames.getCitiesCount(),
                        totalCitiesCount = geonames.getTotalCitiesCount(),
                        currentConnectionsCount = geonames.getConnectionsCount(),
                        totalConnectionsCount = geonames.getTotalConnectionsCount();
                    message = cmp.localize(currentCitiesCount==totalCitiesCount && currentConnectionsCount==totalConnectionsCount ? "loadedAll" : "loadedSome") +
                        "<br><br>"+cmp.localize("disclaimer");
                    panel.toastInfo({
                        autoCloseDelay: 5000,

                        closable: true,
                        maxWidth: '90%',
                        html: new Ext.Template(cmp.localize("disclaimer")).apply({
                            currentCitiesCount: currentCitiesCount,
                            totalCitiesCount: totalCitiesCount,
                            currentConnectionsCount: currentConnectionsCount,
                            totalConnectionsCount: totalConnectionsCount,
                            url: panel.getBaseUrl()+"docs/#!/guide/dreamscape"
                        })

                    });
                }
            })
        }, this);
    },
    loadGeonames: function(params) {
        var me = this;
        params = params || {};

        // add queries
        var queries  = [];
        this.query('querysearchfield').forEach(function(querysearchfield) {
            var id = querysearchfield.getItemId();
            querysearchfield.getValue().forEach(function(query) {
                queries.push(id+":"+query);
            })
        });
        var pubDateSlider = this.down("multislider");
        if (pubDateSlider && pubDateSlider.isVisible()) {
            var vals = pubDateSlider.getValue();
            queries.push(pubDateSlider.tokenType+":["+vals[0]+"-"+vals[1]+"]")
        }
        if (queries.length>0 && !("query" in params)) {params.query=queries;}

        // add params from tool
        var panel  = this.up('panel');
        if (panel && panel.getApiParams) {
            Ext.applyIf(params, panel.getApiParams(["minPopulation","connectionsMaxCount","connectionsMinFreq","source","overridesId","filterHasLowerCaseForm","filterIsPersonName","preferredCoordinates"]))
        }

        this.mask("");
        var geonames = this.getGeonames();
        return geonames.load(params).then(function() {
            me.unmask();
            me.fireEvent("filterUpdate", me, geonames);
            return geonames;
        });
    },

    clearAnimation: function() {
        if (this.getTimeout()) {clearTimeout(this.getTimeout());}
    },

    animate: function() {
        var panel = this.up('panel');
        if (!panel) {return;}
        this.clearAnimation();
        var currentConnectionOccurrence = this.getCurrentConnectionOccurrence();
        if (currentConnectionOccurrence) {
            var animationLayer = this.getAnimationLayer();
            if (!animationLayer) {
                animationLayer = this.up('panel').getMap().getLayer(this.getId()+"-animation");
                this.setAnimationLayer(animationLayer);
            }
            if (animationLayer) {
                var features = animationLayer.getSource().getFeatures();
                if (features.length==0) {
                    if (!panel) {return;}
                    var connectionsLayerSource = panel.getMap().getLayer(this.getId()+"-connections").getSource();
                    var connectionsFeatures = connectionsLayerSource.getFeatures();
                    var hasMatch = false;
                    for (var i=0, len=connectionsFeatures.length; i<len; i++) {
                        if (currentConnectionOccurrence.source.id==connectionsFeatures[i].get("source") && currentConnectionOccurrence.target.id==connectionsFeatures[i].get("target")) {
                            hasMatch = connectionsFeatures[i];
                            break;
                        }
                    }
                    if (hasMatch) {
                        // check to see if we need to reposition the map, use displayed feature as basis for extent
                        if(this.getKeepAnimationInFrame()) {
                            var map = panel.getMap();
                            var extent = panel.getMap().getView().calculateExtent(map.getSize());
                            var isVisible = ol.extent.containsExtent(extent, hasMatch.getGeometry().getExtent());
                            if(!isVisible) {
                                newExtent = ol.extent.extend(extent, hasMatch.getGeometry().getExtent());
                                map.getView().fit(newExtent);
                            }
                        }

                        var arcGenerator = new arc.GreatCircle(
                            {x: currentConnectionOccurrence.source.lng, y: currentConnectionOccurrence.source.lat},
                            {x: currentConnectionOccurrence.target.lng, y: currentConnectionOccurrence.target.lat});
                        var arcLine = arcGenerator.Arc(100, {offset: 100});
                        var label = currentConnectionOccurrence.source.label+" -> "+currentConnectionOccurrence.target.label;
                        arcLine.geometries.forEach(function(geometry) {
                            var line = new ol.geom.LineString([]); // can be empty since we generate a line during next animate call
                            line.transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857'));
                            var feature = new ol.Feature({
                                geometry: line,
                                allcoords: geometry.coords ,
                                text: label,
                                color: this.getColor(),
                                width: 5,
                                start: new Date().getTime()
                            });
                            animationLayer.getSource().addFeature(feature);
                        }, this);

                        var ticker = panel.body.down(".ticker");

                        panel.body.down(".ticker").setHtml(
                            currentConnectionOccurrence.source.left+" <span class='keyword'>"+currentConnectionOccurrence.source.term+"</span> "+currentConnectionOccurrence.source.right+"  "+
                            currentConnectionOccurrence.target.left+" <span class='keyword'>"+currentConnectionOccurrence.target.term+"</span> "+currentConnectionOccurrence.target.right
                        );
                        return this.setTimeout(setTimeout(this.animate.bind(this), 1));

                    } else {
                        if (!this.getGeonames()) {return;}
                        currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence.index+1);
                        this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                        animationLayer.getSource().clear();
                        return this.setTimeout(setTimeout(this.animate.bind(this), 1));

                    }
                } else if (features.length>0) {

                    var coords = features[0].getGeometry().getCoordinates(),
                        allcoords = features[0].get("allcoords");
                    if (coords.length<allcoords.length) {
                        var elapsed = new Date().getTime()-features[0].get('start'),
                            len = elapsed*allcoords.length/this.getMillisPerAnimation()
                        line = new ol.geom.LineString(allcoords.slice(0,len));
                        line.transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857'));
                        features[0].set("geometry", line);
                        return this.setTimeout(setTimeout(this.animate.bind(this), 25));

                    }
                    // if we get here, all features should have been changed
                    currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence.index+1);
                    if(!this.getStepByStepMode()) {
                        this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                        animationLayer.getSource().clear();
                        return this.setTimeout(setTimeout(this.animate.bind(this), 1));
                    }
                }
            }
        } else {
            if (!this.getGeonames()) {return;}
            currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(0);
            if (currentConnectionOccurrence) {
                this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                return this.setTimeout(setTimeout(this.animate.bind(this), 1));
            }
        }
    }
});

// assuming Knots library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Knots', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.knots',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
        	 * @property query A string to search for in a document.
        	 * @type String
    		 * @private
        	 */
    		query: null,
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		/**
    		 * @property docId The document ID to restrict results to.
    		 * @type String
    		 * @private
    		 */
    		docId: undefined,
    		
    		audio: false
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
		knots: undefined,
		termStore: undefined,
		docTermStore: undefined,
		tokensStore: undefined,
    	options: [{xtype: 'stoplistoption'},{xtype: 'colorpaletteoption'}],
    	refreshInterval: 100,
    	startAngle: 315,
    	angleIncrement: 15,
    	currentTerm: undefined
	},
	
	termTpl: new Ext.XTemplate(
		'<tpl for=".">',
			'<div class="term" style="color: rgb({color});float: left;padding: 3px;margin: 2px;">{term}</div>',
		'</tpl>'
	),
	
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		var firstDoc = corpus.getDocument(0);
    		var pDoc = this.processDocument(firstDoc);
    		this.getKnots().setCurrentDoc(pDoc);
    		
    		this.setApiParams({docId: firstDoc.getId()});
    		this.getDocTermStore().getProxy().setExtraParam('corpus', corpus.getId());
    		this.getTokensStore().setCorpus(corpus);
    		this.getDocTermStore().load({params: {
		    	limit: 5,
		    	stopList: this.getApiParams('stopList')
		    }});
    	}, this);
    	
        this.on('activate', function() { // load after tab activate (if we're in a tab panel)
			if (this.getCorpus()) {				
				Ext.Function.defer(function() {
					this.getDocTermStore().load({params: {
				    	limit: 5,
				    	stopList: this.getApiParams('stopList')
				    }});
				}, 100, this);
			}
    	}, this);
        
        this.on('query', function(src, query) {
    		if (query !== undefined && query != '') {
    			this.getDocTermsFromQuery(query);
    		}
    	}, this);
        
        this.on('documentSelected', function(src, doc) {
        	
        	var document = this.getCorpus().getDocument(doc)
        	this.setApiParam('docId', document.getId());
        	
        	var terms = this.getKnots().currentDoc.terms;
        	var termsToKeep = [];
        	for (var t in terms) {
        		termsToKeep.push(t);
        	}
        	
//        	this.getTermStore().removeAll();
    		this.setApiParams({query: termsToKeep});
    		
    		var limit = termsToKeep.length;
    		if (limit === 0) {
    			limit = 5;
    		}
        	
        	this.getKnots().setCurrentDoc(this.processDocument(document));
        	
        	this.getDocTermStore().load({params: {
		    	query: termsToKeep,
		    	limit: limit,
		    	stopList: this.getApiParams('stopList')
		    }});
        }, this);
        
        this.on('termsClicked', function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (Ext.isString(term)) {queryTerms.push(term);}
    			else if (term.term) {queryTerms.push(term.term);}
    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
    		});
    		if (queryTerms.length > 0) {
    			this.getDocTermsFromQuery(queryTerms);
    		}
		}, this);
        
		this.on('corpusTermsClicked', function(src, terms) {
			var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.getDocTermsFromQuery(queryTerms);
		}, this);
		
		this.on('documentTermsClicked', function(src, terms) {
			var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.getDocTermsFromQuery(queryTerms);
		}, this);
    },
    
    initComponent: function() {
    	this.setTermStore(Ext.create('Ext.data.ArrayStore', {
	        fields: ['term', 'color']
	    }));
    	
    	this.setDocTermStore(Ext.create("Ext.data.Store", {
			model: "Voyant.data.model.DocumentTerm",
    		autoLoad: false,
    		remoteSort: false,
    		proxy: {
				type: 'ajax',
				url: Voyant.application.getTromboneUrl(),
				extraParams: {
					tool: 'corpus.DocumentTerms',
					withDistributions: 'raw',
					withPositions: true
				},
				reader: {
					type: 'json',
		            rootProperty: 'documentTerms.terms',
		            totalProperty: 'documentTerms.total'
				},
				simpleSortMode: true
   		     },
   		     listeners: {
   		    	 beforeload: function(store) {
   		    		 store.getProxy().setExtraParam('docId', this.getApiParam('docId'));
   		    	 },
   		    	 load: function(store, records, successful, options) {
   		    		var termObj = {};
   		    		if (records && records.length>0) {
   	   		    		records.forEach(function(record) {
   	   		    			var termData = this.processTerms(record);
   	   		    			var docId = record.get('docId');
   	   		    			var term = record.get('term');
   	   		    			termObj[term] = termData;
   	   		    		}, this);
   	   		    		this.getKnots().addTerms(termObj);
   	   		    		this.getKnots().buildGraph();
   		    		}
   		    		else {
   		    			this.toastInfo({
   		    				html: this.localize("noTermsFound"),
   		    				align: 'bl'
   		    			})
   		    		}
   				},
   				scope: this
   		     }
    	}));
    	
    	this.setTokensStore(Ext.create("Voyant.data.store.Tokens", {
        	stripTags: "all",
        	listeners: {
        		beforeload: function(store) {
  		    		 store.getProxy().setExtraParam('docId', this.getApiParam('docId'));
  		    	},
        		load: function(store, records, successful, options) {
        			var context = '';
        			var currTerm = this.getCurrentTerm();
        			records.forEach(function(record) {
        				if (record.getPosition() == currTerm.tokenId) {
        					context += '<strong>'+record.getTerm()+'</strong>';
        				} else {
        					context += record.getTerm();
        				}
        			});
        			
        			Ext.Msg.show({
        				title: this.localize('context'),
        				message: context,
        				buttons: Ext.Msg.OK,
        			    icon: Ext.Msg.INFO
        			});
        		},
   				scope: this
        	}
        }));
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                },{
	            	text: this.localize('clearTerms'),
	            	glyph: 'xf00d@FontAwesome',
	            	handler: function() {
	            		this.down('#termsView').getSelectionModel().deselectAll(true);
	            		this.getTermStore().removeAll();
	            		this.setApiParams({query: null});
	            		this.getKnots().removeAllTerms();
	            		this.getKnots().drawGraph();
	            	},
	            	scope: this
	            },{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					itemId: 'speed',
					fieldLabel: this.localize("speed"),
					labelAlign: 'right',
					labelWidth: 50,
					width: 100,
					increment: 50,
					minValue: 0,
					maxValue: 500,
					value: 500-this.getRefreshInterval(),
					listeners: {
						changecomplete: function(slider, newvalue) {
							this.setRefreshInterval(500-newvalue);
							if (this.getKnots()) {this.getKnots().buildGraph();}
						},
						scope: this
					}
				},{
					xtype: 'slider',
					itemId: 'startAngle',
					fieldLabel: this.localize('startAngle'),
					labelAlign: 'right',
					labelWidth: 35,
					width: 85,
					increment: 15,
					minValue: 0,
					maxValue: 360,
					value: this.getStartAngle(),
					listeners: {
						changecomplete: function(slider, newvalue) {
							this.setStartAngle(newvalue);
							if (this.getKnots()) {this.getKnots().buildGraph();}
						},
						scope: this
					}
				},{
					xtype: 'slider',
					itemId: 'tangles',
					fieldLabel: this.localize('tangles'),
					labelAlign: 'right',
					labelWidth: 30,
					width: 80,
					increment: 5,
					minValue: 5,
					maxValue: 90,
					value: this.getAngleIncrement(),
					listeners: {
						changecomplete: function(slider, newvalue) {
							this.setAngleIncrement(newvalue);
							if (this.getKnots()) {this.getKnots().buildGraph();}
						},
						scope: this
					}
				},{
	                xtype: 'checkbox',
	                boxLabel: this.localize('sound'),
	                listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(this.getApiParam("audio")===true ||  this.getApiParam("audio")=="true")
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('soundTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    change: function(cmp, val) {
	                    	if (this.getKnots()) {
		                    	this.getKnots().setAudio(val);
	                    	}
	                    },
	                    scope: this
	                }
	            }]
    		}],
            border: false,
            layout: 'fit',
            items: {
            	layout: {
            		type: 'vbox',
            		align: 'stretch'
            	},
            	defaults: {border: false},
	            items: [{
	            	height: 30,
	            	itemId: 'termsView',
	            	xtype: 'dataview',
	            	store: this.getTermStore(),
	            	tpl: this.termTpl,
	            	itemSelector: 'div.term',
	            	overItemCls: 'over',
	            	selectedItemCls: 'selected',
	            	selectionModel: {
	            		mode: 'SIMPLE'
	            	},
//	            	cls: 'selected', // default selected
	            	focusCls: '',
	            	listeners: {
	            		beforeitemclick: function(dv, record, item, index, event, opts) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			dv.fireEvent('itemcontextmenu', dv, record, item, index, event, opts);
	            			return false;
	            		},
	            		beforecontainerclick: function() {
	            			// cancel deselect all
	            			event.preventDefault();
	            			event.stopPropagation();
	            			return false;
	            		},
	            		selectionchange: function(selModel, selections) {
	            			var dv = this.down('#termsView');
	            			var terms = [];
	            			
	            			dv.getStore().each(function(r) {
	            				if (selections.indexOf(r) !== -1) {
	            					terms.push(r.get('term'));
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('unselected').addCls('selected');
	            				} else {
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('selected').addCls('unselected');
	            				}
	            			});
	            			
	            			this.getKnots().termsFilter = terms;
	            			this.getKnots().drawGraph();
	            		},
	            		itemcontextmenu: function(dv, record, el, index, event) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			var isSelected = dv.isSelected(el);
	            			var menu = new Ext.menu.Menu({
	            				floating: true,
	            				items: [{
	            					text: isSelected ? this.localize('hideTerm') : this.localize('showTerm'),
	            					handler: function() {
	            						if (isSelected) {
	            							dv.deselect(index);
	            						} else {
	            							dv.select(index, true);
	            						}
	            					},
	            					scope: this
	            				},{
	            					text: this.localize('removeTerm'),
	            					handler: function() {
	            						dv.deselect(index);
	            						var term = this.getTermStore().getAt(index).get('term');
	            						this.getTermStore().removeAt(index);
	            						dv.refresh();
	            						
	            						this.getKnots().removeTerm(term);
	            						this.getKnots().drawGraph();
	            					},
	            					scope: this
	            				}]
	            			});
	            			menu.showAt(event.getXY());
	            		},
	            		scope: this
	            	}
	            },{
	            	flex: 1,
	            	xtype: 'container',
	            	autoEl: 'div',
	            	itemId: 'canvasParent',
	            	layout: 'fit',
	            	overflowY: 'auto',
	            	overflowX: 'hidden'
	            }],
	            listeners: {
	            	render: function(component) {
	            		var canvasParent = this.down('#canvasParent');
	                	this.setKnots(new Knots({
	                		container: canvasParent,
	                		clickHandler: this.knotClickHandler.bind(this),
	                		audio: this.getApiParam("audio")===true ||  this.getApiParam("audio")=="true"
	                	}));
	            	},
            		afterlayout: function(container) {
            			if (this.getKnots().initialized === false) {
            				this.getKnots().initializeCanvas();
            			}
            		},
	        		resize: function(cnt, width, height) {
	        			this.getKnots().doLayout();
	        		},
            		scope: this
            	}
            }
		});
    	
    	this.callParent(arguments);
    },
    
    updateRefreshInterval: function(value) {
    	if (this.getKnots()) {
    		if (value < 50) {
    			value = 50;
    			this.getKnots().progressiveDraw = false;
    		} else {
    			this.getKnots().progressiveDraw = true;
    		}
    		this.getKnots().refreshInterval = value;
			this.getKnots().buildGraph(this.getKnots().drawStep);
    	}
    },
    
    updateStartAngle: function(value) {
    	if (this.getKnots()) {
			this.getKnots().startAngle = value;
			this.getKnots().recache();
			this.getKnots().buildGraph();
    	}
    },
    
    updateAngleIncrement: function(value) {
    	if (this.getKnots()) {
	    	this.getKnots().angleIncrement = value;
			this.getKnots().recache();
			this.getKnots().buildGraph();
    	}
    },
    
    loadFromCorpusTerms: function(corpusTerms) {
    	if (this.getKnots()) { // get rid of existing terms
    		this.getKnots().removeAllTerms();
    		this.getTermStore().removeAll(true);
    	}
		corpusTerms.load({
		    callback: function(records, operation, success) {
		    	var query = []; //this.getApiParam('query') || [];
				if (typeof query == 'string') query = [query];
		    	records.forEach(function(record, index) {
					query.push(record.get('term'));
				}, this);
		    	this.getDocTermsFromQuery(query);
		    },
		    scope: this,
		    params: {
		    	limit: 5,
		    	stopList: this.getApiParams('stopList')
		    }
    	});
    },
    
    /**
     * Get the results for the query(s) for each of the corpus documents.
     * @param query {String|Array}
     * @private
     */
    getDocTermsFromQuery: function(query) {
    	if (query) {this.setApiParam("query", query);} // make sure it's set for subsequent calls
    	var corpus = this.getCorpus();
    	if (corpus && this.isVisible()) {
    		this.setApiParams({query: query}); // assumes docId already set
			this.getDocTermStore().load({params: this.getApiParams()});
    	}
	},
    
	reloadTermsData: function() {
		var terms = [];
		for (var term in this.bubblelines.currentTerms) {
			terms.push(term);
		}
		this.getDocTermsFromQuery(terms);
	},
	
    filterDocuments: function() {
		var docIds = this.getApiParam('docId');
		if (docIds == '') {
			docIds = [];
			this.getCorpus().getDocuments().each(function(item, index) {
				docIds.push(item.getId());
			});
			this.setApiParams({docId: docIds});
		}
		if (typeof docIds == 'string') docIds = [docIds];
		
		if (docIds == null) {
			this.selectedDocs = this.getCorpus().getDocuments().clone();
			var count = this.selectedDocs.getCount();
			if (count > 10) {
				for (var i = 10; i < count; i++) {
					this.selectedDocs.removeAt(10);
				}
			}
			docIds = [];
			this.selectedDocs.eachKey(function(docId, doc) {
				docIds.push(docId);
			}, this);
			this.setApiParams({docId: docIds});
		} else {
			this.selectedDocs = this.getCorpus().getDocuments().filterBy(function(doc, docId) {
				return docIds.indexOf(docId) != -1;
			}, this);
		}
	},
	
	// produce format that knots can use
	processDocument: function(doc) {
		var title = doc.getShortTitle();
		title = title.replace('&hellip;', '...');
	
		return {
			id: doc.getId(),
			index: doc.get('index'),
			title: title,
			totalTokens: doc.get('tokensCount-lexical'),
			terms: {},
			lineLength: undefined
		};
	},
	
	processTerms: function(termRecord) {
		var termObj;
		var term = termRecord.get('term');
		var rawFreq = termRecord.get('rawFreq');
		var positions = termRecord.get('positions');
		if (rawFreq > 0) {
			var color = this.getApplication().getColorForTerm(term);
			if (this.getTermStore().find('term', term) === -1) {
				this.getTermStore().loadData([[term, color]], true);
				var index = this.getTermStore().find('term', term);
				this.down('#termsView').select(index, true); // manually select since the store's load listener isn't triggered
			}
			var distributions = termRecord.get('distributions');
			termObj = {term: term, positions: positions, distributions: distributions, rawFreq: rawFreq, color: color};
		} else {
			termObj = false;
		}
		
		return termObj;
	},
	
	knotClickHandler: function(data) {
		this.setCurrentTerm(data);
		var start = data.tokenId - 10;
		if (start < 0) start = 0;
		this.getTokensStore().load({
			start: start,
			limit: 21
		});
		
		data = [data].map(function(item) {return item.term}); // make an array for the event dispatch
		this.getApplication().dispatchEvent('termsClicked', this, data);
	}
});
Ext.define('Voyant.panel.Phrases', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.phrases',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		sort: 'length',
    		dir: 'desc',
    		minLength: 2,
    		maxLength: 50,
    		overlapFilter: 'length'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    constructor: function(config) {
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.isVisible()) {
            	if (this.hasCorpusAccess(corpus)==false) {
            		this.mask(this.localize('limitedAccess'), 'mask-no-spinner');
            	} else {
        			this.loadFromApis();
            	}
    		}
    		
    	});
    	
    	if (config.embedded) {
//    		var cls = Ext.getClass(config.embedded).getName();
//    		if (cls=="Voyant.data.store.DocumentTerms" || cls=="Voyant.data.model.Document") {
//    			this.fireEvent('loadedCorpus', this, config.embedded.getCorpus())
//    		}
    	}
    	else if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus)
    	}
    	
    	this.on("corpusTermsClicked", function(src, terms) {
    		if (this.getStore().getCorpus()) { // make sure we have a corpus
        		var query = [];
        		terms.forEach(function(term) {
        			query.push(term.get("term"));
        		})
        		this.setApiParams({
        			query: query,
        			docId: undefined,
        			docIndex: undefined
        		});
        		if (this.isVisible()) {
            		this.getStore().load({params: this.getApiParams()});
        		}
    		}
    	});
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {this.loadFromApis()}
    	}, this)
    	
    	this.on("query", function(src, query) {
    		this.setApiParam("query", query);
    		this.getStore().getProxy().setExtraParam("query", query);
    		this.loadFromApis();
    	}, this)
    },
    
    loadFromApis: function() {
    	if (this.getStore().getCorpus()) {
    			this.getStore().load({params: this.getApiParams()});
    	}
    },
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.CorpusNgramsBuffered", {
        	parentPanel: me
        });
        
        store.on("beforeload", function(store) {
    		return me.hasCorpusAccess(store.getCorpus());
        });
        me.on("sortchange", function( ct, column, direction, eOpts ) {
        	this.setApiParam('sort', column.dataIndex);
        	this.setApiParam('dir', direction);
        	var api = this.getApiParams(["stopList", "query", "docId", "docIndex", "sort", "dir", "minLength", "maxLength", "overlapFilter"]);
        	var proxy = this.getStore().getProxy();
        	for (var key in api) {proxy.setExtraParam(key, api[key]);}
        }, me)

        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		var terms = [];
                    		var context = this.getApiParam("context")
                    		selections.forEach(function(selection) {
                    			terms.push('"'+selection.getTerm()+'"')
                    		})
                    		this.getApplication().dispatchEvent('termsClicked', this, terms);
                    	},
                    	scope: this
                    }
                }
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }, '-', {
                	text: me.localize('length'),
                	tooltip: 'test',
                	xtype: 'label'
                }, {
                	xtype: 'slider',
                	minValue: 2,
                	values: [2, 30],
                	maxValue: 30,
                	increment: 1,
                	width: 75,
                	tooltip: this.localize("lengthTip"),
                	listeners: {
                		render: {
                			fn: function(slider) {
                				var values = slider.getValues();
                				slider.setValue(0, parseInt(this.getApiParam("minLength", values[0])))
                				slider.setValue(1, parseInt(this.getApiParam("maxLength", values[1])))
	                		},
	                		scope: me
                		},
                		changecomplete: {
                			fn: function(slider, newValue) {
                				var values = slider.getValues();
                				this.setApiParam("minLength", parseInt(values[0]));
                				this.setApiParam("maxLength", parseInt(values[1]));
                        		this.getStore().load({params: this.getApiParams()});
                    		},
                    		scope: me
                		}
                	}
                }, {
        			xtype: 'corpusdocumentselector'
        		}, '-', {
                    xtype: 'button',
                    text: this.localize('overlap'),
                    tooltip: this.localize('overlapTip'),
                    menu: {
                    	items: [
                           {
                        	   xtype: 'menucheckitem',
                               text: this.localize("overlapNone"),
                               group: 'overlap',
                               inputValue: 'none',
                               checkHandler: function() {
                            	   this.setApiParam('overlapFilter', 'none')
                            	   this.getStore().load({params: this.getApiParams()})
                               },
                               scope: this
                           }, {
                        	   xtype: 'menucheckitem',
                               text: this.localize("overlapLength"),
                               group: 'overlap',
                               inputValue: 'length',
                               checkHandler: function() {
                            	   this.setApiParam('overlapFilter', 'length')
                            	   this.getStore().load({params: this.getApiParams()})
                               },
                               scope: this
                           }, {
                        	   xtype: 'menucheckitem',
                               text: this.localize("overlapFreq"),
                               group: 'overlap',
                               inputValue: 'rawFreq',
                               checkHandler: function() {
                            	   this.setApiParam('overlapFilter', 'rawfreq')
                            	   this.getStore().load({params: this.getApiParams()})
                               },
                               scope: this
                           }
	                   ],
	                   listeners: {
	                	   afterrender: {
	                		   fn: function(menu) {
	                			   var overlapFilter = this.getApiParam('overlapFilter');
	                			   menu.items.each(function(item) {
	                				   if (item.group) {
	                					   item.setChecked(item.inputValue==overlapFilter);
	                				   }
	                			   }, this)
	                		   },
	                		   scope: this
	                	   }
                
	                   }
                    }
                }]
            }],
    		columns: [{
    			text: this.localize("term"),
        		dataIndex: 'term',
            	tooltip: this.localize("termTip"),
                sortable: true,
                flex: 1
            },{
    			text: this.localize("rawFreq"),
        		dataIndex: 'rawFreq',
            	tooltip: this.localize("termRawFreqTip"),
                sortable: true,
                width: 'autoSize'
            },{
            	text: this.localize("length"),
            	dataIndex: 'length',
            	tooltip: this.localize("lengthTip"),
            	sortable: true,
                width: 'autoSize'
            },{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize('trendTip'),
                width: 120,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline'
                }
            }],
            
            listeners: {
				corpusSelected: function() {
					this.setApiParams({docIndex: undefined, docId: undefined});
					this.loadFromApis();
				},
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined})
					this.loadFromApis();
				},
            	termsClicked: {
            		fn: function(src, terms) {
                		if (this.getStore().getCorpus()) { // make sure we have a corpus
                    		var queryTerms = [];
                    		terms.forEach(function(term) {
                    			if (Ext.isString(term)) {queryTerms.push(term);}
                    			else if (term.term) {queryTerms.push(term.term);}
                    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
                    		});
                    		if (queryTerms.length > 0) {
                    			this.setApiParams({
                    				docIndex: undefined,
                    				docId: undefined,
                    				query: queryTerms
                    			});
                        		if (this.isVisible()) {
                            		if (this.isVisible()) {
                                		this.getStore().clearAndLoad({params: this.getApiParams()});
                            		}
                        		}
                    		}
                		}
                	},
                	scope: this
            	}
            }
        });

        me.callParent(arguments);
        
        me.getStore().getProxy().setExtraParam("withDistributions", true);
        
    }
    
})
/**
 * Corpus Terms tool, a grid that shows the terms in the corpus.
 * 
 * <iframe src="../?corpus=austen&view=corpusterms" style="max-width: 500px; height: 300px"></iframe>
 * 
 * The typical use is not to instantiate this class directly, but to embed the tool from a corpus.
 * 
 * 		var austen;
 * 		new Corpus("austen").then(function(corpus) {
 * 			austen = corpus;
 * 			austen.embed('CorpusTerms'); // simply embed
 * 			austen.embed('CorpusTerms', {query: '^lov*'}); // embed with query
 * 		});
 */
Ext.define('Voyant.panel.CorpusTerms', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.corpusterms',
    statics: {
    	i18n: {
    	},
    	api: {
    		
    		/**
    		 * @cfg {String} stopList A comma-separated list of words, a named list or a URL to a plain text list, one word per line.
    		 * 
    		 *  By default this is set to 'auto' which auto-detects the document's language and loads an appropriate list (if available for that language). Set this to blank to not use the default stopList.
    		 *  
    		 * For more information see the <a href="#!/guide/search">Stopwords documentation</a>.
    		 */
    		stopList: 'auto',
    		
    		/**
    		 * @cfg {String/String[]} query A query or array of queries (queries can be separated by a comma).
    		 * 
    		 * For query syntax, see the <a href="#!/guide/search">search documentation</a>.
    		 */
    		query: undefined,
    		
    		/**
    		 * @cfg {Number} maxBins The maximum number of bins to use for distributions in Trend.
    		 * 
    		 * By default this is set to 100 (in other words, if there are more than 100 documents in the corpus, they will be forced into 100 bins).
    		 * Higher values are possible but it can cause performance issues and necessitate more data transfer (values for each one of the bins for each one of the terms).
    		 * @cfg
    		 */
    		maxBins: 100,
    		
    		/**
    		 * @cfg {String} comparisonCorpus An existing corpus to be used for comparison purposes.
    		 * 
    		 * None of the columns visible by default use comparisonCorpus so this is an advanced parameter used when the "Comparison" column is shown.
    		 * The comparison column shows the relative frequency of the term in the corpus compared to the relative frequency of the same term in a comparison corpus.
    		 */
    		comparisonCorpus: undefined
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	/**
    	 * @private
    	 */
    	options: [{
    		xtype: 'stoplistoption'
    	},{
    		xtype: 'corpusselector',
    		name: 'comparisonCorpus',
    		fieldLabel: 'comparison corpus'
    	}]
    },
	/**
	 * @private
	 */
    constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.CorpusTermsBuffered", {
        	parentPanel: this,
        	proxy: {
        		extraParams: {
        			withDistributions: 'relative',
        			forTool: 'corpusterms'
        		}
        	}
        });
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                pruneRemoved: false,
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		if (selections && selections.length>0) {
                        		this.getApplication().dispatchEvent('corpusTermsClicked', this, selections);
                    		}
                    	},
                    	scope: this
                    }
                },
                mode: 'SIMPLE'
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }]
            }],
            
            plugins: [{
                ptype: 'rowexpander',
                rowBodyTpl: new Ext.XTemplate('')
            }],
            viewConfig: {
                listeners: {
                    // TODO widget disappears when scrolled off screen
                    expandbody: function(rowNode, record, expandRow, eOpts) {
                        if (expandRow.innerText==='' || (eOpts && eOpts.force)) {
                            Ext.create('Voyant.widget.CorpusTermSummary', {
                                record: record,
                                header: false,
                                renderTo: expandRow.querySelector('div')
                            });
                        }
                    },
                    scope: this
                }
            },

    		columns: [{
                xtype: 'rownumberer',
                width: 'autoSize',
                sortable: false
            },{
    			text: this.localize("term"),
            	tooltip: this.localize("termTip"),
        		dataIndex: 'term',
        		flex: 1,
                sortable: true
            },{
            	text: this.localize("rawFreq"),
            	tooltip: this.localize("rawFreqTip"),
            	dataIndex: 'rawFreq',
                width: 'autoSize',
            	sortable: true
            },{
            	text: this.localize("relativeFreq"),
            	tooltip: this.localize("relativeFreqTip"),
            	dataIndex: 'relativeFreq',
            	renderer: function(val) {
            		var percent = val*100;
            		return Ext.util.Format.number(val*1000000, "0,000")/* + " (%"+
            			(val*100 <  .1 ? "<0.1" : Ext.util.Format.number(val*100, "0.0"))+")"*/
            	},
                width: 'autoSize',
                hidden: true,
            	sortable: true
            },{
            	text: this.localize("relativePeakedness"),
            	tooltip: this.localize("relativePeakednessTip"),
            	dataIndex: 'relativePeakedness',
            	renderer: Ext.util.Format.numberRenderer("0,000.0"),
                width: 'autoSize',
                hidden: true,
            	sortable: true
            },{
            	text: this.localize("relativeSkewness"),
            	tooltip: this.localize("relativeSkewnessTip"),
            	dataIndex: 'relativeSkewness',
            	renderer: Ext.util.Format.numberRenderer("0,000.0"),
                width: 'autoSize',
                hidden: true,
            	sortable: true
            },{
            	text: this.localize("corpusComparisonDifference"),
            	tooltip: this.localize("corpusComparisonDifferenceTip"),
            	dataIndex: 'comparisonRelativeFreqDifference',
            	renderer: Ext.util.Format.numberRenderer("0,000.00000"),
                width: 'autoSize',
                hidden: !this.getApiParam('comparisonCorpus'),
            	sortable: true,
            	listeners: {
            		show: function(ct, column, eopts) {
            			if (!me.getApiParam('comparisonCorpus')) {
            				me.showError(me.localize('noCorpusComparison'))
            			}
            		}
            	}
            },{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize("trendTip"),
                flex: 1,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline',
                    tipTpl: new Ext.XTemplate('{[this.getDocumentTitle(values.x,values.y)]}', {
                    	getDocumentTitle: function(docIndex, relativeFreq) {
                    		return this.panel.store.getCorpus().getDocument(docIndex).getTitle()+"<br>"+this.panel.localize("relativeFreqLabel")+" "+Ext.util.Format.number(relativeFreq*1000000, "0,000")
                    	},
                    	panel: me 
                    })
                }
            }]
        });
        
    	me.on('loadedCorpus', function(src, corpus) {
//    		this.setApiParam('query', undefined);
    		if (corpus.getDocumentsCount()>100) {
    			this.getStore().getProxy().setExtraParam('bins', this.getApiParam('maxBins'));
    		}
    		if (this.isVisible()) {
        		this.getStore().load()
    		}
    	}, me);
    	
    	me.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (me.getStore().getCorpus()) {
    			me.getStore().load({params: this.getApiParams()});
    		}
    	}, me);

    	
    	me.on("query", function(src, query) {
    		this.setApiParam('query', query);
    		this.getStore().removeAll();
    		this.getStore().load();
    	}, me);


        me.callParent(arguments);
        
    }
})

Ext.define('Voyant.panel.DocumentTerms', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Voyant.data.store.DocumentTerms'],
	alias: 'widget.documentterms',
	config: {
		options: {
    		xtype: 'stoplistoption'
    	}
    },
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		bins: 10
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    constructor: function(config) {
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		var store = this.getStore();
    		store.setCorpus(corpus);
    		if (this.isVisible()) {
        		store.load();
    		}
    	});
    	
    	if (config.embedded) {
    		if (window.console) {
    			console.warn(config.embedded.then);
    		}
    		var cls = Ext.getClass(config.embedded).getName();
    		if (cls=="Voyant.data.store.DocumentTerms" || cls=="Voyant.data.model.Document") {
    			this.fireEvent('loadedCorpus', this, config.embedded.getCorpus());
    		}
    	}
    	else if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus);
    	}
    	
    	this.on("query", function(src, query) {
    		this.fireEvent("corpusTermsClicked", src, query);
    	}, this);
    	
    	this.on("corpusTermsClicked", function(src, terms) {
    		if (this.getStore().getCorpus()) { // make sure we have a corpus
        		var query = [];
        		terms.forEach(function(term) {
        			query.push(Ext.isString(term) ? term : term.get("term"));
        		});
        		this.setApiParams({
        			query: query,
        			docId: undefined,
        			docIndex: undefined
        		});
        		if (this.isVisible()) {
            		this.getStore().load({params: this.getApiParams()});
        		}
    		}
    	});
    	
    	this.on("documentsClicked", function(src, documents) {
    		var docIds = [];
    		documents.forEach(function(doc) {docIds.push(doc.get('id'));});
    		this.setApiParams({
    			docId: docIds,
    			query: undefined
    		});
    		if (this.isVisible()) {
        		this.getStore().load({params: this.getApiParams()});
    		}
    	});
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {
    			this.getStore().load({params: this.getApiParams()});
    		}
    	}, this);
    },
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.DocumentTermsBuffered", {parentPanel: this});
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		this.getApplication().dispatchEvent('documentTermsClicked', this, selections);
                    	},
                    	scope: this
                    }
                },
                pruneRemoved: false,
    			mode: 'SIMPLE'
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }]
            }],
    		columns: [{
    			text: '#',
    			width: 30,
        		dataIndex: 'docIndex',
                sortable: true,
                renderer: function(v) {return v+1;} // 0-based to 1-based
            },{
    			text: this.localize("term"),
        		dataIndex: 'term',
            	tooltip: this.localize("termTip"),
                sortable: true,
                flex: 1
            },{
            	text: this.localize("rawFreq"),
            	dataIndex: 'rawFreq',
            	tooltip: this.localize("rawFreqTip"),
            	width: 'autoSize',
            	sortable: true
            },{
            	text: this.localize("relativeFreq"),
            	tooltip: this.localize("relativeFreqTip"),
            	dataIndex: 'relativeFreq',
            	width: 'autoSize',
            	sortable: true,
            	renderer: Ext.util.Format.numberRenderer('0,000')
            },{
            	text: this.localize("tfidf"),
            	tooltip: this.localize("tfidfTip"),
            	dataIndex: 'tfidf',
            	width: 'autoSize',
            	sortable: true,
            	hidden: true,
            	renderer: Ext.util.Format.numberRenderer('0,000.000')
            },{
            	text: this.localize("zscore"),
            	tooltip: this.localize("zscoreTip"),
            	dataIndex: 'zscore',
            	width: 'autoSize',
            	sortable: true,
            	hidden: true,
            	renderer: Ext.util.Format.numberRenderer('0,000.000')
            },{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize('trendTip'),
                flex: 1,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline'
                }
            }],
            
            listeners: {
            	termsClicked: {
            		fn: function(src, terms) {
                		if (this.getStore().getCorpus()) { // make sure we have a corpus
                    		var queryTerms = [];
                    		terms.forEach(function(term) {
                    			if (Ext.isString(term)) {queryTerms.push(term);}
                    			else if (term.term) {queryTerms.push(term.term);}
                    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
                    		});
                    		if (queryTerms.length > 0) {
                    			this.setApiParams({
                    				docIndex: undefined,
                    				docId: undefined,
                    				query: queryTerms
                    			});
                        		if (this.isVisible()) {
                            		if (this.isVisible()) {
                                		this.getStore().load({params: this.getApiParams()});
                            		}
                        		}
                    		}
                		}
                	},
                	scope: this
            	}
            }
        });

        me.callParent(arguments);
        
        me.getStore().getProxy().setExtraParam("withDistributions", true);
        
    }
    
});

Ext.define('Voyant.panel.Documents', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel','Voyant.util.Downloadable'],
	alias: 'widget.documents',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		docIndex: undefined,
    		docId: undefined
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    
    MODE_EDITING: 'editing',
    MODE_NORMAL: 'normal',
    config: {
    	mode: this.MODE_NORMAL
    },

    constructor: function(config) {
    	
    	var store = Ext.create("Voyant.data.store.Documents", {
    	    selModel: {pruneRemoved: false},
    	    proxy: {
    	    	extraParams: {
    	    		forTool: 'documents'
    	    	}
    	    }
    	});
    	
    	var dockedItemsItems = [{
            xtype: 'querysearchfield'
        }, {
            xtype: 'totalpropertystatus'
        }]
    	
    	var me = this;
    	
    	if (!config || config.mode!=this.MODE_EDITING) {
    		dockedItemsItems.push({
            	text: this.localize("modify"),
            	tooltip: this.localize("modifyTip"),
    			glyph: 'xf044@FontAwesome',
    			scope: this,
    			itemId: 'modifyButton',
            	handler: function(btn) {
            		var win = Ext.create('Ext.window.Window', {
            		    title: this.localize("title"),
            		    modal: true,
            		    width: "80%",
            		    minWidth: 300,
            		    minHeight: 200,
            		    height: "80%",
            		    layout: 'fit',
            		    frame: true,
            		    border: true,
            		    items: {
            		    	xtype: 'documents',
            		    	mode: this.MODE_EDITING,
            		    	corpus: this.getStore().getCorpus(),
            		    	header: false,
            		    	viewConfig: {
            		            plugins:{
            		                ptype:'gridviewdragdrop'
            		            },
            		            listeners: {
            		            	beforedrop: function(node, data, overModel, dropPosition, dropHandlers) {
            		            		if (this.getStore().getCount()<this.getStore().getCorpus().getDocumentsCount()) {
            		            			var panel = this.up("panel");
            		        				Ext.Msg.show({
            		        				    title: panel.localize('error'),
            		        				    message: panel.localize('reorderFilteredError'),
            		        				    buttons: Ext.Msg.OK,
            		        				    icon: Ext.Msg.ERROR
            		        				});
            		            			return false;
            		            		}
            		            		return true;
            		            	}
            		            }
            		    	}
            		    },
            		    buttons: [{
                			text: this.localize('add'),
                			tooltip: this.localize("addTip"),
                			glyph: 'xf067@FontAwesome',
                			handler: function(btn) {
                				btn.up("window").close();
                				Ext.create('Ext.window.Window', {
                					header: false,
                        		    modal: true,
                        		    layout: 'fit',
                        		    items: {
                        		    	xtype: 'corpuscreator',
                        		    	corpus: this.getStore().getCorpus()
                        		    }
                        		}).show();
                			},
                			scope: this
                		}, {
                			text: this.localize('remove'),
                			tooltip: this.localize("removeTip"),
                			glyph: 'xf05e@FontAwesome',
                			hidden: this.getStore().getCorpus().getDocumentsCount()==1,
                			handler: this.keepRemoveReorderHandler,
                			itemId: 'remove',
                			scope: this
                		}, {
                			text: this.localize('keep'),
                			tooltip: this.localize("keepTip"),
                			glyph: 'xf00c@FontAwesome',
                			hidden: this.getStore().getCorpus().getDocumentsCount()==1,
                			handler: this.keepRemoveReorderHandler,
                			itemId: 'keep',
                			scope: this
                		}, {
                			text: this.localize('reorder'),
                			tooltip: this.localize("reorderTip"),
                			glyph: 'xf0dc@FontAwesome',
                			hidden: this.getStore().getCorpus().getDocumentsCount()==1,
                			handler: this.keepRemoveReorderHandler,
                			itemId: 'reorder',
                			scope: this
                		},{
            		        text: 'Cancel',
                			glyph: 'xf00d@FontAwesome',
            		        handler: function(btn) {
            		        	btn.up("window").close();
            		        }
            		    }]
            		}).show();

            	}
    		}, {
    			text: this.localize('downloadButton'),
		    	glyph: 'xf019@FontAwesome',
    			itemId: 'downloadButton',
    			handler: function() {
    				me.downloadFromCorpusId(me.getStore().getCorpus().getId())
    			}
    		})
    	}
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
	    	columns:[
	    	   {
	    		   xtype: 'rownumberer',
	    	        renderer: function(value, metaData, record) {return record.getIndex()+1},
	    	        sortable: false
	    	    },{
	    	        text: this.localize('documentTitle'),
	    	        dataIndex: 'title',
	    	        sortable: true,
	    	        renderer: function(val, metadata, record) {return record.getTitle();},
	    	        flex: 3
	    	    },{
	    	        text: this.localize('documentAuthor'),
	    	        dataIndex: 'author',
	    	        sortable: true,
	    	        hidden: true,
	    	        renderer: function(val, metadata, record) {return record.getAuthor();},
	    	        flex: 2
	    	    },{
	    	        text: this.localize('tokensCountLexical'),
	    	        dataIndex: 'tokensCount-lexical',
	    	        renderer: Ext.util.Format.numberRenderer('0,000'),
	    	        sortable: true,
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('typesCountLexical'),
	    	        dataIndex: 'typesCount-lexical',
	    	        renderer: Ext.util.Format.numberRenderer('0,000'),
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('typeTokenRatioLexical'),
	    	        dataIndex: 'typeTokenRatio-lexical',
	    	        renderer: function(val) {return Ext.util.Format.percent(val)},
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('averageWordsPerSentence'),
	    	        dataIndex: 'averageWordsPerSentence',
	    	        renderer: Ext.util.Format.numberRenderer('0,000.0'),
	            	tooltip: this.localize("averageWordsPerSentenceTip"),
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('language'),
	    	        dataIndex: 'language',
	    	        hidden: true,
	    	        renderer: function(val, metaData, record, rowIndex, colIndex, store, view) {return view.ownerCt.getLanguage(val);},
	    	        width: 'autoSize'
	    	    }
	    	],
	    	
	        store: store,
	    	
	    	selModel: {
	    		type: 'rowmodel',
	    		mode: 'MULTI',
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		this.getApplication().dispatchEvent('documentsClicked', this, selections, this.getStore().getCorpus());
                    	},
                    	scope: this
                    }
                }
            },
            
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: dockedItemsItems
            }]
    	});
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {

    		this.store.setCorpus(corpus);
    		if (this.isVisible()) {
        		this.store.load({params: this.getApiParams()});
    		} else {
    			this.on('afterrender', function() {
            		this.store.load({params: this.getApiParams()});
    			}, this);
    		}
    		if (this.hasCorpusAccess(corpus)==false) {
    			this.queryById('modifyButton').hide();
    			this.queryById('downloadButton').hide();
    		}
    		/*
    		var me = this;
    		Ext.Ajax.request({
    			url: this.getApplication().getTromboneUrl(),
    			params: {
    				corpus: corpus.getId(),
    				tool: 'corpus.CorpusManager',
    				getAccess: true
    			},
    		    success: function(response, opts) {
    		        var obj = Ext.decode(response.responseText);
    		        if (obj && obj)
    		        debugger
    		        console.dir(obj);
    		        me
    		    },
    		    failure: function(response, opts) {
    		    	me.showError(response);
    		    }
    		})
    		*/
    	})
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {
    			this.getStore().load({params: this.getApiParams()});
    		}
    	}, this);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('query', function(src, query) {
    		this.setApiParam('query', query);
    		this.store.load({params: this.getApiParams()});
    	})
    	
    	if (config.embedded) {
        	if (Ext.getClass(config.embedded).getName() == "Voyant.data.model.Corpus") {
        		config.corpus = config.embedded
        	}
        	else if (Ext.getClass(config.embedded).getName() == "Voyant.data.store.Documents") {
        		this.store.setRecords(config.embedded.getData())
        		config.corpus = config.embedded.getCorpus()
        	}
    		
    	}
    	
    	// if we have a corpus, load it
    	if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus)
    	}
    },
    
    keepRemoveReorderHandler: function(btn) {
    	// we're not sure which scope we're in, so ensure we're talking about this buttons panel
		var panel = btn.up("window").down("documents");
		var selection = panel.getSelection();
		var docs = panel.getStore().getCorpus().getDocumentsCount();
		var btnMode = btn.getItemId();
		// if reordering, check to make sure that we're not looking at a subset
		if (btnMode=='reorder') {
			if (panel.getStore().getCount()<docs) {
				return Ext.Msg.show({
				    title: this.localize('error'),
				    message: this.localize('reorderFilteredError'),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR
				});
			}
			else {
				docIndex = [];
				panel.getStore().each(function(doc) {
					docIndex.push(doc.getIndex())
			    }, this);
				for (var i=1; i<docIndex.length; i++) {
					if (docIndex[i-1]>docIndex[i]) {
						return Ext.Msg.confirm(panel.localize('newCorpus'), new Ext.Template(panel.localize(btnMode+'Documents')).applyTemplate([selection.length]), function(confirmBtn){
							if (confirmBtn==='yes') {
								docIndex = [];
								this.getStore().each(function(doc) {
									docIndex.push(doc.getIndex())
							    }, this);
								var params = {docIndex: docIndex};
								params[btnMode+"Documents"] = true;
								this.editCorpus(params)
							}
						}, panel);
					}
				}
				// if we get here it's because nothing's been reordered
				return Ext.Msg.show({
				    title: this.localize('error'),
				    message: this.localize('reorderOriginalError'),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR
				});
			}
			
		}
		
		if (selection.length>0) {
			if (selection.length==docs) {
				if (docs==1) {
					return Ext.Msg.show({
					    title: this.localize('error'),
					    message: this.localize('onlyOneError'),
					    buttons: Ext.Msg.OK,
					    icon: Ext.Msg.ERROR
					});
				}
				else {
					return Ext.Msg.show({
					    title: this.localize('error'),
					    message: this.localize('allSelectedError'),
					    buttons: Ext.Msg.OK,
					    icon: Ext.Msg.ERROR
					});
				}
			}
			else {
				return Ext.Msg.confirm(this.localize('newCorpus'), new Ext.Template(this.localize(btnMode+'SelectedDocuments')).applyTemplate([selection.length]), function(confirmBtn){
					if (confirmBtn==='yes') {
						docIndex = [];
						selection.forEach(function(doc){
							docIndex.push(doc.getIndex())
						})
						var params = {docIndex: docIndex};
						params[btnMode+"Documents"] = true;
						this.editCorpus(params)
					}
				}, panel);
			}
		}
		else if (panel.getApiParam("query") && panel.getStore().getCount()<docs) {
			return Ext.Msg.confirm(this.localize('newCorpus'), new Ext.Template(this.localize(btnMode+'FilteredDocuments')).applyTemplate([selection.length]), function(confirmBtn){
				if (confirmBtn==='yes') {
					docIndex = [];
					this.getStore().each(function(doc) {
						docIndex.push(doc.getIndex())
				    }, this);
					var params = {docIndex: docIndex};
					params[btnMode+"Documents"] = true;
					this.editCorpus(params)
				}
			}, panel);
		}
		else {
			return Ext.Msg.show({
			    title: this.localize('error'),
			    message: this.localize('selectOrFilterError'),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
		}    	
    },
    
    editCorpus: function(params) {
    	
    	Ext.apply(params, {
    		tool: 'corpus.CorpusManager',
    		corpus: this.getStore().getCorpus().getId()
    	})

    	// mask main viewport while we create a new corpus
    	var app = this.getApplication();
    	var view = app.getViewport();
		view.mask(this.localize("Creating new corpus"));
    	Ext.Ajax.request({
    		url: this.getApplication().getTromboneUrl(),
    		method: 'POST',
    		params: params,
    		success: function(response) {
    			view.unmask();
    			var obj = Ext.decode(response.responseText);
				app.openUrl(app.getBaseUrl()+"?corpus="+obj.corpus.id);
//    			view.mask("Loading new corpus")
//    			new Voyant.data.model.Corpus({corpus: obj.corpus.id}).then(function(corpus) {
//    				view.unmask();
//    				app.openUrl(app.getBaseUrl()+"/?corpus="+obj.corpus.id)
//    				app.dispatchEvent('loadedCorpus', app, corpus);
//    			}).fail(function(message, response) {
//    				view.unmask();
//    				app.showErrorResponse({message: message}, response);
//    			});
    		}
    	});
    	
    	// close editing window if we're in modal mode, should happen asynchronously while new corpus is created
    	var win = this.up("window");
    	if (win && win.isFloating()) {win.close()}
    }
})
Ext.define('Voyant.panel.DocumentsFinder', {
	extend: 'Ext.grid.Panel',
	require: ['Voyant.data.store.DocumentQueryMatches','Ext.grid.plugin.CellEditing'],
	mixins: ['Voyant.panel.Panel'/*,'Voyant.util.Localization'*/],
	alias: 'widget.documentsfinder',
    statics: {
    	i18n: {
    	}
    },
    config: {
    	exportGridAll: false // prevents export all options from grid
    },

    constructor: function(config) {
    	
        this.cellEditing = Ext.create("Ext.grid.plugin.CellEditing", {
            clicksToEdit: 1
        });

        this.cellEditing.on('edit', this.onEditComplete, this);
    	
    	var me = this;
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
    		plugins: [this.cellEditing],
    		bbar: [
    		       {
                       text: this.localize('addRow'),
                       glyph: 'xf055@FontAwesome',
                       handler: this.addRow,
                       scope: this
    		       },{
                       text: this.localize('exportNewCorpus'),
                       disabled: true,
                       glyph: 'xf08e@FontAwesome',
                       tooltip: this.localize('exportNewCorpusTip'),
                       handler: function() {
                    	   var query = this.getQueryFromStore();
                    	   if (query) {
                    		   this.setLoading(true);
	   	               			var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
		            			documentQueryMatches.load({
		            				params: {query: query, createNewCorpus: true},
		            				callback: function(records, operation, success) {
		                     		   this.setLoading(false);
		            					if (success) {
		            						var corpus = operation.getProxy().getReader().rawData.documentsFinder.corpus;
		            						var url = this.getBaseUrl()+'?corpus='+corpus;
		                         		   Ext.Msg.alert({
		                        			   title: this.localize('title'),
		                        			   message: "<a href='"+url+"' target='_blank'>New Corpus</a>"
		                        		   })
		            					}
		            					else {
		            						Ext.create("Voyant.util.ResponseError", {
		            							msg: this.localize("unsuccessfulQuery"),
		            							response: operation.getError().response
		            						}).show();
		            					}
		            				},
		            				scope: this
		            			})
                    		   
                    	   }
                    	   else {
                    		   Ext.Msg.alert({
                    			   title: this.localize('title'),
                    			   message: this.localize('noMatches')
                    		   })
                    	   }
                       },
                       scope: this,
                       cls: 'exportBtn'
    		       },{
    		    	   xtype: 'tbtext',
    		    	   name: 'status',
    		    	   cls: 'status'
    		       }
    		],
	    	columns:[
 	    	    {
	    	        text: this.localize('query'),
	    	        dataIndex: 'query',
	    	        renderer: function(value) {
	    	        	return Ext.isEmpty(value) ? '<span class="placeholder">'+me.localize('emptyQuery') + '</span>' : value;
	    	        },
	    	        editor: true,
	    	        minWidth: 150,
	    	        maxWidth: 300
	    	    },{
	    	        text: this.localize('field'),
	    	        dataIndex: 'field',
	    	        editor: {
	    	        	xtype: 'combo',
	                    typeAhead: true,
	                    triggerAction: 'all',
	                    forceSelection: true,
	                    value: '',
	                    valueField: 'value',
	                    listeners: {
	                    	change:function() {
	                    	  if (Ext.isEmpty(this.getValue())) {
		                    	    this.reset();
		                    	  }
		                    	}
	                    },
	                    store: new Ext.data.Store({
	                        fields: ['text','value'],
	                		data: [[this.localize('textField'),'text'],[this.localize('advancedField'),'advanced']]
	                    })
	    	        },
	    	        width: 150,
                    renderer: function(v) {return Ext.isEmpty(v) ? '' : me.localize(v+"Field")}
	    	    },{
	    	        text: this.localize('operator'),
	    	        dataIndex: 'operator',
	    	        editor: {
	    	        	xtype: 'combo',
	                    forceSelection: true,
	                    store: new Ext.data.Store({
	                        autoDestroy: true,
	                        fields: ['text','value'],
	                        displayField:  'text',
	                        valueField: 'value',
	                		data: [{text:'AND',value:'+'},{text:'OR',value:''}]
	                    })
	    	        },
	    	        minWidth: 75,
	    	        maxWidth: 75
	    	    },{
	    	        text: this.localize('count'),
	    	        dataIndex: 'count',
	    	        renderer: function(value, metadata, record) {
	    	        	return Ext.isEmpty(record.get('query')) ? '' : Ext.util.Format.number(value, '0,000')
	    	        },
	    	        minWidth: 100,
	    	        maxWidth: 100
	    	    },{
	    	    	xtype: 'actioncolumn',
	                width: 25,
	                sortable: false,
	                menuDisabled: true,
	                width: 25,
	                getGlyph: 'xf014@FontAwesome',
	                tooltip: this.localize('deleteQueryTip'),
	                menuDisabled: true,
	                sortable: false,
	                handler: this.removeRow,
	                scope: this
	    	    }
	    	],
	    	
	    	store: new Ext.data.Store({
                // destroy the store if the grid is destroyed
                autoDestroy: true,
                fields: ['id','operator','field','query','count'],
	    		data: [['','','','',0]]
            })
      	});
    			
        this.callParent(arguments);
        
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        
  
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		var docs = corpus.getDocuments();
    		if (docs && docs.getCount()>0) {
    			var doc = docs.getDocument(0);
    			var records = [];
    			["title","author","pubDate","publisher","pubPlace"].forEach(function(field) {
    				if (!Ext.isEmpty(doc.get(field))) {
    					records.push([this.localize(field+'Field'),field])
    				}
    			}, this);
    			if (records) {
    				var editor = this.getColumnManager().getHeaderByDataIndex("field").getEditor();
    				var store = editor.getStore();
    				store.each(function(record) {
    					records.push([record.get('text'), record.get('value')]);
    				}, this);
    				editor.setStore(Ext.create("Ext.data.Store",{
    					fields: ['text','value'],
    					data: records
    				}))
    			}
    			this.updateStatus(0);
    			this.setLoading(false);
    		}
    	})
    	
    },
    
    removeRow:function(grid, rowIndex) {
    	this.getStore().removeAt(rowIndex);
    	if (this.getStore().getCount()==0) {this.addRow();}
    	this.updateAggregate();
    },
    
    addRow: function() {
    	this.store.loadData([['','','','',0]], true);
    },
    
    onEditComplete: function(editor, context) {
    	
    	
    	var query = this.getQueryFromRecord(context.record);
		if (Ext.isEmpty(query)) {
			context.record.set('count','');
			this.updateAggregate();
		}
		else {
			var cell = context.view.getCell(context.record, this.getColumnManager().getHeaderByDataIndex("count"));
			cell.mask("loading");
			var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
			documentQueryMatches.load({
				params: {
					query: query
				},
				callback: function(records, operation, success) {
					cell.unmask();
					if (success) {
						context.record.set('count', records.length==0 ? 0 : records[0].get('count'))
					}
					else {
						Ext.create("Voyant.util.ResponseError", {
							msg: this.localize("unsuccessfulQuery"),
							response: operation.getError().response
						}).show();
						context.record.set('count',0);
					}
					this.updateAggregate();
				},
				scope: this
			})
		}

    },
    
    getQueryFromRecord: function(record) {
		if (Ext.isEmpty(record) || Ext.isEmpty(record.get('query'))) {return ""}
		var query = record.get('query').trim();
		if (Ext.isEmpty(query)) {return ""}
		var field = record.get('field');
		return Ext.isEmpty(field ? field.trim() : field) ? query : field+":"+query
    },
    
    getQueryFromStore: function() {
    	var query = "";
 		this.getStore().each(function(record) {
 			var q = this.getQueryFromRecord(record);
 			if (!Ext.isEmpty(q)) {
 				if (!Ext.isEmpty(query)) {
 					var op = record.get('operator');
 					query += op== 'AND' ? ' + ' : ' | '
 				}
 				query+=q
 			}
 		}, this)
 		console.warn(query)
 		return query;
    },
    
    updateAggregate: function() {
    	var count = this.getStore().sum('count');
    	if (!count || typeof count == 'string') {
    		this.updateStatus(0);
    	}
    	else if (count==1) {
    		var count = this.getStore().getAt(0).get('count');
    		this.updateStatus(this.getStore().getAt(0).get('count'))
    	}
    	else {
    		
    		var query = this.getQueryFromStore();
    		if (!Ext.isEmpty(query)) {
            	if (!this.status) {this.status=this.down("[cls~=status]")} // make sure we have status for masking
    			this.status.mask(this.localize("loading"));
    			var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
    			documentQueryMatches.load({
    				params: {query: query},
    				callback: function(records, operation, success) {
    					
    					this.status.unmask();
    					if (success) {
    						this.updateStatus(records[0].get('count'));
    					}
    					else {
    						Ext.create("Voyant.util.ResponseError", {
    							msg: this.localize("unsuccessfulQuery"),
    							response: operation.getError().response
    						}).show();
    						this.updateStatus(0);
    					}
    				},
    				scope: this
    			})
    		}
    	}
    },
    
    updateStatus: function(count) {
    	if (!this.status) {this.status=this.down("[cls~=status]")}
    	if (!this.exportBtn) {this.exportBtn=this.down("[cls~=exportBtn]")}
    	if (count==0) {
        	this.status.update(new Ext.XTemplate(this.localize('noMatches')).apply([this.getCorpus().getDocumentsCount()]))
    	}
    	else {
    		this.status.update(new Ext.XTemplate(this.localize('queryMatches')).apply([count,this.getCorpus().getDocumentsCount()]))
    	}
    	this.exportBtn.setDisabled(count==0);
    	
    }
    
})
Ext.define('Voyant.panel.Dummy', {
    extend: 'Ext.Panel',
    xtype: 'dummy',
	autoScroll: true,
    initComponent: function() {
        var me = this;
        
        var columns = 3;
        
        Ext.apply(this, {
    		xtype: 'tabpanel',
    		items: [{
                title: 'Tab 1',
                icon: null,
                glyph: 42,
                html: "one"
            }, {
                title: 'Tab 2',
                icon: null,
                glyph: 70,
                html: "two"
            }]
        })
        
        this.callParent();
    }
});
// assuming Bubblelines library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Fountain', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.fountain',
    statics: {
    	i18n: {
    		title: "FountainMeter"
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		docIndex: 0,
    		
    		speed: 30,
    		
    		groups: undefined
    			
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
    	options: {xtype: 'stoplistoption'},
    	audio: false,
    	words: [],
    	groups: {},
    	moveWordsTimeout: undefined
	},
	
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	Ext.apply(this, {
    		title: this.localize('title'),
    		layout: {
    			type: 'hbox',
    			align: 'stretch'
    		},
    		items: [{
        		html: '<svg></svg>',
        		itemId: 'fountain',
        		flex: 2
    		},{
    			flex: 1,
    			layout:  'vbox',
    			items: [{
    				   xtype: 'polar',
    				   itemId: 'gauge',
    				   width: 300,
    				   flex: 1,
    				   store: {
    				       fields: ['mph', 'fuel', 'temp', 'rpm'],
    				       data: [{val: 10}]
    				   },
    				   series: {
    				       type: 'gauge',
    				       colors: this.getApplication().getColorPalette(undefined, true),
    				       angleField: 'val',
    				       donut: 20
    				   }
    				},{
		    			width: 300,
		    			height: 16,
    					items: {
    		    			xtype: 'sparklineline',
        				    itemId: 'gaugsparkline',
    		    			values: [0,1,2,34],
    		    			height: 16,
    		    			width: 300
    					},
		    			listeners: {
		    				afterrender: function(cmp) {
		    					cmp.getTargetEl().setStyle("cursor", "pointer");
			    				cmp.getTargetEl().on("click", function(e, t, eOpts) {
	    					    	clearTimeout(this.getMoveWordsTimeout());
		    						this.getWords().forEach(function(word) {

		    							if (word.svg) {
		    								word.svg.remove();
		    								delete word.svg;
		    							}
		    							word.direction = -1; // reset
		    						})
		    						var pos = Math.floor(e.event.offsetX * this.getWords().length / t.offsetWidth)
		    						this.moveWords(pos);
		    					}, this);
		    				},
		    				scope: this
		    			}
    				}]
    		}],
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					fieldLabel: this.localize('speed'),
					labelAlign: 'right',
					labelWidth: 40,
					width: 100,
					increment: 1,
					minValue: 1,
					maxValue: 60,
					value: 30,
					listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(parseInt(this.getApiParam("speed")));
	                		if (this.bubbles) {this.bubbles.frameRate(cmp.getValue())}
	                		this.setAudio(cmp.getValue());
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('speedTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    changecomplete: function(cmp, val) {
	                    	this.setApiParam('speed', val);
	                		if (this.bubbles) {this.bubbles.frameRate(val)}
	                    },
	                    scope: this
					}
				}]
    		}]
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		this.loadDocument();
    	}, this);
    	
    },
    
    loadDocument: function() {
    	var me = this;
    	var docIndex = parseInt(this.getApiParam('docIndex')) || 0;
    	this.getCorpus().getWordsArray({docIndex: docIndex, stopList: 'auto'}).then(function(words) {

    		// fold to lower case
    		var lcwords = words.map(function(w) {return w.toLowerCase()});
    		
    		// if we don't have any groups of words, form them based on words that are longer than four letters
    		if (me.getApiParam("groups")==undefined) {
    			var group = {};
    			lcwords.forEach(function(w) {
    				if (w.length>5 && !(w in group)) {
    					group[w] = w.length;
    				} 
    			});
    			var maxLen = Math.max.apply(this, Object.values(group))
    			var lenVal = d3.scaleLinear().domain([4,maxLen]).range([.5,1])
    			for (var w in group) {
    				group[w] = lenVal(group[w]); // convert length to val between 0 and 1
    			}
    			me.setGroups({length: {
    				color: me.getApplication().getColorForTerm("length"),
    				terms: group
    			}})
    		}

    		var el = me.getComponent('fountain').getTargetEl();
			var svgEl = el.down("svg");
    		svgEl.set({width: el.getWidth(), height: el.getHeight()});
    		var svgDom = svgEl.dom
    		var svg = d3.select(svgDom);
    		svg.selectAll("*").remove(); // clear
    		
    		// create words and set min height (highest point)
    		var types = {};
    		var groups = me.getGroups();

    		me.setWords(words.slice(0,1000).map(function(w) {
    			var word = new me.FountainWord(w.toLowerCase());
    			if (word.word in types) {types[word.word]++}
    			else {types[word.word]=1;}
    			word.min = parseInt(Math.random()*svgDom.clientHeight*.05);
    			var yshift = Math.sqrt(Math.random()*10)
    			word.yshift = Math.random()*2<1 ? - yshift : yshift;
    			word.jump = svgDom.clientHeight/10
    			word.groupVals = {};
    			for (var g in groups) {
    				if (word.word in groups[g].terms) {
    					word.groupVals[g] = groups[g].terms[word.word]
    				}
    			}
    			return word;
    		}));
    		var max = Math.max.apply(this, Object.values(types));
    		var fontSize = d3.scaleLog().domain([1,Math.max.apply(this, Object.values(types))]).range([4,12]);
    		me.getWords().forEach(function(word) {
    			word.fontSize = fontSize(types[word.word])
    		})
    		me.moveWords();
    	})
    },
    
    FountainWord: function(word) {
    	this.word = word;
    	this.direction = -1;
    },
    
    moveWords: function(until) {

    	var words = this.getWords(),
    		svg = this.getComponent('fountain').getTargetEl().down("svg").dom,
			height = svg.clientHeight,
			width = svg.clientWidth,
			groups = this.getGroups();
		var opacity = d3.scaleLinear().domain([0,height]).range([1,0]);

		var gaugeVals = [];
		var seen = 0;
    	for (var i=0; i<words.length; i++) {
    		seen++;
    		
			// make sure to count group hits for all words since start to current point
			if (Object.keys(words[i].groupVals).length==0) {
				gaugeVals.push(0)
			} else {
				Object.values(words[i].groupVals).forEach(function(val) {
					gaugeVals.push(val);
				});
			}
			
    		if (words[i].direction<0) { // going up
    			
				
    			if (!words[i].svg) {
    	    		var word = d3.select(svg)
    	    			.append("text")
    	    			.text(words[i].word)
    	    			.attr("font-size", words[i].fontSize)
    	    			.attr("text-anchor", "middle")
    	    			.attr("x", width/2)
    	    			.attr("y", height-(Math.random()*height)/5)
    	    			.attr("fill", Object.keys(words[i].groupVals).length==0 ? "black" : this.getApplication().getColorForTerm(Object.keys(words[i].groupVals).shift(), true));
    	    		words[i].ys = [height];
    	    		words[i].svg = word;
    	    		if (!until || i>until) {
    	    			break;
    	    		}
    			} else {
    				var y = parseInt(words[i].svg.attr("y"));
        			var delta = y-words[i].min;
        			var change = delta/5
        			words[i].svg.attr("y", y-change);
        			words[i].svg.attr("x", parseInt(words[i].svg.attr("x"))+words[i].yshift);
        			y = parseInt(words[i].svg.attr("y"))
        			words[i].ys.push(y);
        			if (y<=words[i].min) {
        				words[i].direction = 1;
        			}
    			}
    			
    		} else if (words[i].direction>0) { // going down
    			if (words[i].svg && words[i].ys.length>0) {
        			words[i].svg.attr("y", words[i].ys.pop());
        			words[i].svg.attr("x", parseInt(words[i].svg.attr("x"))+words[i].yshift);
        			words[i].svg.attr("opacity", opacity(parseInt(words[i].svg.attr("y"))));
    				
    			} else {
    				words[i].direction = 0;
    			}
    		} else {
    			if ("svg" in words[i]) {
    				words[i].svg.remove()
    				delete words[i].svg
    			}
    		}
    		
    	}

    	var avg = gaugeVals.length==0 ? 0 : Ext.mean(gaugeVals)*100;
    	var polar = this.down("polar")
    	polar.getStore().getAt(0).set("val", avg)
    	polar.setSprites({
            type: 'text',
            text: Ext.util.Format.number(avg, '%0.0'),
            x: 145,
            y: 240
        });
    	var sparkline = this.down("sparklineline");
    	sparkline.setValues(gaugeVals.length>100 ? this.chunkify(gaugeVals, 100, true).map(function(vals) {return Ext.mean(vals)}) : gaugeVals);
    	sparkline.setWidth(seen*sparkline.ownerCt.getWidth()/words.length)
    	
    	this.setMoveWordsTimeout(Ext.defer(this.moveWords, 100, this));
    },
    
    // https://stackoverflow.com/questions/8188548/splitting-a-js-array-into-n-arrays
    chunkify: function(a, n, balanced) {
        if (n < 2)
            return [a];

        var len = a.length,
                out = [],
                i = 0,
                size;

        if (len % n === 0) {
            size = Math.floor(len / n);
            while (i < len) {
                out.push(a.slice(i, i += size));
            }
        }

        else if (balanced) {
            while (i < len) {
                size = Math.ceil((len - i) / n--);
                out.push(a.slice(i, i += size));
            }
        }

        else {

            n--;
            size = Math.floor(len / n);
            if (len % size === 0)
                size--;
            while (i < size * n) {
                out.push(a.slice(i, i += size));
            }
            out.push(a.slice(size * n));

        }

        return out;    	
    },
    
    initComponent: function() {
    	this.callParent(arguments);
    }
});
Ext.define('Voyant.panel.RezoViz', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.rezoviz',
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		limit: 25,
    		stopList: 'auto',
    		type: ['organization','location','person'],
    		minEdgeCount: 2
    	},
		glyph: 'xf1cb@FontAwesome'
    },
    
    config: {
    	network: undefined, // the vis network graph
    	nodesStore: undefined, // used by combo
    	nodesDataSet: undefined, // used by vis
    	edgesDataSet: undefined, // used by vis
    	isNetworkBounded: true
    },

    categorizedNodeOptions: {
    	location: {
    		font: {
    			color: 'green'
    		}
    	},
    	person: {
    		font: {
    			color: 'maroon'
    		}
    	},
    	organization: {
    		font: {
    			color: 'purple'
    		}
    	}
    },
    nodeOptions: {
		shape: 'box',
		color: {
			border: 'rgba(0,0,0,0.1)',
			background: 'rgba(255,255,255,1)'
		},
		scaling:{
            label: {
              min: 8,
              max: 20
            }
          }
	},
	edgeOptions: {
		color: {
			color: 'rgba(0,0,0,0.1)',
			highlight: 'black',
			hover: 'red'
		},
		labelHighlightBold: false
	},
	highlightOptions: {
		font: {
			color: 'white'
		},
		color: {
			background: 'black'/*,
			hover: {
				border: '#CB157F',
				background: '#EB42A5'
			}*/
		}
	},
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        var me = this;
        
        this.setNodesStore(Ext.create('Ext.data.Store', {
        	fields: ['id', 'term', 'type', 'rawFreq'],
        	sortOnLoad: true,
        	sorters: 'term'
        }));
        
        Ext.apply(me, {
    		title: this.localize('title'),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'combo',
                    queryMode: 'local',
                    valueField: 'term',
                    displayField: 'term',
                    store: this.getNodesStore(),
                    listeners: {
						select: function(combo, record) {
							this.getNetwork().selectNodes([record.get('id')]);
						},
						scope: this
                    }
                },{
                	xtype: 'button',
	                text: this.localize('categories'),
	                menu: {
	                	items: [{
	                		xtype: 'menucheckitem',
	                		text: this.localize('people'),
	                		itemId: 'person',
	                		checked: true
	                	},{
	                		xtype: 'menucheckitem',
	                		text: this.localize('locations'),
	                		itemId: 'location',
	                		checked: true
	                	},{
	                		xtype: 'menucheckitem',
	                		text: this.localize('organizations'),
	                		itemId: 'organization',
	                		checked: true
	                	},{
	                		xtype: 'button',
	                		text: this.localize('reload'),
	                		style: 'margin: 5px;',
	                		handler: this.categoriesHandler,
	                		scope: this
	                	}]
	                }
                },{
					xtype: 'numberfield',
					itemId: 'minEdgeCount',
					fieldLabel: this.localize('minEdgeCount'),
					labelAlign: 'right',
					labelWidth: 120,
					width: 170,
					maxValue: 10,
					minValue: 1,
					allowDecimals: false,
					allowExponential: false,
					allowOnlyWhitespace: false,
					listeners: {
						render: function(field) {
							field.setRawValue(this.getApiParam('minEdgeCount'));
						},
						change: function(field, newVal) {
							if (field.isValid()) {
								this.setApiParam('minEdgeCount', newVal);
								this.getEntities();
							}
						},
						scope: this
					}
                },{ xtype: 'tbseparator' },{
                	xtype: 'slider',
                	fieldLabel: this.localize('repulsion'),
                	labelAlign: 'right',
                	labelWidth: 70,
                	width: 150,
                	value: 100,
                	increment: 10,
                	minValue: 0,
                	maxValue: 500,
                	listeners: {
                		changecomplete: function(slider, val) {
                			this.getNetwork().physics.options.repulsion.nodeDistance = val;
                			this.getNetwork().startSimulation();
                		},
                		scope: this
                	}
                },{
                	xtype: 'slider',
                	fieldLabel: this.localize('stiffness'),
                	labelAlign: 'right',
                	labelWidth: 70,
                	width: 150,
                	value: 4,
                	increment: 1,
                	minValue: 0,
                	maxValue: 10,
                	listeners: {
                		changecomplete: function(slider, val) {
                			val /= 100;
                			this.getNetwork().physics.options.repulsion.springConstant = val;
                			this.getNetwork().startSimulation();
                		},
                		scope: this
                	}
                },{
                	xtype: 'slider',
                	fieldLabel: this.localize('friction'),
                	labelAlign: 'right',
                	labelWidth: 55,
                	width: 150,
                	value: 9,
                	increment: 10,
                	minValue: 0,
                	maxValue: 100,
                	listeners: {
                		changecomplete: function(slider, val) {
                			val /= 100;
                			this.getNetwork().physics.options.repulsion.damping = val;
                			this.getNetwork().startSimulation();
                		},
                		scope: this
                	}
                }]
            }]
        });
        
        this.on('loadedCorpus', function(src, corpus) {
        	if (corpus.getDocumentsCount()==1) {
        		this.setApiParam("minEdgeCount", 1);
        	}
        	this.getEntities();
        }, this);
        
        this.on('resize', function(panel, width, height) {

		}, this);
        
        me.callParent(arguments);
    },
    
    getEntities: function() {
    	var corpusId = this.getCorpus().getId();
    	var el = this.getLayout().getRenderTarget();
    	el.mask(this.localize('loadingEntities'));
    	Ext.Ajax.request({
    		url: this.getApplication().getTromboneUrl(),
    		method: 'POST',
    		params: {
    			tool: 'corpus.EntityCollocationsGraph',
    			type: this.getApiParam('type'),
    			limit: this.getApiParam('limit'),
    			minEdgeCount: this.getApiParam("minEdgeCount"),
    			corpus: corpusId
    		},
    		success: function(response) {
    			el.unmask();
    			var obj = Ext.decode(response.responseText);
    			if (obj.entityCollocationsGraph.edges.length==0) {
    				this.showError({msg: this.localize('noEntities')});
    				Ext.Msg.confirm(this.localize('error'), this.localize('noEntitiesForEdgeCount'), function(button) {
    					if (button === 'yes') {
    						var newEdgeCount = Math.max(1, this.getApiParam('minEdgeCount')-1);
    						this.queryById('minEdgeCount').setRawValue(newEdgeCount);
    						this.setApiParam('minEdgeCount', newEdgeCount);
    						this.getEntities();
    					}
    				}, this);
    			}
    			else {
        			this.processEntities(obj.entityCollocationsGraph);
        			this.initGraph();
    			}
    		},
    		scope: this
    	});
    },
    
    processEntities: function(entityParent) {
    	var nodes = entityParent.nodes;
    	var edges = entityParent.edges;
    	
    	// we need to calculate the font size because the scaling option doesn't seem to work as advertised
    	var extent = d3.extent(nodes, function(node) {return node.rawFreq;});
    	var min = extent[0];
    	var max = extent[1];    	
    	var scaleFont = d3.scale.linear()
                    .domain([min, max])
                    .range([10, 24]);
    	
    	var visNodes = [];
    	for (var i = 0; i < nodes.length; i++) {
    		var n = nodes[i];
    		n.id = i;
    		visNodes.push({id: i, label: n.term, value: nodes[i].rawFreq, font: {size: scaleFont(n.rawFreq), color: this.categorizedNodeOptions[n.type].font.color}, type: n.type, rawFreq: n.rawFreq, title: n.term + (n.rawFreq ? ' ('+n.rawFreq+')':'')});
    	}
    	
    	this.getNodesStore().loadData(nodes);
    	
    	var visEdges = [];
    	for (var i = 0; i < edges.length; i++) {
    		var link = edges[i].nodes;
    		visEdges.push({from: link[0], to: link[1], title: edges[i].count, value: 200*edges[i].count});
    	}
    	
    	this.setNodesDataSet(new vis.DataSet(visNodes));
    	this.setEdgesDataSet(new vis.DataSet(visEdges));
    },
    
    initGraph: function() {
    	var el = this.getLayout().getRenderTarget();
    	el.update(''); // clear
    	
    	// explicitly set dimensions
    	el.setWidth(el.getWidth());
    	el.setHeight(el.getHeight());

    	var options = {
			interaction: {
    			hover: true,
    			hoverConnectedEdges: true,
    			multiselect: false
    		},
    		physics: {
    			solver: 'repulsion',
    			repulsion: {
    				centralGravity: 0.1
    			}
    		},
    		nodes: this.nodeOptions,
    		edges: this.edgeOptions
    	};
    	
    	
    	var network = new vis.Network(el.dom, {
    		nodes: this.getNodesDataSet(),
    		edges: this.getEdgesDataSet()
    	}, options);

    	if (this.getIsNetworkBounded()) {
	    	network.on('beforeDrawing', function (ctx) {
	    		var el = this.getLayout().getRenderTarget();
	    		var width = el.getWidth();
	    		var height = el.getHeight();
	    		
	    	    var nodePositions = network.getPositions();
	    	    for (var id in nodePositions) {
	    	    	var node = nodePositions[id];
	    	    	var xy = network.canvasToDOM(node);
	    	    	var boundedX = Math.max(0, Math.min(width, xy.x));
	    	    	var boundedY = Math.max(0, Math.min(height, xy.y));
	    	    	var bXY = network.DOMtoCanvas({x: boundedX, y: boundedY});
	    	    	network.body.nodes[id].x = bXY.x;
	    	    	network.body.nodes[id].y = bXY.y;
	    	    }
	    	}.bind(this));
    	}
    	
    	network.on('selectNode', function(params) {
    		var node = params.nodes[0];
    		this.doNodeSelect(node);
    	}.bind(this));
    	network.on('deselectNode', function(params) {
    		network.unselectAll(); // need this due to our custom selecting code
    		
    		var node = params.nodes[0];
    		if (node !== undefined) {
    			// select clicked node after deselection is finished
    			setTimeout(this.doNodeSelect.bind(this), 5, node);
    		}
    	}.bind(this));
    	network.on('selectEdge', function(params) {
    		// prevent edge selection
    		network.unselectAll();
    	});
    	
    	this.setNetwork(network);
    },
    
    doNodeSelect: function(node) {
		var term = this.getNodesDataSet().get(node).label;
		this.dispatchEvent("termsClicked", this, [term]);
    	var network = this.getNetwork();
		var nodes = network.getConnectedNodes(node);
		nodes.push(node);
		var edges = network.getConnectedEdges(node);
		
		// custom selection to avoid selecting edges between the secondary/connected nodes
		network.unselectAll();
		for (var i = 0; i < nodes.length; i++) {
			var n = nodes[i];
			var nodeObj = network.body.nodes[n];
			network.selectionHandler.selectObject(nodeObj, false);
		}
		for (var i = 0; i < edges.length; i++) {
			var e = edges[i];
			var edgeObj = network.body.edges[e];
			network.selectionHandler.selectObject(edgeObj, false);
		}
		
		network.redraw(); // need to force redraw if coming from deselect
    },
    
    categoriesHandler: function(item) {
    	var categories = [];
    	item.up('menu').items.each(function(checkitem) {
    		if (checkitem.checked) {
    			categories.push(checkitem.itemId);
    		}
    	});
    	
    	this.setApiParam('type', categories);
    	this.getEntities();
    },
    
    map: function(value, istart, istop, ostart, ostop) {
		return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
	}
});
Ext.define('Voyant.panel.Loom', {
    extend: 'Ext.panel.Panel',
    mixins: ['Voyant.panel.Panel'],
    alias: 'widget.loom',
    statics: {
        i18n: {
        	title: "Loom",
        	controls: "Controls",
        	frequenciesGroup: "Frequencies",
        	coverageGroup: "Coverage",
        	distributionsGroup: "Distribution",
        	termsGroup: "Terms",
        	inDocumentsLabel: "in documents",
        	inDocumentsLabelTip: "each term must be present in the number of documents defined by this range",
        	spanSomeLabel: "some documents",
        	spanSomeLabelTip: "each term must be present in at least one document defined by this range",
        	spanAllLabel: "all documents",
        	spanAllLabelTip: "each term must be present in all documents defined by this range",
        	spanOnlyLabel: "only documents",
        	spanOnlyLabelTip: "each term must be present in only the documents defined by this range",
        	rawFreqLabel: "raw frequency",
        	rawFreqLabelTip: "raw term frequencies for the term must be between these values (inclusively)",
        	rawFreqPercentileLabel: "raw frequency percentile",
        	rawFreqPercentileLabelTip: "raw term frequencies for the term must be between these percentile values (inclusively), this is useful for saying something like terms in the top 90th percentile which will provide 10% of words regardless of the variation in values.",
        	distributionsStdDevLabel: "standard deviation of distributions",
        	distributionsStdDevLabelTip: "the standard deviation of term distribution scores must be between the defined range of values (lower will be for values that are more consistent, higher will be for values that have greater variability)",
        	distributionsStdDevPercentileLabel: "percentile of standard deviations of distributions",
        	distributionsStdDevPercentileLabelTip: "the percentile of standard deviations of distributions must be between the defined range of values (lower will be for values that are more consistent, higher will be for values that have greater variability)",
        	termsLengthLabel: "term length",
        	termsLengthLabelTip: "the length (number of characters) of the term (word)",
        	termsLengthPercentileLabel: "term length percentile",
        	termsLengthPercentileLabelTip: "the percentile of the length (number of characters) of the term (word)",
        	distributionIncreasesLabel: "increases in distribution values",
        	distributionIncreasesLabelTip: "the number of increases of the distribution values must be between the defined range (inclusively)",
        	distributionConsecutiveIncreasesLabel: "consecutive decreases in distribution values",
        	distributionConsecutiveIncreasesLabelTip: "the number of consecutive decreases of the distribution values must be between the defined range (inclusively)",
        	distributionDecreasesLabel: "decreases in distribution values",
        	distributionDecreasesLabelTip: "the number of decreases of the distribution values must be between the defined range (inclusively)",
        	distributionConsecutiveDecreasesLabel: "consecutive decreases in distribution values",
        	distributionConsecutiveDecreasesLabelTip: "the number of consecutive decreases of the distribution values must be between the defined range (inclusively)",
        	distributionMaxLabel: "distribution maximum",
        	distributionMaxLabelTip: "the maximum of the distribution values must be between the defined range (inclusively)",
        	distributionMinLabel: "distribution minimum",
        	distributionMinLabelTip: "the minimum of the distribution values must be between the defined range (inclusively)",
        	presetsGroup: "pre-sets",
        	presetHighFreq: "terms that are high frequency",
        	presetHighFreqLonger: "terms that are longer and high frequency",
        	presetSingleDoc: "higher frequency terms that only occur once",
        	presetIncreaseDistributions: "terms that generally increase in frequency",
        	presetDecreaseDistributions: "terms that generally decrease in frequency ",
        	presetNearStartDistributions: "terms that peak in distribution toward the beginning ",
        	presetNearEndDistributions: "terms that peak in distribution toward the end ",
        	presetSporadicDistributions: "terms whose distributions vary the most",
        	visibleTerms: "max terms",
        	scaling: "scaling",
        	scaleLinear: "linear",
        	scaleLog: "logarithmic",
        	scaleSqrt: "square root"
        	
        },
        api: {
            limit: 500,
            stopList: 'auto',
            inDocuments: undefined,
            spanSome: undefined,
            spanAll: undefined,
            spanOnly: undefined,
            termLength: undefined,
            termsLengthPercentile: undefined,
            rawFreq: undefined,
            rawFreqPercentile: undefined,
            distributionsStdDev: undefined,
            distributionsStdDevPercentile: undefined,
            distributionIncreases: undefined,
            distributionDecreases: undefined,
            distributionConsecutiveIncreases: undefined,
            distributionConsecutiveDecreases: undefined,
            distributionMax: undefined,
            distributionMin: undefined,
            scaling: 'linear'
        },
        glyph: 'xf1e0@FontAwesome'
    },
    
    config: {
    	store: undefined,
    	terms: undefined,
    	options: [
    		{xtype: 'stoplistoption'}
    	],
    	controls: undefined
    },


    constructor: function(config) {
        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
        
    initComponent: function() {
    	
        this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
        
    	var controls = new Ext.util.MixedCollection({
    		allowFunctions: true
    	});
    	controls.addAll({
    		inDocuments: new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'inDocuments',
	    		initControl: function(store) {
	    			this.setMin(1);
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var count = record.getDistributions().filter(function(val) {return val>0}).length;
	        		return count >= this.getLow() && count <= this.getHigh();
	        	}
    		}),
    		spanSome :new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'spanSome',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length-1);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		for (var i=low; i<high+1; i++) {
	        			if (vals[i]>0) {return true}
	        		}
	        		return false;
	        	}
    		}),
    		spanAll :new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'spanAll',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length-1);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		for (var i=low; i<high+1; i++) {
	        			if (vals[i]==0) {return false}
	        		}
	        		return true;
	        	}
    		}),
    		spanOnly :new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'spanOnly',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length-1);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		for (var i=0; i<vals.length; i++) {
	        			if (i<low || i>high) {
	        				if (vals[i]>0) {return false}
	        			} else {
	        				if (vals[i]==0) {return false}
	        			}
	        		}
	        		return true;
	        	}
    		}),
    		rawFreq :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'rawFreq',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			var vals = store.getRange().map(function(r) {return r.get('rawFreq')});
	    			this.setMin(Ext.Array.min(vals))
	    			this.setMax(Ext.Array.max(vals))
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), val = record.get("rawFreq");
	        		return val>=low && val <= high;
	        	}
    		}),
    		rawFreqPercentile :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'rawFreqPercentile',
	    		min: 0,
	    		max: 100,
	    		initControl: function(store) {
	    			this.vals = store.getRange().map(function(r) {return r.get('rawFreq')});
	    			this.vals.sort(function (a, b) {  return a - b;  });
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
	        			ind = Ext.Array.indexOf(this.vals, record.get("rawFreq")),
	        			val = Math.round(ind*100/this.vals.length)
	        		return val>=low && val <= high;
	        	}
    		}),
    		distributionsStdDev :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'distributionsStdDev',
	    		initControl: function(store) {
	    			var allvals = Ext.Array.flatten(store.getRange().map(function(r) {return r.getDistributions()}));
	    			// we'll scale to all available distributions, otherwise we're not making similar comparisons
	    			var scale = d3.scaleLinear().domain([d3.min(allvals),d3.max(allvals)]).range([0,100]);
	    			store.each(function(record) {
	    				if (record.get("distributionsStdDev")===undefined) {
	    					// https://derickbailey.com/2014/09/21/calculating-standard-deviation-with-array-map-and-array-reduce-in-javascript/
	    					// https://gist.github.com/Daniel-Hug/7273430
		    				var vals = record.getDistributions();
		    				var scaledVals = vals.map(function(v) {return scale(v)});
		    				var avg = Ext.Array.mean(scaledVals);
							var squareDiffs = vals.map(function(value){
								    var diff = value - avg;
								    var sqrDiff = diff * diff;
								    return sqrDiff;
							});
							var avgSquareDiff = Ext.Array.mean(squareDiffs);
							var stdDev = Math.sqrt(avgSquareDiff);
							record.set("distributionsStdDev", stdDev);
	    				}
	    			})
	    			var vals = store.getRange().map(function(r) {return r.get('distributionsStdDev')});
	    			this.setMin(Ext.Array.min(vals))
	    			this.setMax(Ext.Array.max(vals))
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
	        			val = record.get("distributionsStdDev");
	        		return val>=low && val <= high;
	        	}
    		}),
    		distributionsStdDevPercentile :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'distributionsStdDevPercentile',
	    		min: 0,
	    		max: 100,
	    		initControl: function(store) {
	    			this.vals = store.getRange().map(function(r) {return r.get('distributionsStdDev')});
	    			this.vals.sort(function (a, b) {  return a - b;  });
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
        				ind = Ext.Array.indexOf(this.vals, record.get("distributionsStdDev")),
        				val = Math.round(ind*100/this.vals.length)
        			return val>=low && val <= high;
	        	}
    		}),
    		termsLength :new Voyant.util.LoomControl({
	    		group: 'terms',
	    		name: 'termsLength',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			var vals = store.getRange().map(function(r) {return r.get('term').length});
	    			this.setMin(Ext.Array.min(vals))
	    			this.setMax(Ext.Array.max(vals))
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), val = record.get("term").length;
	        		return val>=low && val <= high;
	        	}
    		}),
    		termsLengthPercentile :new Voyant.util.LoomControl({
	    		group: 'terms',
	    		name: 'termsLengthPercentile',
	    		min: 0,
	    		max: 100,
	    		initControl: function(store) {
	    			this.vals = store.getRange().map(function(r) {return r.get('term').length});
	    			this.vals.sort(function (a, b) {  return a - b;  });
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
        				ind = Ext.Array.indexOf(this.vals, record.get("term").length),
        				val = Math.round(ind*100/this.vals.length)
        			return val>=low && val <= high;
	        	}
    		}),
    		distributionIncreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionIncreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var increases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]>vals[i-1]) {
	        				increases++;
	        				if (increases>high) {return false}
	        			}
	        		}
	        		return increases>=low;
	        	}
    		}),
    		distributionConsecutiveIncreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionConsecutiveIncreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var increases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]>vals[i-1]) {
	        				increases++;
	        				if (increases>high) {return false}
	        			} else {
	        				increases=0;
	        			}
	        		}
	        		return increases>=low;
	        	}
    		}),
    		distributionDecreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionDecreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var decreases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]<vals[i-1]) {
	        				decreases++;
	        				if (decreases>high) {return false}
	        			}
	        		}
	        		return decreases>=low;
	        	}
    		}),
    		distributionConsecutiveDecreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionConsecutiveDecreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var decreases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]<vals[i-1]) {
	        				decreases++;
	        				if (decreases>high) {return false}
	        			} else {
	        				decreases = 0;
	        			}
	        		}
	        		return decreases>=low;
	        	}
    		}),
    		distributionMax :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionMax',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions(), val = Ext.Array.max(vals);
	        		for (var i=low;i<high;i++) { // look at every value in case there are duplicate values
	        			if (vals[i]==val) {return true}
	        		}
	        		return false;
	        	}
    		}),
    		distributionMin :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionMin',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions(), val = Ext.Array.min(vals);
	        		for (var i=low;i<high;i++) { // look at every value in case there are duplicate values
	        			if (vals[i]==val) {return true}
	        		}
	        		return false;
	        	}
    		})
    	});

    	controls.each(function(control) {
    		var val = this.getApiParam(control.getName()), vals = (val || "").split(",");
    		control.setEnabled(val!==undefined);
    		if (vals.length==2) {
    			control.setLow(parseInt(vals[0]))
    			control.setHigh(parseInt(vals[1]))
    		}
    		control.on("change", function(control) {
    			if (control.getEnabled()) {
    				this.setApiParam(control.getName(), control.getLow()+","+control.getHigh());
    			} else {
    				this.setApiParam(control.getName(), undefined);
    			}
    			this.filterRecords();
    		}, this);
    	}, this);

    	this.setControls(controls);
    	
    	// used below in preset handlers
    	var me = this;
    	var clearApiParamsForControls = function() {
    		var currentParams = me.getApiParams();
    		var params = {};
    		me.controls.each(function(control) {
    			control.setEnabled(false, true);
    			var name = control.getName();
    			if (name in currentParams) {
    				me.setApiParam(name, undefined)
    			}
    		})
    	}

    	
    	var tbitems = [{
    		text: this.localize("presetsGroup"),
    		menu: {
    			items: [{
    				text: this.localize('presetHighFreq'),
    				handler: function() {
    					clearApiParamsForControls();
    			    	this.filterRecords();
    				},
    				scope: this
    			},{
    				text: this.localize('presetHighFreqLonger'),
    				handler: function() {
    					clearApiParamsForControls();
    					this.controls.getByKey("termsLengthPercentile").setEnabled(true, true).setValues(50,100, true);
    					this.controls.getByKey("rawFreqPercentile").setEnabled(true, true).setValues(50,100);
    				},
    				scope: this
    			},{
    				text: this.localize('presetSingleDoc'),
    				handler: function() {
    					clearApiParamsForControls();
    					this.controls.getByKey("inDocuments").setEnabled(true, true).setValues(1,1);
    				},
    				scope: this
    			},{
    				text: this.localize('presetIncreaseDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionIncreases");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(Math.round(max*.75),max);
    				},
    				scope: this
    			},{
    				text: this.localize('presetDecreaseDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionDecreases");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(Math.round(max*.75),max);
    				},
    				scope: this
    			},{
    				text: this.localize('presetNearStartDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionMax");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(0, Math.round(max*.2));
    				},
    				scope: this
    			},{
    				text: this.localize('presetNearEndDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionMax");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(Math.round(max*.8), max);
    				},
    				scope: this
    			},{
    				text: this.localize('presetSporadicDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					this.controls.getByKey("distributionsStdDevPercentile").setEnabled(true, true).setValues(80, 100);
    				},
    				scope: this
    			}]
    		}
    	}, {
    		xtype: 'tbspacer'
    	}];
    	["frequencies","coverage","distributions","terms"].map(function(group) {
    		tbitems.push({
    			text: this.localize(group+"Group"),
    			menu: {
    				items: controls.filterBy(function(control) {return control.getGroup()==group}).getRange().map(function(control) {
    					return {
    						xtype: 'menucheckitem',
    						checked: control.getEnabled(),
							text: this.localize(control.getName()+"Label"),
							tooltip: this.localize(control.getName()+"LabelTip"),
							listeners: {
								beforerender: function(cmp) {
									cmp.setChecked(control.getEnabled());
									control.on("change", function() {
										cmp.setChecked(control.getEnabled());
									})
								},
								click: function(cmp) {
									control.setEnabled(cmp.checked)
									cmp.getMenu().setDisabled(!cmp.checked)
									if (cmp.checked) {cmp.getMenu().show();}
									else {cmp.getMenu().hide()}
								}
    						},
							menu: {
								disabled: !control.getEnabled(),
								items: {
									xtype: 'multislider',
									width: 100,
									minValue: control.getMin() || 0,
									maxValue: control.getMax() || 0,
									values: [(control.getLow() || 0), (control.getHigh() || 0)],
									tipText: function(t) {
										return control.getOffsetTipText() ? t.value+1 : t.value;
									},
									listeners: {
    									beforerender: function(slider) {
    										slider.updateFromControl(control);
    										control.on("change", function() {
    											slider.updateFromControl(control);
    										})
    									},
    									changecomplete: function(slider) {
    										control.setValues(slider.getValues());
    									}
									},
									updateFromControl: function(control) {
										this.setMinValue(control.getMin() || 0);
										this.setMaxValue(control.getMax());
										this.setValue(0, control.getLow() || 0)
										this.setValue(1, control.getHigh()===undefined ? (control.getMax() || 0) : control.getHigh())
									}
								}
							}
    					}
    				}, this)
    			}
    		});
    	}, this);
    	
        Ext.apply(this, {
            title: this.localize('title'),
            layout: {
            	type: 'hbox',
            	align: 'stretch'
            },
            listeners: {
            	afterrender: function() {
            		var terms = this.getComponent("terms"), threads = this.getComponent("threads");
            		
            		// this is a quick and dirty implementation to mirror actions in the terms panel to the threads panel,
            		// but it should probably redone locally to the threads logic and using the tips
            		terms.on("termHovered", function(src, term) {
            			var thick = threads.getTargetEl().dom.querySelector("path[term="+term+"]");
            			if (thick) {
                			var fadeIt = function(node, time) {
                				opacity = node.getAttribute("opacity");
                				if (opacity>0) {
                					opacity-=.01;
                					node.setAttribute("opacity", opacity)
                					time=time/2
                					Ext.defer(fadeIt, time, this, [node, time]);
                				}
                			}   
                			thick.setAttribute("opacity", 1);
                			fadeIt(thick, 1000);
            			}
            		})
            	}
            },
            items: [{
            	itemId: 'terms',
            	width: 100,
            	layout: 'fit',
            	listeners: {
            		filterchange: function(store) {
            			var el = this.getTargetEl(), width = el.getWidth(), height = el.getHeight(), len = store.getCount();
            			el.setHtml(" ")
            			terms = store.getRange().map(function(r,i) {
            				return {
            					term: r.getTerm(),
            					col: Voyant.application.getColorForTerm(r.getTerm(), true),
            					x: width/2,
            					y: i*height/len
            				}
            			});
            			terms.sort(function(a, b) {return a.term.localeCompare(b.term)});
            			
            			// attempts to use fisheye code failed with larger number or words http://bl.ocks.org/jczaplew/8603055

            			
            			
          			  var svg = d3.select(el.dom).append("svg")
      			    .attr("width", width)
      			    .attr("height", height)
      			  .append("g")
      			    .attr("transform", "translate(-.5,-.5)");
          			  
          			var textHeight = Math.ceil(height/terms.length);
        			  var text = svg.selectAll("ytext")
      			    .data(terms)
      			  .enter().append("text")
      			    .text(function(d,i){return d.term})
      			    .attr("class", "ytext") 
      			    .attr("text-anchor", "middle")
    			  	.attr("x", width/2)
    			  	.attr("y", function(t, i) {return textHeight*i})
      			    .attr("fill", function(d) {return Voyant.application.getColorForTerm(d.term, true)})

            			var textHeight = Math.ceil(height/terms.length);

            			
            			var fisheye = d3.fisheye.circular()
	            		    .radius(50)
	            		    .distortion(2);
            			
            			yFisheye = d3.fisheye.scale(d3.scaleIdentity).domain([0, height]);
            			
            			var me = this;
            			svg.on("mousemove", function() {
            				var mouse = d3.mouse(this);
            					currentItem = Math.round(mouse[1]*terms.length/height),
            					currentItem = Math.min(currentItem, terms.length-1);
            				fisheye.focus(mouse[1]);
            				yFisheye.focus(mouse[1]);
            				
            			var nodes = text.nodes();
            			if (nodes[currentItem]) {
                			me.fireEvent("termHovered", me, nodes[currentItem].textContent)
            			}
            			
            			var fs = 14, y=Math.max(mouse[1],fs), fo=1;
            			d3.select(nodes[currentItem])
            				.attr("y", function(d) { return y })
            				.attr("font-size", fs)
            				.attr("fill-opacity", fo)
            				
            			var yin = undefined;
            			for (var i=currentItem-1;i>-1;i--) {
            				if (fs>=8) {
            					y-=fs
            					fs-=.5
            				} else {
            					if (yin==undefined) {
            						yin = y/i
            					}
            					y-=yin;
            				}
            				if (fo>.1) {fo-=.05}
                			d3.select(nodes[i])
            				.attr("y", function(d) { return y })
            				.attr("font-size", fs)
            				.attr("fill-opacity", fo)
            			}
            			
            			fs = 14, y=Math.max(mouse[1],fs), fo=1, yin=undefined;
            			

            			for (var i=currentItem+1,len=terms.length;i<len;i++) {
            				if (fs>=8) {
            					y+=fs
            					fs-=.5
            				} else {
            					if (yin==undefined) {
            						yin = (height-y)/(len-i)
            					}
            					y+=yin;
            				}
            				if (fo>.1) {fo-=.05}
                			d3.select(nodes[i])
            				.attr("y", function(d) { return y })
            				.attr("font-size", fs)
            				.attr("fill-opacity", fo)
            			}

            			})

            		}
            	}
            },{
            	itemId: 'threads',
//                html: '<canvas></canvas>',
                layout: 'fit',
                flex: 1,
                listeners: {
//                	boxready: function() {
//                		this.body.down("canvas").dom.width=this.getTargetEl().getWidth();
//                		this.body.down("canvas").dom.height=this.getTargetEl().getHeight();
//                	},
            		filterchange: function(store) {
            			var el = this.getTargetEl(), width = el.getWidth(), height = el.getHeight();
            			el.setHtml(" "); // empty
            			terms = store.getRange().map(function(r) {return {
            				term: r.getTerm(),
            				vals: r.getDistributions()
            			}})
            			var svg = d3.select(el.dom).append("svg")
            		      .attr("width", el.getWidth())
            		      .attr("height", el.getHeight());
            			
            			if (terms.length==0) {
            				return this.up("panel").toastInfo("No hits")
            			}
            			
            			var xincrement = width/terms[0].vals.length;
            			
            			var scale, scaleApi = this.up('loom').getApiParam("scaling");
            			if (scaleApi=="sqrt") {scale = d3.scaleSqrt()}
            			else if (scaleApi=="log") {scale = d3.scaleLog();}
            			else {scale = d3.scaleLinear();}
            			
            			var yscale = scale
            				.domain([
            					Math.max(1e-6, Ext.Array.min(terms.map(function(t) {return Ext.Array.min(t.vals)}))),
            					Math.max(1e-6, Ext.Array.max(terms.map(function(t) {return Ext.Array.max(t.vals)})))
            					]).range([1e-6, height-2]);
            			
//            			console.warn(
//            					Math.max(1e-6, Ext.Array.min(terms.map(function(t) {return Ext.Array.min(t.vals)}))),
//            					Math.max(1e-6, Ext.Array.max(terms.map(function(t) {return Ext.Array.max(t.vals)})))
//            					);
            			
            			var valueline = d3.line()
            				.curve(d3.curveCardinal)
	            		    .x(function(d, i) { return (xincrement/2)+(xincrement*i)})
	            		    .y(function(d) { return height-1-yscale(d)});
            			
        			    var tooltip = svg.append("g")
        			    	.attr("opacity", 0);
        			    
        			    var tooltipbox = tooltip.append("rect")
        			    	.attr("fill", "white")
        			    	.attr("text-anchor", "middle")
        			    	.attr("alignment-baseline", "middle")
        			    	.attr("stroke", "rgba(0,0,0,.05)")
        			    	.attr("class", "rect")
        			    	.attr("x", 100)
        			    	.attr("y", 100)
        			    	.attr("width", 70)
        			    	.attr("height", 16)
        			    	.attr("opacity", 1)
        			    	
        			    var tooltiptext = tooltip
        			    	.append("text")
        			    	.attr("text-anchor", "middle")
        			    	.attr("alignment-baseline", "middle")
        			    	.attr("x", 100)
        			    	.attr("y", 100)
//        			    	.attr("width", 100)
//        			    	.attr("height", 12)
        			    	.text("testing")

            			terms.forEach(function(term) {
            				var color = Voyant.application.getColorForTerm(term.term, true)
            				
            				// draw a first line, always visible
            				svg.append("path")
            			      .datum(term.vals)
						      .attr("fill", "none")
						      .attr("stroke", color)
						      .attr("opacity", .5)
						      .attr("stroke-linejoin", "round")
						      .attr("stroke-linecap", "round")
						      .attr("stroke-width", 1)
						      .attr("class", "line")
            			      .attr("d", valueline)

            				
            			    // draw a second line to make it easier to hover (line width 1 is harder to find)
            				svg.append("path")
            			      .datum(term.vals)
						      .attr("fill", "none")
						      .attr("stroke", color)
						      .attr("opacity", 0)
						      .attr("stroke-width", 3)
						      .attr("class", "line")
            			      .attr("term", term.term)
            			      .attr("d", valueline)
						      .on('mouseover', function() { // on mouse out hide line, circles and text
						    	  d3.select(this)
						    	  	.attr("opacity", 1);
						    	  
						    	  var coords = d3.mouse(this);
						    	  
						    	  tooltip
						    	  	.attr("opacity", 1)
						    	  	
						    	  tooltipbox
						    	  	.attr("x", coords[0]-35)
						    	  	.attr("y", coords[1] -8+ (coords[1]>height/2 ? -18 : 18))
							    	 
						    	  tooltiptext
							    	  	.text(term.term)
							    	  	.attr("fill", color)
							    	  	.attr("x", coords[0])
							    	  	.attr("y", coords[1] + (coords[1]>height/2 ? -18 : 18))

						      })
						      .on('mouseout', function() { // on mouse out hide line, circles and text
						    	  d3.select(this)
						    	  	.attr("opacity", 0);
						    	  tooltip.attr("opacity", 0)
						      })
						      
						      tooltip.raise(); // make sure this is at top level for legibility

            			}, this)
            		}

                }
            }],
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [tbitems[0], tbitems[2], tbitems[3], tbitems[4], tbitems[5]/*, {
                	text: this.localize("controls"),
                	tooltip: this.localize("controlsTip"),
                	menu: {
                    	items: tbitems
                	}
                }*/,{
        			fieldLabel: this.localize('visibleTerms'),
        			labelWidth: 70,
        			width: 120,
        			xtype: 'slider',
	            	increment: 25,
	            	minValue: 25,
	            	maxValue: 5000,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("limit")));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			// maybe not necessary when value is smaller
	            			this.fireEvent("loadedCorpus", this, this.getCorpus())
	            		},
	            		scope: this
	            	}
                },{
                	text: this.localize("scaling"),
                	menu: {
                		defaults: {
                			xtype: 'menucheckitem',
                			handler: function(cmp) {
                				this.setApiParam("scaling", cmp.getItemId());
                        		this.getComponent("threads").fireEventArgs("filterchange", [this.getStore()]);
                			},
                			scope: this,
                			listeners: {
                				afterrender: function(cmp) {
                					cmp.setChecked(cmp.getItemId()==this.getApiParam("scaling"))
                				},
                				scope: this
                			},
                			group: 'scaling'
                		},
                		items: [{
                			text: this.localize("scaleLinear"),
                			itemId: 'linear'
                		},{
                			text: this.localize("scaleLog"),
                			itemId: 'log'
                		},{
                			text: this.localize("scaleSqrt"),
                			itemId: 'sqrt'
                		}]
                
                	}
                }]
              }]
        });
        
        this.on('loadedCorpus', function(src, corpus) {
        	var store = corpus.getDocumentsCount()==1 ? corpus.getDocumentTerms() : corpus.getCorpusTerms();
        	store.on("load", function() {
        	    this.updateControlsFromStore();
		    	this.filterRecords();
        	}, this);
        	store.on("filterchange", function() {
        		this.getComponent("terms").fireEventArgs("filterchange", arguments);
        		this.getComponent("threads").fireEventArgs("filterchange", arguments);
        		
        	}, this);
        	this.setStore(store);
        	params = this.getApiParams();
        	Ext.apply(params, {
        		withDistributions: true
        	});
        	store.load({
    		    callback: function(records, operation, success) {
    		    	this.filterRecords();
    		    },
    		    scope: this,
    		    params: params
        	});

        }, this);
        
        this.callParent(arguments);
    },

    filterRecords: function() {
    	var store = this.getStore();
    	store.clearFilter();
    	var limit = parseInt(this.getApiParam("limit")), hit = 0;
    	store.filterBy(function(record) {
    		var keep = Ext.Array.every(this.getControls().getRange(), function(control) {
    			return control.getEnabled()==false || control.getValidateRecord().call(control, record);
    		}, this);
    		return keep && hit++<limit;
    	}, this)
    },
    
    updateControlsFromStore: function() {
    	var store = this.getStore();
    	this.getControls().each(function(control) {
    		control.suspendEvent("change");
    		control.initControl.call(this, store);
    		if (control.getMin()===undefined) {control.setMin(0);}
    		if (control.getLow()==undefined) {control.setLow(control.getMin())}
    		if (control.getMax()===undefined) {control.setMax(1);} // shouldn't happen
    		if (control.getHigh()==undefined) {control.setHigh(control.getMax())}
    		control.resumeEvent("change");
    	})
    },
    
    revalidate: function() {
    	var canvas = this.body.down('canvas').dom, ctx = canvas.getContext("2d");
    	ctx.clearRect(0,0,canvas.width,canvas.height);

    	var controls = this.query('loomcontrol');
    	
    	var loomTermRecords = new Voyant.panel.LoomTermRecords();
    	this.getStore().each(function(record) {
    		var vals = record.getDistributions().map(function(v) {return true;})
    		Ext.Array.each(controls, function(control) {
    			if (control.getChecked()) {
    				if (control.validateRecord) {
    					var newvals = control.validateRecord.call(this, control.getField(), record, record.getDistributions());
//    					console.warn(control.getName(), newvals)
    					if (Ext.isBoolean(newvals) && !newvals) {
    						vals = false;
    						return false;
    					} else if (Ext.isArray(newvals)) {
        					for (var i=0; i<vals.length; i++) {
        						vals[i] = vals[i] && newvals[i];
        					}
        					return Ext.Array.some(vals, function(v) {return v})
    					}
    				}
    			}
    		});
    		if (Ext.isArray(vals) && Ext.Array.some(vals, function(v) {return v})) {
    			loomTermRecords.add(record);
    		}
    	})
    	
    	loomTermRecords.update(canvas, ctx);
    }
    
});

Ext.define('Voyant.panel.LoomTermRecords', {
	config: {
		termRecords: []
	},
	constructor: function(config) {
		this.setTermRecords([])
	    this.callParent(arguments);
	},
	add: function(record) {
		this.getTermRecords().push(new Voyant.panel.LoomTermRecord(record));
	},
	update: function(canvas, ctx) {
		var min = Ext.Array.min(this.getTermRecords().map(function(r) {return Ext.Array.min(r.getValues())}))
		var max = Ext.Array.max(this.getTermRecords().map(function(r) {return Ext.Array.max(r.getValues())}))
		this.getTermRecords().forEach(function(r) {
			r.update(canvas, ctx, min, max)
		})
	}
})

Ext.define('Voyant.panel.LoomTermRecord', {
	config: {
		record: undefined,
		values: undefined,
		term: undefined,
		texts: undefined
	},
	constructor: function(config) {
		this.setRecord(config);
		this.setValues(config.getDistributions());
		var term = config.getTerm();
		this.setTerm(term);
		this.setTexts(config.getDistributions().map(function(v) {
			return new Ext.draw.sprite.Text({
				type: 'text',
				text: term
			})
		}))
	    this.callParent(arguments);
	},
	update: function(canvas, ctx, min, max) {
		var values = this.getValues(), columnWidth = canvas.offsetWidth/(values.length),
			height = canvas.offsetHeight, term = this.getTerm();
		this.getTexts().forEach(function(text, i) {
			var y = values[i]*height/max;
		    ctx.fillText(term, (columnWidth/2)+(i*columnWidth), height-y);
		})
	}
})

Ext.define('Voyant.util.LoomControl', {
    extend: 'Ext.Base',
    mixins: ['Ext.mixin.Observable'],
    constructor: function(config) {
    	this.mixins.observable.constructor.call(this, config);
        this.callParent(arguments);
    },
    config: {
    	group: undefined,
    	name: undefined,
    	enabled: false,
    	min: undefined,
    	max: undefined,
    	low: undefined,
    	high: undefined,
    	initControls: Ext.emptyFn,
    	validateRecord: Ext.emptyFn,
		offsetTipText: false
    },
    setMin: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setMax: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setLow: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setHigh: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setValues: function(low, high) {
    	this.suspendEvent("change");
    	if (Ext.isArray(low)) {
        	this.setLow(low[0]);
        	this.setHigh(low[1]);
    	} else {
        	this.setLow(low);
        	this.setHigh(high);
    	}
    	this.resumeEvent("change");
    	if (arguments.length < 3 || !arguments[2]) {this.fireEvent("change", this);}
    	return this;
    },
    setEnabled: function() {
    	this.callParent(arguments);
    	if (arguments.length < 2 || !arguments[1]) {this.fireEvent("change", this);}
    	return this;
    }
    
})
Ext.define('Voyant.panel.MicroSearch', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.microsearch',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	/**
    	 * @private
    	 */
    	options: {xtype: 'stoplistoption'},
    	
    	/**
    	 * @private
    	 */
    	maxTokens: 0,
    	
    	/**
    	 * @private
    	 */
    	tokensPerSegment: 0,
    	
    	/**
    	 * @private
    	 */
    	maxVerticalLines: 0,
    	
    	/**
    	 * @private
    	 */
    	maxSegments: 0
    },
    constructor: function(config ) {

    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                }]
    		}]
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.rendered) {
    			this.initialize();
    		}
    		else {
    			this.on("afterrender", function() {
    				this.initialize();
    			}, this)
    		}

    	});
    	
    	this.on('query', function(src, query) {
    		this.setApiParam('query', query);
    		this.updateSearchResults();
    	})
    	
    },
    
    initialize: function() {

    	var el = this.getTargetEl(), corpus = this.getCorpus();
    	
		var lineSize = 5; // pixels, including margins below and above
		this.setMaxVerticalLines(Math.floor((el.getHeight() - 10 /* margin of 5px */) / lineSize));
		
		// max segments
		var gutterSize = 10;
		var corpusSize = corpus.getDocumentsCount();
		var gutter = corpusSize * gutterSize;
		var columnSize = Math.floor((el.getWidth() - gutter - 10 /* margin of 5px */) / corpusSize);
		if (columnSize>200) {columnSize=200;}
		var segmentWidth = 3; // each segment is 3 pixels
		var maxSegmentsPerLine = Math.floor(columnSize / segmentWidth);
		if (maxSegmentsPerLine<1) {maxSegmentsPerLine=1;}
		
		// and the answer is...
		this.setMaxSegments(maxSegmentsPerLine * this.getMaxVerticalLines());
		
		var documentsStore = corpus.getDocuments();
		this.setMaxTokens(documentsStore.max('tokensCount-lexical'));

		this.setTokensPerSegment(this.getMaxTokens() < this.getMaxSegments() ? 1 : Math.ceil(this.getMaxTokens()/this.getMaxSegments()));
		

		var canvas = "<table cellpadding='0' cellspacing='0' style='height: 100%'><tr>";
		this.segments = [];
		documentsStore.each(function(document) {
			docIndex = document.getIndex();
			canvas+='<td style="overflow: hidden; vertical-align: top; width: '+columnSize+'px;">'+
				'<div class="docLabel" style="white-space: nowrap; width: '+columnSize+'px;" data-qtip="'+document.getFullLabel()+'">'+document.getFullLabel()+"</div>"+
				'<canvas style="display: block;" width="'+columnSize+'" height="'+el.getHeight()+'" id="'+this.body.id+'-'+docIndex+'">'+
				'</td>';
			if (docIndex+1<corpusSize) {canvas+='<td style="width: '+gutterSize+'px;">&nbsp;</td>';}
		}, this);
		canvas+='</tr></table>';
		el.update(canvas);
		
		this.updateSearchResults();
		
    	if (!this.getApiParam('query')) {
    		var me = this;
    		return this.getCorpus().loadCorpusTerms({limit: 1, stopList: this.getApiParam('stopList')}).then(function(corpusTerms) {
    			var term = corpusTerms.getAt(0).getTerm();
    			var q = me.down('querysearchfield');
    			q.addValue(new Voyant.data.model.CorpusTerm({term: term}));
    			me.fireEvent("query", me, [term])
    		});
    	}

    },
    
    updateSearchResults: function() {
    	query = this.getApiParam('query');
    	if (Ext.Array.from(query).length==0) { // draw simple lines
        	this.getCorpus().getDocuments().each(function(document) {
        		var distributions = this.redistributeDistributions(document, new Array(this.getMaxSegments()));
        		this.drawDocumentDistributions(document, distributions);
        	}, this)
    	} else {
    		this.mask(this.localize('loading'))
    		this.getCorpus().getDocumentTerms().load({
    			params: {
    				query: Ext.Array.from(query).join('|'), // treat as one query
        			withDistributions: 'relative',
        			bins: this.getMaxSegments()
    			},
    			callback: function(records, operation, success) {
    				this.unmask();
    				var max = 0, min = Number.MAX_VALUE, docs = [], m;
    				records.forEach(function(record) {
    					var doc = this.getCorpus().getDocument(record.getDocIndex());
    					var distributions = this.redistributeDistributions(doc, record.getDistributions())
    					m = Ext.Array.max(distributions);
    					if (m>max) {max=m;}
    					distributions.forEach(function(d) {
    						if (d && d<min) {
    							min = d;
    						}
    					})
    					docs[record.getDocIndex()] = this.redistributeDistributions(doc, record.getDistributions());
    				}, this);
    				docs.forEach(function(distributions, i) {
                    	this.drawDocumentDistributions(this.getCorpus().getDocument(i), distributions, min || Ext.Array.min(distributions), max || Ext.Array.max(distributions));
    				}, this)
    			},
    			scope: this
    		})
    	}
    },
    
    redistributeDistributions: function(doc, distributions) {
		var segments = Math.ceil(doc.getLexicalTokensCount() / this.getTokensPerSegment());

		// redistribute if needed, we'll take the mean of the distribution values to maintain comparison across segments
    	if (distributions.length>segments) {
    		var newdistributions = [];
    		for (var i=0; i<distributions.length; i++) {
    			var a = parseInt(i*segments/distributions.length);
    			if (newdistributions[a]) {newdistributions[a].push(distributions[i])}
    			else {newdistributions[a]=[distributions[i]];}
    		}
			distributions = newdistributions
    		for (var i=0; i<distributions.length; i++) {
    			distributions[i] = Ext.Array.mean(distributions[i]);
    		}
    	}
    	return distributions;
    },
    
    drawDocumentDistributions: function(doc, distributions, min, max) {
    	var canvas = this.getTargetEl().dom.querySelector("#"+this.body.id+"-"+doc.getIndex());
    	var c = canvas.getContext('2d');
    	var x = 0, w = canvas.clientWidth, y = 0;
    	for (var j=0; j<distributions.length;j++) {
    		c.fillStyle = distributions[j] ? "rgba(250,0,0,"+(((distributions[j]-min)*.8/(max-min))+.2)+")" : "rgb(230,230,230)";
    		c.fillRect(x,y,3,3)
    		x+=3;
    		if (x>=w) {x=0; y+=5}
    	}
    	
    }
});
Ext.define('Voyant.panel.Mandala', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.mandala',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		query: undefined,
    		
    		labels: true
    		
    	},
    	glyph: 'xf1db@FontAwesome'
	},
	
	gutter: 5,
	
	textFont: '12px sans-serif',
	
	config: {
    	options: [{xtype: 'stoplistoption'}]
	},
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	Ext.apply(this, {
    		title: this.localize('title'),
			html: '<div style="text-align: center"><canvas width="800" height="600"></canvas></div>',
			dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	text: this.localize('add'),
        			glyph: 'xf067@FontAwesome',
                	handler: function() {
                		this.editMagnet();
                	},
                	scope: this
                },{
                	text: this.localize('clear'),
					glyph: 'xf014@FontAwesome',
                	handler: function() {
                		this.setApiParam('query', undefined);
                		this.updateFromQueries(true);
                		this.editMagnet();
                	},
                	scope: this
	            },{
	                xtype: 'checkbox',
	                boxLabel: this.localize('labels'),
	                listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(this.getApiParam("labels")===true);
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('labelsTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    change: function(cmp, val) {
	                    	this.setApiParam('labels', val);
	                    	this.draw();
	                    },
	                    scope: this
	                }
	            }]
    		}]			
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('boxready', function(cmp) {
			var canvas = this.getTargetEl().dom.querySelector("canvas");
			var me = this;
    		canvas.addEventListener('mousemove', function(evt) {
    			var rect = canvas.getBoundingClientRect(), x =  evt.clientX - rect.left, y = evt.clientY - rect.top,
				change = false, docRadius = parseInt(me.textFont)/2;
    			if (me.documents) {
    				me.documents.forEach(function(doc) {
    					var isHovering = x > doc.x-docRadius && x < doc.x+docRadius && y > doc.y-docRadius && y < doc.y+docRadius;    					
    					if (isHovering!=doc.isHovering) {change = true;}
    					doc.isHovering = isHovering;
    				})
    			}
				radius = parseInt(me.textFont)/2;
				for (term in me.magnets) {
					var isHovering = x > me.magnets[term].x-radius && x < me.magnets[term].x+radius && y > me.magnets[term].y-radius && y < me.magnets[term].y+radius;    					
					if (isHovering!=me.magnets[term].isHovering) {change = true;}
					me.magnets[term].isHovering = isHovering;
				}
				if (change) {
					me.draw();
				}
    	    }, false);
    		canvas.addEventListener('click', function(evt) {
    			var rect = canvas.getBoundingClientRect(), x =  evt.clientX - rect.left, y = evt.clientY - rect.top,
					docRadius = parseInt(me.textFont)/2;
				for (term in me.magnets) {
					if (x > me.magnets[term].x-radius && x < me.magnets[term].x+radius && y > me.magnets[term].y-radius && y < me.magnets[term].y+radius) {
						me.editMagnet(term);
					}
				}
    	    }, false);
    	})
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		this.documents = [];
    		var canvas = this.getTargetEl().dom.querySelector("canvas"), ctx = canvas.getContext("2d"), radius = canvas.width/2;
    		ctx.font = this.textFont;
    		corpus.getDocuments().each(function(document) {
    			var label = document.getTinyTitle();
    			this.documents.push({
    				doc: document,
    				label: label,
    				width: ctx.measureText(label).width,
    				x: radius,
    				y: radius,
    				matches: [],
    				isHovering: false
    			});
    		}, this);
    		this.updateDocs(canvas);
    		this.draw();
    		this.updateFromQueries();
    	}, this);
    	
    	this.on("resize", function() {
    		var canvas = this.getTargetEl().dom.querySelector("canvas"),
    			diam = Math.min(this.getTargetEl().getWidth(), this.getTargetEl().getHeight());
    		canvas.width = diam;
    		canvas.height = diam;
	    	this.updateMagnets();
	    	this.updateDocs();
    		this.draw(canvas)
    	})
    },
    
    editMagnet: function(term) {
    	var me = this, currentTerms = Ext.Array.from(me.getApiParam('query'));
		Ext.create('Ext.window.Window', {
			title: this.localize("EditMagnet"),
			modal: true,
			items: {
				xtype: 'form',
				width: 300,
				items: [{
					xtype: 'querysearchfield',
					corpus: this.getCorpus(),
					store: this.getCorpus().getCorpusTerms({
						proxy: {
							extraParams: {
								stopList: this.getApiParam('stopList')
							}
						}
					}),
					stopList: this.getApiParam('stopList'),
					listeners: {
						afterrender: function(field) {
							if (term) {
								var termObj = new Ext.create("Voyant.data.model.CorpusTerm", {
									term: term
								});
								field.getStore().loadData(termObj, true)
								field.setValue(termObj);
							}
						}
					}
				},{
					xtype: "numberfield",
				    fieldLabel: me.localize('rotateClockwise'),
				    minValue: 0,
				    maxValue: currentTerms.length-1,
				    value: 0,
				    stepValue: 1,
				    width: 200,
				    name: "rotate"
				}],
				buttons: [{
	            	text: this.localize("remove"),
					glyph: 'xf0e2@FontAwesome',
	            	flex: 1,
		            ui: 'default-toolbar',
	        		handler: function(btn) {
	        			var queries = Ext.Array.filter(Ext.Array.from(me.getApiParam('query')), function(query) {
	        				return query!=term
	        			});
	        			me.setApiParam('query', queries);
	        			me.updateFromQueries(queries.length==0);
	        			btn.up('window').close();
	        		},
	        		scope: this
				},{xtype: 'tbfill'}, {
	            	text: this.localize("cancel"),
		            ui: 'default-toolbar',
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize("update"),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var val = btn.up('window').down('querysearchfield').getValue().join("|")
	        			if (val) {

	        				// start by updating the term in place
		        			var position = -1;
		        			for (var i=0; i<currentTerms.length; i++) {
		        				if (term==currentTerms[i]) {
		        					position=i;
		        					currentTerms[i]=val;
		        					
				        			// see if we need to shift
				        			var rotate = btn.up('window').down('numberfield').getValue();
				        			if (rotate) {
				        				currentTerms.splice(i, 1);
				        				var newpos = i+rotate;
				        				if (newpos>currentTerms.length) {newpos-=currentTerms.length+1;}
				        				currentTerms.splice(newpos, 0, val);
				        			}
				        			break
				        			
		        				}
		        			}
		        			if (position==-1) { // not sure why it couldn't be found
		        				currentTerms.push(val);
		        			}		        			
	        			}
	        			
	        			me.setApiParam('query', currentTerms);
	        			me.updateFromQueries(currentTerms.length==0);
	        			btn.up('window').close();
	        		},
	        		scope: this
	            }]
			},
			bodyPadding: 5
		}).show()
    },
    
    updateFromQueries: function(allowEmpty) {
		this.magnets = undefined;
		this.documents.forEach(function(doc) {doc.matches=[]})
		this.updateDocs();
		this.draw();
    	if (this.documents) {
    		var params = this.getApiParams();
    		if (!params.query) {params.limit=10;}
        	var queries = Ext.Array.from(this.getApiParam('query'));
        	if (!allowEmpty || queries.length>0) {
        		this.getCorpus().getCorpusTerms().load({
        			params: Ext.apply(params, {withDistributions: true}),
        			callback: function(records) {
        		    	var canvas = this.getTargetEl().dom.querySelector("canvas"), ctx = canvas.getContext("2d");
        		    		diam = canvas.width, rad = diam /2;
        		    	ctx.font = this.textFont;
        		    	var magnets = {};
        		    	for (var i=0, len=records.length; i<len; i++) {
        		    		var term = records[i].getTerm();
        		    		records[i].getDistributions().forEach(function(val, i) {
        		    			if (val>0) {
        		    				this.documents[i].matches.push(term)
        		    			}
        		    		}, this);
        		    		magnets[term] = {
        		    			record: records[i],
        		    			colour: this.getApplication().getColor(i),
        		    			width: ctx.measureText(term).width,
        		    			isHovering: false
        		    		}
        		    	}

        		    	this.magnets = {};
        		    	
        		    	// try ordering by queries
        		    	queries.forEach(function(query) {
        		    		if (magnets[query]) {
            		    		this.magnets[query] = magnets[query]
            		    		delete magnets[query]
        		    		}
        		    	}, this);
        		    	
        		    	// now for any leftovers
        		    	for (term in magnets) {
        		    		this.magnets[term] = magnets[term]
        		    	}
        		    	
        		    	this.setApiParam('query', Object.keys(this.magnets))
        		    	this.updateMagnets();
        		    	this.updateDocs();
        		    	this.draw();
        			},
        			scope: this
        		})
        	}
    	}
    },
    
    updateMagnets: function(canvas) {
    	var canvas = this.getTargetEl().dom.querySelector("canvas"), diam = canvas.width, rad = diam /2;
    	var len = Object.keys(this.magnets || {}).length;
    	var i = 0;
    	for (var term in this.magnets) {
    		Ext.apply(this.magnets[term], {
				x:  rad+((rad-this.gutter-50) * Math.cos(2 * Math.PI * i / len)),
				y:  rad+((rad-this.gutter-50) * Math.sin(2 * Math.PI * i / len))
    		})
    		i++;
    	}
    },
    
    updateDocs: function(canvas) {
    	canvas = canvas ||  this.getTargetEl().dom.querySelector("canvas"), diam = canvas.width, rad = diam /2;
    	var notMatching = [];
    	if (this.documents) {
        	this.documents.forEach(function(doc, i) {
        		if (Ext.Array.from(doc.matches).length==0) {notMatching.push(i);} // will be set around perimeter below
        		else if (Ext.Array.from(doc.matches).length==1) { // try to set it away from magnet
        			var x = (Math.random()*15)+15, y = (Math.random()*15)+15;
        			doc.targetX = this.magnets[doc.matches[0]].x + (Math.round(Math.random())==0 ? x : -x);
        			doc.targetY = this.magnets[doc.matches[0]].y + (Math.round(Math.random())==0 ? y : -y);
        		} else {
        			// determine the weighted position
        			var x = 0, y = 0,
        				vals = doc.matches.map(function(term) {return this.magnets[term].record.getDistributions()[i]}, this),
        				min = Ext.Array.min(vals), max = Ext.Array.max(vals);
        			var weights = 0;
        			doc.matches.forEach(function(term, j) {
        				weight = max==min ? 1 : ((vals[j]-min)+min)/((max-min)+min);
        				weights += weight;
        				x += this.magnets[term].x*weight;
        				y += this.magnets[term].y*weight;
        				
        			}, this)
        			doc.targetX = x/weights
        			doc.targetY = y/weights
        		}
        	}, this);
        	
        	// set around perimeter
        	for (var i=0, len=notMatching.length; i<len; i++) {
        		Ext.apply(this.documents[i], {
    				targetX:  rad+((rad-this.gutter) * Math.cos(2 * Math.PI * i / len)),
    				targetY:  rad+((rad-this.gutter) * Math.sin(2 * Math.PI * i / len))
        		})
        	}
    	}
    },
    
    draw: function(canvas, ctx) {
    	canvas = canvas ||  this.getTargetEl().dom.querySelector("canvas");
    	ctx = ctx || canvas.getContext("2d");
    	ctx.font = this.textFont;
    	var radius = canvas.width/2;
    	ctx.clearRect(0,0,canvas.width,canvas.height);
    	var labels = this.getApiParam('labels');
    	
    	// draw circle
    	ctx.beginPath();
    	ctx.strokeStyle = "rgba(0,0,0,.1)"
        ctx.fillStyle = "rgba(0,0,0,.02)"
    	ctx.arc(radius, radius, radius-this.gutter, 0, 2 * Math.PI, false);
    	ctx.fill();
    	ctx.lineWidth = 2;
    	ctx.stroke();
    	
    	// determine if we're animating a move and need to come back
    	var needRedraw = false;
    	
    	// draw documents
    	
    	if (this.documents && this.documents.length>0) {
    		var needMove = false;
    		
    		var noHovering = Ext.Array.each(this.documents, function(doc) {
    			return !doc.isHovering
    		}, this);
    		
    		if (noHovering===true) {
    			noHovering = Ext.Array.each(Object.keys(this.magnets || {}), function(term) {
        			return !this.magnets[term].isHovering
        		}, this);
    		}
			// go through a first time to draw connecting lines underneath
    		var hoveringTerms = {}; hoveringDocs = [];
    		this.documents.forEach(function(document, j) {
	        	document.matches.forEach(function(term, i) {
	        		ctx.beginPath();
	        		ctx.moveTo(document.x, document.y);
	        		ctx.lineTo(this.magnets[term].x, this.magnets[term].y);
	        		if (noHovering===true) {
		        		ctx.strokeStyle = "rgba("+this.magnets[term].colour.join(",")+",.1)";
	        		} else {
	        			if (document.isHovering || this.magnets[term].isHovering) {
	        				hoveringDocs[j]=true;
	        				hoveringTerms[term]=true;
			        		ctx.strokeStyle = "rgba("+this.magnets[term].colour.join(",")+",.5)";
	        			} else {
		        			ctx.strokeStyle = "rgba(0,0,0,.02)";
	        			}
	        		}
	        		ctx.stroke();
	        	}, this);
    		}, this);
    			
			// now a second time for labels/markers
    		var halfSize = parseInt(this.textFont)/2, height = parseInt(this.textFont)+4;
    		this.documents.forEach(function(document, i) {
    			
    			// draw marker/label
    			if (labels || document.isHovering || hoveringDocs[i]==true) {
	    		    var width = document.width+4;
			        ctx.fillStyle = document.isHovering || hoveringDocs[i]==true || noHovering===true ? "white" : "rgba(255,255,255,.05)"
	    		    ctx.fillRect(document.x-(width/2), document.y-(height/2), width, height);
			        ctx.strokeStyle = document.isHovering || hoveringDocs[i]==true || noHovering===true ? "rgba(0,0,0,.2)" : "rgba(0,0,0,.05)"
	    		    ctx.strokeRect(document.x-(width/2), document.y-(height/2), width, height);
			        ctx.textAlign = "center";
			        ctx.fillStyle = document.isHovering || hoveringDocs[i]==true || noHovering===true ? "rgba(0,0,0,.8)" : "rgba(0,0,0,.05)";
	    		    ctx.fillText(document.label, document.x, document.y);
    			} else {
    		    	ctx.beginPath();
    		        ctx.fillStyle = "rgba(0,0,0,.8)"
    		    	ctx.arc(document.x, document.y, halfSize, 0, 2 * Math.PI);
    	        	ctx.fill();
    		    	ctx.stroke();
    			}
	        	
	        	// determine if we need to move
		    	var dx = Math.abs(document.x - document.targetX), dy = Math.abs(document.y- document.targetY)
		    	if (dx!=0 || dy!=0) {
		    		if (dx<1) {document.x = document.targetX}
		    		else {
		    			dx/=2;
		    			document.x = document.x > document.targetX ? document.x-dx : document.x+dx;
		    		}
		    		if (dy<1) {document.y = document.targetY}
		    		else {
		    			dy/=2;
		    			document.y = document.y > document.targetY ? document.y-dy : document.y+dy;
		    		}
		    		needRedraw = true;
		    	}
    		}, this);
    		
    		// now magnets
    		var i = 0, height = parseInt(this.textFont)+4;
	        ctx.textAlign = "center";
	        ctx.textBaseline="middle";
	        for (var term in this.magnets) {
	        	if (labels || term in hoveringTerms || this.magnets[term].isHovering) {
	    		    var width = this.magnets[term].width+4;
			        ctx.fillStyle = term in hoveringTerms || this.magnets[term].isHovering || noHovering===true ? "white" : "rgba(255,255,255,.05)";
	    		    ctx.fillRect(this.magnets[term].x-(width/2), this.magnets[term].y-(height/2), width, height);
			        ctx.strokeStyle = term in hoveringTerms || this.magnets[term].isHovering || noHovering===true ? "rgb("+this.magnets[term].colour.join(",")+")" : "rgba(0,0,0,.05)";
	    		    ctx.strokeRect(this.magnets[term].x-(width/2), this.magnets[term].y-(height/2), width, height);
			        ctx.textAlign = "center";
			        ctx.fillStyle = term in hoveringTerms || this.magnets[term].isHovering || noHovering===true ?"rgba(0,0,0,.8)" : "rgba(0,0,0,.05)";
	    		    ctx.fillText(term, this.magnets[term].x, this.magnets[term].y);
	        	} else {
			    	ctx.beginPath();
			        ctx.fillStyle = "rgb("+this.magnets[term].colour.join(",")+")"
			        ctx.strokeStyle = "rgb("+this.magnets[term].colour.join(",")+")"
			    	ctx.arc(this.magnets[term].x, this.magnets[term].y, 12, 0, 2 * Math.PI);
		        	ctx.fill();
			    	ctx.stroke();
	        	}
    		}
    	}
    	
		if (needRedraw) {
			var me = this;
			setTimeout(function() {
				me.draw();
			}, 100);
		} else if (this.documents) {
			var minDist = Math.max(radius/this.documents.length, 50), spring = .1
			for (var i=0, len=this.documents.length; i<len; i++) {
				for (var j=0; j<len; j++) {
					if (i<j) {
						
						var dx = this.documents[i].x  - this.documents[j].x,
							dy = this.documents[i].y - this.documents[j].y,
							dist = Math.sqrt(dx * dx + dy * dy);
						if (dist < minDist) {
							var ax = dx * spring, ay = dy * spring;
							this.documents[i].targetX += ax;
							this.documents[j].targetX -= ax;
							this.documents[i].targetY += ay;
							this.documents[j].targetY -= ay;
							needRedraw = true;
						}
					}
				}
			}
			if (needRedraw) {
				var me = this;
				setTimeout(function() {
					me.draw();
				}, 100);
			}
		}
    }
    
});
Ext.define('Voyant.panel.MicroOcp', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.microocp',
    statics: {
    	i18n: {
    		title: "MicroOCP"
    	},
    	api: {
    		config: undefined,
    		stopList: 'auto'
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    },
    
    constructor: function(config) {
    	debugger
    	config = config || {};
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
		
    	Ext.apply(this, {
    		title: this.localize('title'),
    		layout: 'hbox',
    		items: [{
		        	xtype: 'panel',
		        	flex: 1,
		        	height: '100%',
		        	align: 'stretch',
		        	header: false,
		        	listeners: {
		        		boxready: function() {
		        			var me = this;
		        			var editor = ace.edit(Ext.getDom(this.getEl()));
		        			debugger
//		        			editor.$blockScrolling = Infinity;
//		        			editor.getSession().setUseWorker(true);
//		        			editor.setTheme(this.getTheme());
//		        			editor.getSession().setMode(this.getMode());
//		        			editor.setOptions({minLines: 6, maxLines: this.getMode().indexOf("javascript")>-1 ? Infinity : 10, autoScrollEditorIntoView: true, scrollPastEnd: true});
//		        			editor.setHighlightActiveLine(false);
//		        			editor.renderer.setShowPrintMargin(false);
//		        			editor.renderer.setShowGutter(false);
//		        			editor.setValue(this.getContent() ? this.getContent() : this.localize('emptyText'));
//		        			editor.clearSelection();
//		        		    editor.on("focus", function() {
//		        		    	me.getEditor().renderer.setShowGutter(true);
//		        		    }, this);
		        		}

		        	}
		        }]
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    	});
    	
    	this.on('afterrender', function(panel) {
    		
    	});
    	
    	
    }
    
});

Ext.define('Voyant.panel.Reader', {
	extend: 'Ext.panel.Panel',
	requires: ['Voyant.data.store.Tokens'],
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.reader',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		start: 0,
    		limit: 1000,
    		skipToDocId: undefined,
    		query: undefined
    	},
    	glyph: 'xf0f6@FontAwesome'
	},
    config: {
    	innerContainer: undefined,
    	tokensStore: undefined,
    	documentsStore: undefined,
    	documentTermsStore: undefined,
    	exportVisualization: false,
    	lastScrollTop: 0,
    	scrollIntoView: false,
    	insertWhere: 'beforeEnd',
    	locationMarker: undefined,
    	lastLocationUpdate: new Date(),
    	isDetailedGraph: true
    },
    
    SCROLL_UP: -1,
    SCROLL_EQ: 0,
    SCROLL_DOWN: 1,
    
    LOCATION_UPDATE_FREQ: 100,
    
    DETAILED_GRAPH_DOC_LIMIT: 25, // upper limit on document count for showing detailed graphs 
    
    INITIAL_LIMIT: 1000, // need to keep track since limit can be changed when scrolling
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function(config) {
    	var tokensStore = Ext.create("Voyant.data.store.Tokens", {
    		parentTool: this,
    		proxy: {
    			extraParams: {
    				forTool: 'reader'
    			}
    		}
    	})
    	var me = this;
    	tokensStore.on("beforeload", function(store) {
    		return me.hasCorpusAccess(store.getCorpus());
    	})
    	tokensStore.on("load", function(s, records, success) {
    		if (success) {
	    		var contents = "";
	    		var documentFrequency = this.localize("documentFrequency");
	    		var isPlainText = false;
	    		var docIndex = -1;
	    		var isLastNewLine = false;
	    		records.forEach(function(record) {
	    			if (record.getPosition()==0) {
	    				contents+="<h3>"+this.getDocumentsStore().getById(record.getDocId()).getFullLabel()+"</h3>";
	    			}
	    			if (record.getDocIndex()!=docIndex) {
	    				isPlainText = this.getDocumentsStore().getById(record.getDocId()).isPlainText();
	    				docIndex = record.getDocIndex();
	    			}
	    			if (record.isWord()) {
	    				isLastNewLine = false;
	    				contents += "<span class='word' id='"+ record.getId() + "' data-qtip='"+documentFrequency+" "+record.getDocumentRawFreq()+"'>"+ record.getTerm() + "</span>";
	    			}
	    			else {
	    				var newContents = record.getTermWithLineSpacing(isPlainText);
	    				var isNewLine = newContents.indexOf("<br />")==0;
	    				if (isLastNewLine && (isNewLine || newContents.trim().length==0)) {}
	    				else {
	    					contents += newContents;
	    					isLastNewLine = isNewLine;
	    				}
	    			}
	    		}, this);
	    		this.updateText(contents);
	    		
	    		var keyword = this.down('querysearchfield').getValue();
	    		if (keyword != '') {
//	    			this.highlightKeywords(keyword);
	    		}
    		}
    	}, this);
    	this.setTokensStore(tokensStore);
    	
    	this.on("query", function(src, queries) {
    		this.loadQueryTerms(queries);
    	}, this);
    	
    	this.setDocumentTermsStore(Ext.create("Ext.data.Store", {
			model: "Voyant.data.model.DocumentTerm",
    		autoLoad: false,
    		remoteSort: false,
    		proxy: {
				type: 'ajax',
				url: Voyant.application.getTromboneUrl(),
				extraParams: {
					tool: 'corpus.DocumentTerms',
					withDistributions: true,
					// TODO handle positions
					withPositions: true,
					bins: 25,
					forTool: 'reader'
				},
				reader: {
					type: 'json',
		            rootProperty: 'documentTerms.terms',
		            totalProperty: 'documentTerms.total'
				},
				simpleSortMode: true
   		     },
   		     listeners: {
   		    	 load: function(store, records, successful, opts) {
   		    		 store.sort('docIndex', 'ASC');
   		    		 var graphDatas = {};
   		    		 var maxValue = 0;
   		    		 var term; // store last accessed term
   		    		 store.each(function(r) {
   		    			 var graphData = [];
   		    			 var dist = r.get('distributions');
   		    			 var docId = r.get('docId');
   		    			 var docIndex = r.get('docIndex');
   		    			 term = r.get('term');
   		    			 for (var i = 0; i < dist.length; i++) {
   		    				 var bin = i;//docIndex * dist.length + i;
   		    				 var val = dist[i];
   		    				 if (val > maxValue) maxValue = val;
   		    				 graphData.push([docId, docIndex, bin, val, term]);
   		    			 }
   		    			 graphDatas[docIndex] = graphData;
   		    		 }, this);
   		    		 
   		    		 this.highlightKeywords(term);
//   		    		 this.down('querysearchfield').setValue(term);
   		    		 
   		    		 if (this.getIsDetailedGraph()) {
	   		    		 var graphs = this.query('cartesian');
	   		    		 for (var i = 0; i < graphs.length; i++) {
	   		    			 var graph = graphs[i];
	   		    			 var data = graphDatas[i];
	   		    			 if (data !== undefined) {
	   		    				 graph.getAxes()[0].setMaximum(maxValue);
	 		    				 graph.getStore().loadData(data);
	   		    			 } else {
	   		    				 graph.getStore().removeAll();
	   		    			 }
	   		    		 }
   		    		 }
   		    	 },
   		    	 scope: this
   		     }
    	}));
    	
    	this.on("afterrender", function() {
    		var centerPanel = this.down('panel[region="center"]');
    		this.setInnerContainer(centerPanel.getLayout().getRenderTarget());
    		
    		// scroll listener
    		centerPanel.body.on("scroll", function(event, target) {
    			var scrollDir = this.getLastScrollTop() < target.scrollTop ? this.SCROLL_DOWN
    								: this.getLastScrollTop() > target.scrollTop ? this.SCROLL_UP
									: this.SCROLL_EQ;
    			
    			// scroll up
    			if (scrollDir == this.SCROLL_UP && target.scrollTop < 1) {
    				this.fetchPrevious(true);
    			// scroll down
    			} else if (scrollDir == this.SCROLL_DOWN && target.scrollHeight - target.scrollTop < target.offsetHeight*1.5) {//target.scrollTop+target.offsetHeight>target.scrollHeight/2) { // more than half-way down
    				this.fetchNext(false);
    			} else {
    				var amount;
    				if (target.scrollTop == 0) {
    					amount = 0;
    				} else if (target.scrollHeight - target.scrollTop == target.clientHeight) {
    					amount = 1;
    				} else {
    					amount = (target.scrollTop + target.clientHeight * 0.5) / target.scrollHeight;
    				}
    				
    				var now = new Date();
        			if (now - this.getLastLocationUpdate() > this.LOCATION_UPDATE_FREQ || amount == 0 || amount == 1) {
        				this.updateLocationMarker(amount, scrollDir);
        			}
    			}
    			this.setLastScrollTop(target.scrollTop);
    		}, this);
    		
    		// click listener
    		centerPanel.body.on("click", function(event, target) {
    			target = Ext.get(target);
    			if (target.hasCls('word')) {
    				var info = Voyant.data.model.Token.getInfoFromElement(target);
    				var term = target.getHtml();
    				var data = [{
    					term: term,
    					docIndex: info.docIndex
    				}];
    				this.loadQueryTerms([term]);
    				this.getApplication().dispatchEvent('termsClicked', this, data);
    			}
    		}, this);
    		
    		if (this.getCorpus()) {
    			this.load();
	    		var query = this.getApiParam('query');
	    		if (query) {
	    			this.loadQueryTerms(Ext.isString(query) ? [query] : query);
	    		}
    		}
			this.on("loadedCorpus", function() {
    			this.load(true); // make sure to clear in case we're replacing the corpus
	    		var query = this.getApiParam('query');
	    		if (query) {
	    			this.loadQueryTerms(Ext.isString(query) ? [query] : query);
	    		}
			}, this);
    	}, this);
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		cls: 'voyant-reader',
    	    layout: 'fit',
    	    items: {
    	    	layout: 'border',
    	    	items: [{
    		    	bodyPadding: 10,
    		    	region: 'center',
    		    	border: false,
    		    	autoScroll: true,
    		    	html: '<div class="readerContainer"></div>'
    		    },{
    		    	region: 'south',
    		    	height: 40,
    		    	split: {
    		    		size: 2
    		    	},
    		    	splitterResize: true,
    		    	border: false,
    		    	layout: {
    		    		type: 'hbox'
    		    	}
    		    }]
    	    },
    		// TODO clearing search loads default document terms into chart but probably shouldn't
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	glyph: 'xf060@FontAwesome',
            		handler: function() {
            			this.fetchPrevious(true);
            		},
            		scope: this
            	},{
            		glyph: 'xf061@FontAwesome',
            		handler: function() {
            			this.fetchNext(true);
            		},
            		scope: this
            	},{xtype: 'tbseparator'},{
                    xtype: 'querysearchfield'
                }]
    		}],
    		listeners: {
    			loadedCorpus: function(src, corpus) {
    	    		this.getTokensStore().setCorpus(corpus);
    	    		this.getDocumentTermsStore().getProxy().setExtraParam('corpus', corpus.getId());
    	    		
    	    		var docs = corpus.getDocuments();
    	    		this.setDocumentsStore(docs);
    	    		
    	    		this.setIsDetailedGraph(docs.getTotalCount() < this.DETAILED_GRAPH_DOC_LIMIT);
    	    		
    	    		var container = this.down('panel[region="south"]');
    	    		
    	    		if (this.getLocationMarker() == undefined) {
    	    			this.setLocationMarker(Ext.DomHelper.append(container.el, {tag: 'div', style: 'background-color: #157fcc; height: 100%; width: 2px; position: absolute; top: 0; left: 0;'}));
    	    		}
    	    		
    	    		this.generateChart(corpus, container);
    	    		
    	    		if (this.rendered) {
    	    			this.load();
        	    		if (this.hasCorpusAccess(corpus)==false) {
        	    			this.mask(this.localize("limitedAccess"), 'mask-no-spinner')
        	    		}
        	    		var query = this.getApiParam('query');
        	    		if (query) {
        	    			this.loadQueryTerms(Ext.isString(query) ? [query] : query);
        	    		}
    	    		}
    	    		
    			},
            	termsClicked: function(src, terms) {
            		var queryTerms = [];
            		terms.forEach(function(term) {
            			if (Ext.isString(term)) {queryTerms.push(term);}
            			else if (term.term) {queryTerms.push(term.term);}
            			else if (term.getTerm) {queryTerms.push(term.getTerm());}
            		});
            		if (queryTerms.length > 0) {
            			this.loadQueryTerms(queryTerms);
            		}
        		},
        		corpusTermsClicked: function(src, terms) {
        			var queryTerms = [];
            		terms.forEach(function(term) {
            			if (term.getTerm()) {queryTerms.push(term.getTerm());}
            		});
            		this.loadQueryTerms(queryTerms);
        		},
        		documentTermsClicked: function(src, terms) {
        			var queryTerms = [];
            		terms.forEach(function(term) {
            			if (term.getTerm()) {queryTerms.push(term.getTerm());}
            		});
            		this.loadQueryTerms(queryTerms);
        		},
        		documentSelected: function(src, document) {
        			var corpus = this.getTokensStore().getCorpus();
        			var doc = corpus.getDocument(document);
        			this.setApiParams({'skipToDocId': doc.getId(), start: 0});
					this.load(true);
        		},
        		documentsClicked: function(src, documents, corpus) {
        			if (documents.length > 0) {
            			var doc = documents[0];
            			this.setApiParams({'skipToDocId': doc.getId(), start: 0});
						this.load(true);
            		}
        		},
        		termLocationClicked: function(src, terms) {
    				if (terms[0] !== undefined) {
    					var term = terms[0];
    					var docIndex = term.get('docIndex');
    					var position = term.get('position');
    					var bufferPosition = position - (this.getApiParam('limit')/2);
    					var doc = this.getCorpus().getDocument(docIndex);
    					this.setApiParams({'skipToDocId': doc.getId(), start: bufferPosition < 0 ? 0 : bufferPosition});
    					this.load(true, {
    						callback: function() {
    							var el = this.body.dom.querySelector("#_" + docIndex + "_" + position);
    							if (el) {
    								el.scrollIntoView();
    							}
    							this.highlightKeywords(term.get('term'), false);
    						},
    						scope: this
    					});
    				};
        		},
        		documentIndexTermsClicked: function(src, terms) {
        			if (terms[0] !== undefined) {
    					var term = terms[0];
    					var termRec = Ext.create('Voyant.data.model.Token', term);
    					this.fireEvent('termLocationClicked', this, [termRec]);
        			}
        		},
        		scope: this
    		}
    	});
    	
        this.callParent(arguments);
    },
    
    loadQueryTerms: function(queryTerms) {
    	if (queryTerms && queryTerms.length > 0) {
			this.getDocumentTermsStore().load({
				params: {
					query: queryTerms/*,
    				docIndex: undefined,
    				docId: undefined,
    				page: undefined,
    				start: undefined,
    				limit: undefined*/
    			}
			});
		}
    },
    
    updateLocationMarker: function(amount, scrollDir) {
		var readerWords = Ext.DomQuery.select('.word', this.getInnerContainer().down('.readerContainer', true));
		var firstWord = readerWords[0];
		var lastWord = readerWords[readerWords.length-1];
		if (firstWord !== undefined && lastWord !== undefined) {
			var corpus = this.getCorpus();
			var partialFirstDoc = false;
			
			var info1 = Voyant.data.model.Token.getInfoFromElement(Ext.get(firstWord));
			var info2 = Voyant.data.model.Token.getInfoFromElement(Ext.get(lastWord));
			if (info1.position !== 0) {
				partialFirstDoc = true;
			}

			var docTokens = {};
			var totalTokens = 0;
			var currIndex = info1.docIndex;
			while (currIndex <= info2.docIndex) {
				var tokens = corpus.getDocument(currIndex).get('tokensCount-lexical');
				if (currIndex === info2.docIndex) {
					tokens = info2.position; // only count tokens up until last displayed word
				}
				if (currIndex === info1.docIndex) {
					tokens -= info1.position; // subtract missing tokens, if any
				}
				totalTokens += tokens;
				docTokens[currIndex] = tokens;
				currIndex++;
			}
			
			var tokenPos = Math.round(totalTokens * amount);
			var docIndex = 0;
			var currToken = 0;
			for (var i = info1.docIndex; i <= info2.docIndex; i++) {
				docIndex = i;
				currToken += docTokens[i];
				if (currToken >= tokenPos) {
					break;
				}
			}
			var remains = (currToken - tokenPos);
			var tokenPosInDoc = docTokens[docIndex] - remains;
			
			if (partialFirstDoc && docIndex === info1.docIndex) {
				tokenPosInDoc += info1.position;
			}
				
			var fraction = tokenPosInDoc / corpus.getDocument(docIndex).get('tokensCount-lexical');
			var locMarkEl = Ext.get(this.getLocationMarker());
			var locX = locMarkEl.getX();
			if (this.getIsDetailedGraph()) {
				var graph = this.query('cartesian')[docIndex];
				if (graph) {
					locX = graph.getX() + graph.getWidth()*fraction;
				}
			} else {
				var graph = this.down('cartesian');
				var docWidth = graph.getWidth() / this.getCorpus().getDocuments().getCount();
				locX = graph.getX() + docWidth*docIndex + docWidth*fraction;
			}
			if (scrollDir != null) {
				var currX = locMarkEl.getX();
				// prevent location being set in opposite direction of scroll
				if ((scrollDir == this.SCROLL_DOWN && currX > locX) || (scrollDir == this.SCROLL_UP && currX < locX)) locX = currX;
			}
			locMarkEl.setX(locX);
		}
		this.setLastLocationUpdate(new Date());
    },
    
    generateChart: function(corpus, container) {
    	function getColor(index, alpha) {
    		var c = this.getApplication().getColor(index);
    		return 'rgba('+c[0]+','+c[1]+','+c[2]+','+alpha+')';
    	}
    	
    	function map(value, istart, istop, ostart, ostop) {
			return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
		}
    	
    	function addChart(docInfo) {
    		var index = docInfo.index;
    		var fraction = docInfo.fraction;
    		var height = docInfo.relativeHeight;
    		var bColor = getColor.call(this, index, 0.3);
    		var sColor = getColor.call(this, index, 1.0);
    		var chart = container.add({
    			xtype: 'cartesian',
    			plugins: {
                    ptype: 'chartitemevents'
                },
    	    	flex: fraction,
    	    	height: '100%',
    	    	insetPadding: 0,
    	    	background: {
    	    		type: 'linear',
    	    		degrees: 90,
    	    		stops: [{
    	    			offset: 0,
    	    			color: bColor
    	    		},{
    	    			offset: height,
    	    			color: bColor
    	    		},{
    	    			offset: height,
    	    			color: 'white'
    	    		},{
    	    			offset: 1,
    	    			color: 'white'
    	    		}]
    	    	},
    	    	axes: [{
    	    		type: 'numeric',
    	    		position: 'left',
    	    		fields: 'distribution',
    	    		hidden: true
    	    	},{
    				type: 'category',
    				position: 'bottom',
    				fields: 'bin',
    				hidden: true
        		}],
        		series: [{
        			type: 'line',
        			xField: 'bin',
        			yField: 'distribution',
        			style: {
        				lineWidth: 2,
        				strokeStyle: sColor
        			},
                    tooltip: {
                    	corpus: corpus,
                        trackMouse: true,
                        style: 'background: #fff',
                        showDelay: 0,
                        dismissDelay: 500,
                        hideDelay: 5,
                        renderer: function(toolTip, record, ctx) {
                        	toolTip.setHtml(corpus.getDocument(record.get('docIndex')).getTitle()+"<br>"+record.get('term') + ': ' + record.get('distribution'));
                        }
                    }
        		}],
    	    	store: Ext.create('Ext.data.ArrayStore', {
            		fields: ['docId', 'docIndex', 'bin', 'distribution', 'term'],
            		data: []
            	}),
            	listeners: {
            		itemclick: function(chart, item, event) {
            			var data = item.record.data;
            			var doc = this.getDocumentsStore().getAt(data.docIndex);
            			this.getApplication().dispatchEvent('documentsClicked', this, [doc]);
            		},
            		scope: this
            	}
    		});
    		
    		chart.body.on('click', function(event, target) {
    			var el = Ext.get(target);
    			var x = event.getX();
    			var box = el.getBox();
    			var fraction = (x - box.x) / box.width;
    			var chartContainer = el.parent('.x-panel');
    			var containerParent = chartContainer.parent();
    			var children = Ext.toArray(containerParent.dom.children);
    			var docIndex = children.indexOf(chartContainer.dom);
    			var doc = this.getDocumentsStore().getAt(docIndex);
				var totalTokens = doc.get('tokensCount-lexical');
				
				var position = Math.floor(totalTokens * fraction);
				var bufferPosition = position - (this.getApiParam('limit')/2);
				
				this.setApiParams({'skipToDocId': doc.getId(), start: bufferPosition < 0 ? 0 : bufferPosition});
				this.load(true);
    		}, this);
    	}
    	
    	container.removeAll();
    	
    	var docs = corpus.getDocuments();
    	var tokensTotal = corpus.getWordTokensCount();
    	var docInfos = [];
    	var docMinSize = Number.MAX_VALUE;
    	var docMaxSize = -1;
//		for (var i = 0; i < docs.getTotalCount(); i++) {
		for (var i = 0; i < docs.getCount(); i++) {
			var d = docs.getAt(i);
			var docIndex = d.get('index');
			var count = d.get('tokensCount-lexical');
			if (count < docMinSize) docMinSize = count;
			if (count > docMaxSize) docMaxSize = count;
			var fraction = count / tokensTotal;
			docInfos.push({
				index: docIndex,
				count: count,
				fraction: fraction
			});
		}
		
		if (this.getIsDetailedGraph()) {
			for (var i = 0; i < docInfos.length; i++) {
				var d = docInfos[i];
				d.relativeHeight = d.count==docMaxSize ? 1 : map(d.count, docMinSize, docMaxSize, 0.25, 1);
				addChart.call(this, d);
			}
		} else {
			var chart = container.add({
    			xtype: 'cartesian',
    			plugins: {
                    ptype: 'chartitemevents'
                },
    	    	flex: 1,
    	    	height: '100%',
    	    	insetPadding: 0,
    	    	axes: [{
    	    		type: 'numeric',
    	    		position: 'left',
    	    		fields: 'count',
    	    		hidden: true
    	    	},{
    				type: 'category',
    				position: 'bottom',
    				fields: 'index',
    				hidden: true
        		}],
        		series: [{
        			type: 'bar',
        			xField: 'index',
        			yField: 'count',
        			style: {
        				minGapWidth: 0,
        				minBarWidth: 1,
        				lineWidth: 0,
        				strokeStyle: 'none'
        			},
        			renderer: function (sprite, config, rendererData, index) {
        				var reader = this.getChart().findParentByType('reader');
        				return {fillStyle: getColor.call(reader, index, 0.3)};
        			}
        		}],
    	    	store: Ext.create('Ext.data.JsonStore', {
            		fields: [{name: 'index', type: 'int'}, {name: 'count', type: 'int'}, {name: 'fraction', type: 'float'}],
            		data: docInfos
            	}),
            	listeners: {
            		itemclick: function(chart, item, event) {
            			var el = Ext.get(event.getTarget());
            			var x = event.getX();
            			var box = el.getBox();
            			var docWidth = box.width / this.getCorpus().getDocuments().getCount();
            			var docX = (x - box.x) % docWidth;
            			var fraction = docX / docWidth;

            			var data = item.record.data;
            			var doc = this.getDocumentsStore().getAt(data.index);
            			
            			var totalTokens = doc.get('tokensCount-lexical');
            			var position = Math.floor(totalTokens * fraction);
        				var bufferPosition = position - (this.getApiParam('limit')/2);
        				
        				this.setApiParams({'skipToDocId': doc.getId(), start: bufferPosition < 0 ? 0 : bufferPosition});
        				this.load(true);
            		},
            		scope: this
            	}
    		});
		}

    },
    
    highlightKeywords: function(query, doScroll) {
		if (!Ext.isArray(query)) query = [query];
		
		this.getInnerContainer().first().select('span[class*=keyword]').removeCls('keyword');
		
		var spans = [];
		var caseInsensitiveQuery = new RegExp('^'+query[0]+'$', 'i');
		var nodes = this.getInnerContainer().first().select('span.word');
		nodes.each(function(el, compEl, index) {
			if (el.dom.firstChild && el.dom.firstChild.nodeValue.match(caseInsensitiveQuery)) {
				el.addCls('keyword');
				spans.push(el.dom);
			}
		});
		
//		if (doScroll && spans[0] !== undefined) {
//			Ext.get(nodes[0]).scrollIntoView(reader).frame("ff0000", 1, { duration: 2 });
//		}
	},
    
	fetchPrevious: function(scroll) {
		var readerContainer = this.getInnerContainer().first();
		var first = readerContainer.first('.word');
		if (first != null && first.hasCls("loading")===false) {
			while(first) {
				if (first.hasCls("word")) {
					var info = Voyant.data.model.Token.getInfoFromElement(first);
					var docIndex = info.docIndex;
					var start = info.position;
					var doc = this.getDocumentsStore().getAt(docIndex);    						
					var limit = this.getApiParam('limit');
					var getPrevDoc = false;
					if (docIndex === 0 && start === 0) {
						var scrollContainer = this.down('panel[region="center"]').body;
						var scrollNeeded = first.getScrollIntoViewXY(scrollContainer, scrollContainer.dom.scrollTop, scrollContainer.dom.scrollLeft);
						if (scrollNeeded.y != 0) {
							first.dom.scrollIntoView();
						}
						first.frame("red");
						break;
					}
					if (docIndex > 0 && start === 0) {
						getPrevDoc = true;
						docIndex--;
						doc = this.getDocumentsStore().getAt(docIndex);
						var totalTokens = doc.get('tokensCount-lexical');
						start = totalTokens-limit;
						if (start < 0) {
							start = 0;
							this.setApiParam('limit', totalTokens);
						}
					} else {
						limit--; // subtract one to limit for the word we're removing. need to do this to account for non-lexical tokens before/after first word.
						start -= limit;
					}
					if (start < 0) start = 0;
					
					var mask = first.insertSibling("<div class='loading'>"+this.localize('loading')+"</div>", 'before', false).mask();
					if (!getPrevDoc) {
						first.destroy();
					}
					
					var id = doc.getId();
					this.setApiParams({'skipToDocId': id, start: start});
					this.setInsertWhere('afterBegin')
					this.setScrollIntoView(scroll);
					this.load();
					this.setApiParam('limit', this.INITIAL_LIMIT);
					break;
				}
				first.destroy(); // remove non word
				first = readerContainer.first();
			}
		}
	},
	
	fetchNext: function(scroll) {
		var readerContainer = this.getInnerContainer().first();
		var last = readerContainer.last();
		if (last.hasCls("loading")===false) {
			while(last) {
				if (last.hasCls("word")) {
					var info = Voyant.data.model.Token.getInfoFromElement(last);
					var docIndex = info.docIndex;
					var start = info.position;
					var doc = this.getDocumentsStore().getAt(info.docIndex);
					var id = doc.getId();
					
					var totalTokens = doc.get('tokensCount-lexical');
					if (start + this.getApiParam('limit') >= totalTokens && docIndex == this.getCorpus().getDocumentsCount()-1) {
						var limit = totalTokens - start;
						if (limit <= 1) {
							last.dom.scrollIntoView();
							last.frame("red")
							break;
						} else {
							this.setApiParam('limit', limit);
						}
					}
					
					// remove any text after the last word
					var nextSib = last.dom.nextSibling;
					while(nextSib) {
						var oldNext = nextSib;
						nextSib = nextSib.nextSibling;
						oldNext.parentNode.removeChild(oldNext);
					}
					
					var mask = last.insertSibling("<div class='loading'>"+this.localize('loading')+"</div>", 'after', false).mask();
					last.destroy();
					this.setApiParams({'skipToDocId': id, start: info.position});
					this.setInsertWhere('beforeEnd');
					this.setScrollIntoView(scroll);
					this.load(); // callback not working on buffered store
					this.setApiParam('limit', this.INITIAL_LIMIT);
					break;
				}
				last.destroy(); // remove non word
				last = readerContainer.last();
			}
		}
	},
	
    load: function(doClear, config) {
    	if (doClear) {
    		this.getInnerContainer().first().destroy(); // clear everything
    		this.getInnerContainer().setHtml('<div class="readerContainer"><div class="loading">'+this.localize('loading')+'</div></div>');
			this.getInnerContainer().first().first().mask();
    	}
    	this.getTokensStore().load(Ext.apply(config || {}, {
    		params: Ext.apply(this.getApiParams(), {
    			stripTags: 'blocksOnly',
    			stopList: '' // token requests shouldn't have stopList
    		})
    	}));
    },
    
    updateText: function(contents) {
    	var loadingMask = this.getInnerContainer().down('.loading');
    	if (loadingMask) loadingMask.destroy();
    	// FIXME: something is weird here in tool/Reader mode, this.getInnerContainer() seems empty but this.getInnerContainer().first() gets the canvas?!?
    	var inserted = this.getInnerContainer().first().insertHtml(this.getInsertWhere()/* where is this defined? */, contents, true); // return Element, not dom
    	if (inserted && this.getScrollIntoView()) {
    		inserted.dom.scrollIntoView(); // use dom
    		// we can't rely on the returned element because it can be a transient fly element, but the id is right in a deferred call
    		Ext.Function.defer(function() {
    			var el = Ext.get(inserted.id); // re-get el
    			if (el) {el.frame("red")}
    		}, 100);
    	}
    	var target = this.down('panel[region="center"]').body.dom;
    	var amount;
		if (target.scrollTop == 0) {
			amount = 0;
		} else if (target.scrollHeight - target.scrollTop == target.clientHeight) {
			amount = 1;
		} else {
			amount = (target.scrollTop + target.clientHeight * 0.5) / target.scrollHeight;
		}
    	this.updateLocationMarker(amount);
    },
    
    updateChart: function() {
    	
    }
});

Ext.define('Voyant.panel.SimpleDocReader', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.simpledocreader',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		docIndex: undefined,
    		docId: undefined
    	},
    	glyph: 'xf0f6@FontAwesome'
	},
    config: {
    },
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function(config) {
    	var me = this;
    	Ext.apply(this, {
    		html: '<iframe style="width: 100%; height: 100%; border: none;"></iframe>',
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	glyph: 'xf060@FontAwesome',
            		handler: this.fetchPrevious,
            		scope: this
            	},{
            		glyph: 'xf061@FontAwesome',
            		handler: this.fetchNext,
            		scope: this
                }]
    		}],
    		listeners: {
    			loadedCorpus: function(src, corpus) {
    				
    				// we can keep the reader blank to begin
    				if (this.getApiParam("autoLoadOnLoadedCorpus", "false")==="true") {return;}
    				
    				this.fireEvent("documentSelected", this, 0);
    				
    			},
        		documentSelected: function(src, document) {
        			this.setApiParams({
        				docIndex: this.getCorpus().getDocument(document).getIndex(),
        				docId: undefined
        			});
        			this.fetch();
        		},
        		scope: this
    		}
    	});
    	
        this.callParent(arguments);
    },
    
	fetchPrevious: function() {
		var doc;
		if (this.getApiParam("docIndex")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docIndex"));}
		else if (this.getApiParam("docId")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docId"));}
		else {doc = this.getCorpus().getDocument(1);}
		if (doc.getIndex()>0) {
			this.setApiParams({docIndex: doc.getIndex()-1, docId: undefined});
			this.fetch();
		} else {
			this.toastInfo(this.localize('noPrevious'))
		}
	},
	
	fetchNext: function() {
		var doc;
		if (this.getApiParam("docIndex")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docIndex"));}
		else if (this.getApiParam("docId")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docId"));}
		else {
			this.setApiParams({docIndex: 0, docId: undefined});
			return this.fetch();
		}
		if (doc.getIndex()<this.getCorpus().getDocumentsCount()-1) {
			this.setApiParams({docIndex: doc.getIndex()+1, docId: undefined});
			this.fetch();
		} else {
			this.toastInfo(this.localize('noNext'))
		}
	},
	
	fetch: function() {
		var doc;
		if (this.getApiParam("docIndex")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docIndex"));}
		else if (this.getApiParam("docId")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docId"));}
		else {doc = this.getCorpus().getDocument(0);}
		var iframe = this.getTargetEl().down("iframe", true);
		iframe.setAttribute("src", "about:blank")
		if (this.getApiParam("originalUrlMetadataKey")) {
			var url = doc.get(this.getApiParam("originalUrlMetadataKey"));
			if (url) {
				iframe.setAttribute("src", url)
				return;
			}
		}
		
		var params = {
			corpus: this.getCorpus().getId(),
			docIndex: doc.getIndex(),
			tool: 'corpus.DocumentTokens',
			template: 'docTokensPlusStructure2html',
			outputFormat: 'html',
			limit: 0
		}
		var url = this.getTromboneUrl() + "?" + Ext.Object.toQueryString(params);
		iframe.setAttribute("src", url);

	}
});

Ext.define('Voyant.panel.ScatterPlot', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Ext.chart.CartesianChart'],
	alias: 'widget.scatterplot',
    statics: {
    	i18n: {
    	},
    	api: {
    		docId: undefined,
    		analysis: 'ca',
    		limit: 50,
    		dimensions: 3,
    		bins: 10,
    		clusters: 3,
    		perplexity: 15,
    		iterations: 1500,
    		comparisonType: 'relative',
    		stopList: 'auto',
    		target: undefined,
    		term: undefined,
    		query: undefined,
    		whitelist: undefined,
    		label: ['summary', 'docs', 'terms'],
    		storeJson: undefined
    	},
		glyph: 'xf06e@FontAwesome'
    },
	config: {
		options: {
    		xtype: 'stoplistoption'
    	},
    	caStore: null,
    	pcaStore: null,
    	tsneStore: null,
    	docSimStore: null,
    	termStore: null,
    	chartMenu: null,
    	newTerm: null,
    	termsTimeout: null,
    	highlightData: {x: 0, y: 0, r: 0},
        highlightTask: null
	},
    
    tokenFreqTipTemplate: null,
    docFreqTipTemplate: null,
    
    constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		if ("storeJson" in config) {
    		var json = JSON.parse(config.storeJson);
    		Ext.apply(config, json);
    	}
		this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
    	this.setCaStore(Ext.create('Voyant.data.store.CAAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	this.setPcaStore(Ext.create('Voyant.data.store.PCAAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	this.setTsneStore(Ext.create('Voyant.data.store.TSNEAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	this.setDocSimStore(Ext.create('Voyant.data.store.DocSimAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	
    	this.setTermStore(Ext.create('Ext.data.JsonStore', {
			fields: [
				{name: 'term'},
				{name: 'rawFreq', type: 'int'},
				{name: 'relativeFreq', type: 'number'},
				{name: 'coordinates', mapping : 'vector'},
				{name: 'category'}
			],
			sorters: [{property: 'rawFreq', direction: 'DESC'}],
			groupField: 'category'
		}));
    	
    	this.setChartMenu(Ext.create('Ext.menu.Menu', {
    		items: [
    			{text: this.localize('remove'), itemId: 'remove', glyph: 'xf068@FontAwesome'},
    			{text: this.localize('nearby'), itemId: 'nearby', glyph: 'xf0b2@FontAwesome'}
    		],
    		listeners: {
    			hide: function() {
    				var series = this.down('#chart').getSeries();
    				series[0].enableToolTips();
    				series[1].enableToolTips();
    			},
    			scope: this
    		}
    	}));
    	
    	this.tokenFreqTipTemplate = new Ext.Template(this.localize('tokenFreqTip'));
    	this.docFreqTipTemplate = new Ext.Template(this.localize('docFreqTip'));
    	
        Ext.apply(this, {
        	title: this.localize('title'),
        	layout: 'border',
        	autoDestroy: true,
        	items: [{
    			itemId: 'chartParent',
    			region: 'center',
    			layout: 'fit',
        		tbar: {
        			overflowHandler: 'scroller',
        			items: [{
        				xtype: 'querysearchfield',
        				itemId: 'filterTerms',
        				width: 150
        			},{
                		text: this.localize('labels'),
                		itemId: 'labels',
                		glyph: 'xf02b@FontAwesome',
                		menu: {
                			items: [
                			    {text: this.localize("summaryLabel"), itemId: 'summary', xtype: 'menucheckitem'},
                			    {text: this.localize("docsLabel"), itemId: 'docs', xtype: 'menucheckitem'},
                			    {text: this.localize("termsLabel"), itemId: 'terms', xtype: 'menucheckitem'}
                			],
        					listeners: {
        						afterrender: function(menu) {
        							var labels = this.getApiParam('label');
        							menu.items.each(function(item) {
        								item.setChecked(labels.indexOf(item.getItemId())>-1)
        							})
        						},
        						click: function(menu, item) {
        							var labels = this.getApiParam("label");
        							var label = item.getItemId();
        							if (Ext.isString(labels)) {labels = [labels]}
        							if (item.checked && labels.indexOf(label)==-1) {
        								labels.push(label)
        							} else if (!item.checked && labels.indexOf(label)>-1) {
        								labels = labels.filter(function(item) {return item!=label})
        							}
        							this.setApiParam("label", labels);
        							this.doLabels();
        							this.queryById('chart').redraw();
        						},
        						scope: this
        					}
                		}
                	}]
        			
        		},
        		listeners: {
        			query: function(component, value) {
        				this.getTermStore().filter([{property: 'term', value: value, anyMatch: true}]);
        				this.filterChart(value);
        			},
        			scope: this
        		}
    		},{
    			itemId: 'optionsPanel',
        		title: this.localize('options'),
        		region: 'west',
        		split: true,
        		collapsible: true,
        		collapseMode: 'header',
        		width: 135,
        		scrollable: 'y',
        		layout: {
        			type: 'vbox',
        			align: 'stretch'
        		},
        		defaults: {
        			xtype: 'button',
        			margin: '5',
        			labelAlign: 'top'
        		},
        		items: [{
        			xtype: 'label',
        			text: this.localize('input')
        		},{
    				xtype: 'documentselectorbutton'
    			},{
	            	text: this.localize('freqsMode'),
	            	itemId: 'comparisonType',
					glyph: 'xf201@FontAwesome',
				    tooltip: this.localize('freqsModeTip'),
				    menu: {
				    	items: [
			               {text: this.localize("rawFrequencies"), itemId: 'comparisonType_raw', group: 'freqsMode', xtype: 'menucheckitem'},
			               {text: this.localize("relativeFrequencies"), itemId: 'comparisonType_relative', group: 'freqsMode', xtype: 'menucheckitem'},
			               {text: this.localize("tfidf"), itemId: 'comparisonType_tfidf', group: 'freqsMode', xtype: 'menucheckitem'}
			            ],
       					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var type = item.getItemId().split('_')[1];
    								if (type !== this.getApiParam('comparisonType')) {
	    								this.setApiParam('comparisonType', type);
	    								this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    				    }
				    }
        		},{
        			fieldLabel: this.localize('numTerms'),
        			itemId: 'limit',
        			xtype: 'numberfield',
        			minValue: 5,
        			listeners: {
        				change: function(numb, newValue, oldValue) {
        					function doLoad() {
        						this.setApiParam('limit', newValue);
            					this.loadFromApis();
							}
							if (oldValue !== null) {
								if (this.getTermsTimeout() !== null) {
									clearTimeout(this.getTermsTimeout());
								}
								if (numb.isValid()) {
									this.setTermsTimeout(setTimeout(doLoad.bind(this), 500));
								}
							}
        				},
        				scope: this
        			}
        		},{
        			xtype: 'container',
        			html: '<hr style="border: none; border-top: 1px solid #cfcfcf;"/>'
        		},{
        			xtype: 'label',
        			text: this.localize('output')
        		},{
            		text: this.localize('analysis'),
            		itemId: 'analysis',
            		glyph: 'xf1ec@FontAwesome',
                    overflowHandler: 'scroller',
        			menu: {
    					items: [
    					    {text: this.localize('pca'), itemId: 'analysis_pca', group:'analysis', xtype: 'menucheckitem'},
    					    {text: this.localize('ca'), itemId: 'analysis_ca', group:'analysis', xtype: 'menucheckitem'},
    					    {text: this.localize('tsne'), itemId: 'analysis_tsne', group:'analysis', xtype: 'menucheckitem'},
    					    {text: this.localize('docSim'), itemId: 'analysis_docSim', group:'analysis', xtype: 'menucheckitem'}
    					],
    					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var analysis = item.getItemId().split('_')[1];
    								if (analysis !== this.getApiParam('analysis')) {
    									this.doAnalysisChange(analysis);
    									this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    					}
        			}
	            },{
	            	fieldLabel: this.localize('perplexity'),
	            	itemId: 'perplexity',
	            	xtype: 'slider',
	            	minValue: 5,
	            	maxValue: 100,
	            	increment: 1,
	            	listeners: {
	            		changecomplete: function(slider, newValue) {
	            			this.setApiParam('perplexity', newValue);
	            			this.loadFromApis(true);
	            		},
	            		scope: this
	            	}
	            },{
	            	fieldLabel: this.localize('iterations'),
	            	itemId: 'iterations',
	            	xtype: 'slider',
	            	minValue: 100,
	            	maxValue: 5000,
	            	increment: 100,
	            	listeners: {
	            		changecomplete: function(slider, newValue) {
	            			this.setApiParam('iterations', newValue);
	            			this.loadFromApis(true);
	            		},
	            		scope: this
	            	}
	            },{
            		text: this.localize('clusters'),
            		itemId: 'clusters',
            		glyph: 'xf192@FontAwesome',
            		menu: {
            			items: [
            			    {text: '1', itemId: 'clusters_1', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '2', itemId: 'clusters_2', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '3', itemId: 'clusters_3', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '4', itemId: 'clusters_4', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '5', itemId: 'clusters_5', group: 'clusters', xtype: 'menucheckitem'}
            			],
    					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var clusters = parseInt(item.getItemId().split('_')[1]);
    								if (clusters !== this.getApiParam('clusters')) {
        								this.setApiParam('clusters', clusters);
        								this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    					}
            		}
            	},{
            		text: this.localize('dimensions'),
            		itemId: 'dimensions',
            		glyph: 'xf1b2@FontAwesome',
            		menu: {
            			items: [
            			    {text: '2', itemId: 'dimensions_2', group: 'dimensions', xtype: 'menucheckitem'},
            			    {text: '3', itemId: 'dimensions_3', group: 'dimensions', xtype: 'menucheckitem'}
            			],
    					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var dims = parseInt(item.getItemId().split('_')[1]);
    								if (dims !== this.getApiParam('dimensions')) {
        								if (dims == 3 && this.getApiParam('analysis') == 'ca' && this.getCorpus().getDocumentsCount() == 3) {
        									dims = 2;
        									// TODO add info message 'Because of the nature of Correspondence Analysis, you can only use 2 dimensions with 3 documents.'
        									return false;
        								}
        								
        								this.setApiParam('dimensions', dims);
        								this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    					}
            		}
        		},{
        			itemId: 'reloadButton',
        			text: this.localize('reload'),
        			glyph: 'xf021@FontAwesome',
        			handler: function() {
        				this.loadFromApis();
        			},
        			scope: this
        		}]
        	},{
        		itemId: 'termsGrid',
        		xtype: 'grid',
        		title: this.localize('terms'),
        		region: 'east',
        		width: 250,
        		split: true,
        		collapsible: true,
        		collapseMode: 'header',
        		forceFit: true,
        		features: [{
        			ftype: 'grouping',
        			hideGroupedHeader: true,
                    enableGroupingMenu: false
        		}],
        		bbar: {
                    overflowHandler: 'scroller',
        			items: [{
        				itemId: 'nearbyButton',
                        xtype: 'button',
                        text: this.localize('nearby'),
                        glyph: 'xf0b2@FontAwesome',
                        flex: 1,
                        handler: function(btn) {
                        	var sel = btn.up('panel').getSelection()[0];
                        	if (sel === undefined) {
                        		this.toastError({
                        			html: this.localize("noTermSelected"),
                        		     anchor: btn.up("panel").getTargetEl()
                        		 });
                        	}
                        	else {
	                        	var term = sel.get('term');
	                        	this.getNearbyForTerm(term);
                        	}
                        },
                        scope: this
                    },{
                    	itemId: 'removeButton',
                        xtype: 'button',
                        text: this.localize('remove'),
                        glyph: 'xf068@FontAwesome',
                        flex: 1,
                        handler: function(btn) {
                        	var sel = btn.up('panel').getSelection()[0];
                        	if (sel === undefined) {
                        		this.toastError({
                        			html: this.localize("noTermSelected"),
                        		     anchor: btn.up("panel").getTargetEl()
                        		 });
                        	}
                        	else {
	                        	var term = sel.get('term');
	                        	this.removeTerm(term);
                        	}
                        },
                        scope: this
                    }]
        			
        		},
        		tbar: {
                    overflowHandler: 'scroller',
                    items: [{
                    	xtype: 'querysearchfield',
                    	itemId: 'addTerms',
//                    	emptyText: this.localize('addTerm'),
                    	flex: 1
                    }]
                },
        		columns: [{
        			text: this.localize('term'),
    				dataIndex: 'term',
    				flex: 1,
                    sortable: true
    			},{
    				text: this.localize('rawFreq'),
    				dataIndex: 'rawFreq',
    				flex: 0.75,
    				minWidth: 70,
                    sortable: true
    			},{
    				text: this.localize('relFreq'),
    				dataIndex: 'relativeFreq',
    				flex: 0.75,
    				minWidth: 70,
                    sortable: true,
                    hidden: true
    			}],
    			selModel: {
    				type: 'rowmodel',
    				mode: 'SINGLE',
    				allowDeselect: true,
    				toggleOnClick: true,
                    listeners: {
                        selectionchange: {
                        	fn: function(sm, selections) {
//                        		this.getApplication().dispatchEvent('corpusTermsClicked', this, selections);
                        		var sel = selections[0];
                        		if (sel !== undefined) {
	                        		var term = sel.get('term');
	                        		var isDoc = sel.get('category') === 'document';
	                        		this.selectTerm(term, isDoc);
	                        		
	                        		if (isDoc) {
	                        			this.queryById('nearbyButton').disable();
	                        			this.queryById('removeButton').disable();
	                        		} else {
	                        			this.queryById('nearbyButton').enable();
	                        			this.queryById('removeButton').enable();
	                        		}
                        		} else {
                        			this.selectTerm();
                        		}
                        	},
                        	scope: this
                        }
                    }
                },
        		store: this.getTermStore(),
        		listeners: {
        			expand: function(panel) {
        				panel.getView().refresh();
        			},
        			query: function(component, value) {
        				if (value.length > 0 && this.getTermStore().findExact('term', value[0]) === -1) {
	                		this.setNewTerm(value);
	                		this.loadFromApis();
    					} else {
    						this.setNewTerm(null);
    					}
        			},
        			scope: this
        		}
        	}]
        });
        
        this.on('boxready', function(component, width, height) {
			if (width < 400) {
				this.queryById('optionsPanel').collapse();
				this.queryById('termsGrid').collapse();
			}
			if (this.config.storeClass && this.config.storeData) {
				this.loadStoreFromJson(this.config.storeClass, this.config.storeData);
			}
		}, this);
        
        this.on('beforedestroy', function(component) {
        	var oldChart = this.queryById('chart');
        	if (oldChart !== null) {
        		this.queryById('chartParent').remove(oldChart);
        	}
        }, this);
        
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		function setCheckItemFromApi(apiParamName) {
    			var value = this.getApiParam(apiParamName);
    			var menu = this.queryById(apiParamName);
    			var item = menu.down('#'+apiParamName+'_'+value);
    			item.setChecked(true);
    		}
    		var setCheckBound = setCheckItemFromApi.bind(this);
    		
    		setCheckBound('analysis');
    		this.doAnalysisChange(this.getApiParam('analysis'));
    		
    		setCheckBound('comparisonType');
    		setCheckBound('clusters');

    		this.queryById('perplexity').setValue(this.getApiParam('perplexity'));
    		this.queryById('iterations').setValue(this.getApiParam('iterations'));
    		
    		if (corpus.getDocumentsCount() == 3) {
    			this.setApiParam('dimensions', 2);
    		}
    		setCheckBound('dimensions');

    		this.getCaStore().setCorpus(corpus);
    		this.getPcaStore().setCorpus(corpus);
    		this.getDocSimStore().setCorpus(corpus);
    		this.loadFromApis();
    	}, this);
    	
    	this.on('documentsSelected', function(src, docIds) {
    		this.setApiParam('docId', docIds);
    		this.loadFromApis();
    	}, this);
        
    	this.callParent(arguments);
    },
    
    doAnalysisChange: function(analysis) {
    	this.setApiParam('analysis', analysis);
		this.queryById('nearbyButton').setDisabled(analysis === 'tsne');
		this.queryById('reloadButton').setVisible(analysis === 'tsne');
		this.queryById('perplexity').setVisible(analysis === 'tsne');
		this.queryById('iterations').setVisible(analysis === 'tsne');
		if (analysis === 'ca') {
			// TODO handling for when there's no corpus
			if (this.getCorpus().getDocumentsCount() == 3) {
				this.setApiParam('dimensions', 2);
				this.queryById('dimensions').menu.items.get(0).setChecked(true); // need 1-2 docs or 4+ docs for 3 dimensions
			}
		}
    },
    
    loadStoreFromJson: function(storeClass, storeData) {
		if (storeClass == 'Voyant.data.store.CAAnalysis') {
			this.getCaStore().loadRawData(storeData);
			this.doAnalysisChange('ca');
			this.maskAndBuildChart.call(this, this.getCaStore());
		} else if (storeClass == 'Voyant.data.store.PCAAnalysis') {
			this.getPcaStore().loadRawData(storeData);
			this.doAnalysisChange('pca');
			this.maskAndBuildChart.call(this, this.getPcaStore());
		} else if (storeClass == 'Voyant.data.store.TSNEAnalysis') {
			this.getTsneStore().loadRawData(storeData);
			this.doAnalysisChange('tsne');
			this.maskAndBuildChart.call(this, this.getTsneStore());
		} else if (storeClass == 'Voyant.data.store.DocSimAnalysis') {
			this.getDocSimStore().loadRawData(storeData);
			this.doAnalysisChange('docSim');
			this.maskAndBuildChart.call(this, this.getDocSimStore());
		}
    },
    
    maskAndBuildChart: function(store) {
    	this.queryById('chartParent').mask(this.localize('plotting'));
    	Ext.defer(this.buildChart, 50, this, [store]);
    },

    buildChart: function(store) {
    	var that = this; // needed for tooltip renderer
    	
    	var oldChart = this.queryById('chart');
    	if (oldChart !== null) {
    		this.queryById('chartParent').remove(oldChart);
    	}
    	
    	this.queryById('termsGrid').getSelectionModel().deselectAll();
    	
    	var rec = store.getAt(0);
        var numDims = this.getApiParam('dimensions');
        
    	var summary = '';    	
    	if (this.getApiParam('analysis') === 'pca') {
    		// calculate the percentage of original data represented by the dominant principal components
			var pcs = rec.getPrincipalComponents();
			var eigenTotal = 0;
			for (var i = 0; i < pcs.length; i++) {
				var pc = pcs[i];
				eigenTotal += parseFloat(pc.get('eigenValue'));
			}
			if (eigenTotal == 0) {
				// do nothing
			} else {
				summary = this.localize('pcTitle')+'\n';
				var pcMapping = ['xAxis', 'yAxis', 'fill'];
				for (var i = 0; i < pcs.length; i++) {
					if (i >= numDims) break;
					
					var eigenValue = pcs[i].get('eigenValue');
					var percentage = eigenValue / eigenTotal * 100;
					summary += this.localize('pc')+' '+(i+1)+' ('+this.localize(pcMapping[i])+'): '+Math.round(percentage*100)/100+'%\n';
				}
			}
    	} else if (this.getApiParam('analysis') === 'tsne') {
    		
    	} else {
    		summary = this.localize('caTitle')+'\n';
    		var pcMapping = ['xAxis', 'yAxis', 'fill'];
    		
    		var dimensions = rec.getDimensions();
    		for (var i = 0; i < dimensions.length; i++) {
    			if (i >= numDims) break;
    			
    			var percentage = dimensions[i].get('percentage');
    			summary += this.localize('dimension')+' '+(i+1)+' ('+this.localize(pcMapping[i])+'): '+Math.round(percentage*100)/100+'%\n';
    		}
    	}
        
        var maxFreq = 0;
        var minFreq = Number.MAX_VALUE;
        var maxFill = 0;
        var minFill = Number.MAX_VALUE;
        
        
        if (this.getApiParam('analysis') !== 'docSim') { // docSim doesn't return terms so keep the current ones
	        this.getTermStore().removeAll();
        }
	        
        var tokens = rec.getTokens();
        var termData = [];
        var docData = [];
        tokens.forEach(function(token) {
        	var freq = token.get('rawFreq');
        	var category = token.get('category');
        	if (category === undefined) {
        		category = 'term'; // some analyses don't define categories
        		token.set('category', 'term');
        	}
        	var isTerm = category === 'term';
        	if (isTerm) {
	        	if (freq > maxFreq) maxFreq = freq;
	        	if (freq < minFreq) minFreq = freq;
        	}
        	if (this.getTermStore().findExact('term', token.get('term') === -1)) {
        		this.getTermStore().addSorted(token);
        	}
        	if (numDims === 3) {
				var z = token.get('vector')[2];
				if (z !== undefined) {
					if (z < minFill) minFill = z;
					if (z > maxFill) maxFill = z;
				}
			}
        	var tokenData = {
        		x: token.get('vector')[0], y: token.get('vector')[1], z: token.get('vector')[2],
    			term: token.get('term'), rawFreq: freq, relativeFreq: token.get('relativeFreq'), cluster: token.get('cluster'), category: category,
    			disabled: false
        	};
        	if (!isTerm) {
        		if (token.get('category') === 'bin') {
        			tokenData.term = tokenData.title = "Bin "+token.get('docIndex');
        		} else {
	        		tokenData.docIndex = token.get('docIndex');
	        		var doc = this.getCorpus().getDocument(tokenData.docIndex);
	        		if (doc !== null) {
		        		tokenData.term = doc.getShortTitle();
		        		tokenData.title = doc.getTitle();
	        		}
        		}
        		docData.push(tokenData);
        	} else {
        		termData.push(tokenData);
        	}
        }, this);
        
        var newCount = this.getTermStore().getCount();
        this.queryById('limit').setRawValue(newCount);
        this.setApiParam('limit', newCount);
        
        
    	var termSeriesStore = Ext.create('Ext.data.JsonStore', {
    		fields: ['term', 'x', 'y', 'z', 'rawFreq', 'relativeFreq', 'cluster', 'category', 'docIndex', 'disabled'],
    		data: termData
    	});
    	var docSeriesStore = Ext.create('Ext.data.JsonStore', {
    		fields: ['term', 'x', 'y', 'z', 'rawFreq', 'relativeFreq', 'cluster', 'category', 'docIndex', 'disabled'],
    		data: docData
    	});
    	
    	var config = {
        	itemId: 'chart',
        	xtype: 'cartesian',
        	interactions: ['crosszoom','panzoom','itemhighlight'],
        	plugins: {
                ptype: 'chartitemevents'
            },
        	axes: [{
        		type: 'numeric',
        		position: 'bottom',
        		fields: ['x'],
        		label: {
                    rotate:{degrees:-30}
            	}
        	},{
        		type: 'numeric',
        		position: 'left',
        		fields: ['y']
        	}],
        	sprites: [{
        		type: 'text',
        		text: summary,
        		x: 70,
        		y: 70
        	}],
        	innerPadding: {top: 25, right: 25, bottom: 25, left: 25},
        	series: [{
        		type: 'customScatter',
        		xField: 'x',
        		yField: 'y',
        		store: termSeriesStore,
        		label: {
        			font: '14px Helvetica',
        			field: 'term',
        			display: 'over'
        		},
        		tooltip: {
        			trackMouse: true,
        			style: 'background: #fff',
        			renderer: function (toolTip, record, ctx) {
        				toolTip.setHtml(that.tokenFreqTipTemplate.apply([record.get('term'),record.get('rawFreq'),record.get('relativeFreq')]));
        			}
        		},
        		marker: {
        		    type: 'circle'
        		},
        		highlight: {
        			fillStyle: 'yellow',
                    strokeStyle: 'black'
        		},
        		renderer: function (sprite, config, rendererData, index) {
    				var store = rendererData.store;
    				var item = store.getAt(index);
    				if (item !== null) {
	    				var clusterIndex = item.get('cluster');
	    				var scatterplot = that;
	    				
	    				if (clusterIndex === -1) {
	    					// no clusters were specified in initial call
	    					clusterIndex = 0;
	    				}
	    				
	    				var fillAlpha = 0.65;
	    				var strokeAlpha = 1;
	    				if (item.get('disabled') === true) {
	    					fillAlpha = 0.1;
	    					strokeAlpha = 0.1;
	    				} else if (numDims === 3 && item.get('z')) {
	    					fillAlpha = scatterplot.interpolate(item.get('z'), minFill, maxFill, 0, 1);
	    				}
	    				var color = scatterplot.getApplication().getColor(clusterIndex);
	    				config.fillStyle = 'rgba('+color.join(',')+','+fillAlpha+')';
	    				config.strokeStyle = 'rgba('+color.join(',')+','+strokeAlpha+')';
	    				
	    				var freq = item.get('rawFreq');
	    				var radius = scatterplot.interpolate(freq, minFreq, maxFreq, 2, 20);
	    				config.radius = radius;
    				}
    			},
    			scope: this
        	},{
        		type: 'customScatter',
        		xField: 'x',
        		yField: 'y',
        		store: docSeriesStore,
        		label: {
        			font: '14px Helvetica',
        			field: 'term',
        			display: 'over',
        			color: this.getDefaultDocColor(true)
        		},
        		tooltip: {
        			trackMouse: true,
        			style: 'background: #fff',
        			renderer: function (toolTip, record, ctx) {
        				toolTip.setHtml(that.docFreqTipTemplate.apply([record.get('title'),record.get('rawFreq')]));
        			}
        		},
        		marker: {
        		    type: 'diamond'
        		},
        		highlight: {
        			fillStyle: 'yellow',
                    strokeStyle: 'black'
        		},
        		renderer: function (sprite, config, rendererData, index) {
    				var store = rendererData.store;
    				var item = store.getAt(index);
    				if (item !== null) {
	    				var clusterIndex = item.get('cluster');
	    				var scatterplot = that;
	    				
	    				var color;
	    				if (clusterIndex === -1 || scatterplot.getApiParam('analysis') !== 'docSim') {
	    					color = scatterplot.getDefaultDocColor();
	    				} else {
	    					color = scatterplot.getApplication().getColor(clusterIndex);	
	    				}
	    				
	    				var a = 0.65;
	    				if (numDims === 3 && item.get('z')) {
	    					a = scatterplot.interpolate(item.get('z'), minFill, maxFill, 0, 1);
	    				}
	    				
	    				config.fillStyle = 'rgba('+color.join(',')+','+a+')';
	    				config.strokeStyle = 'rgba('+color.join(',')+',1)';
	    				config.radius = 5;
    				}
    			},
    			scope: this
        		
        		
        	}],
        	listeners: {
        		itemclick: function(chart, item, event) {
        			var data = item.record.data;
        			if (data.category === 'doc') {
        				var record = this.getCorpus().getDocument(data.docIndex);
	            		this.getApplication().dispatchEvent('documentsClicked', this, [record]);
        			} else if (data.category === 'term') {
	        			var record = Ext.create('Voyant.data.model.CorpusTerm', data);
	            		this.getApplication().dispatchEvent('corpusTermsClicked', this, [record]);
        			}
        		},
        		render: function(chart) {
        			chart.body.on('contextmenu', function(event, target) {
	        			event.preventDefault();
	        			
		            	var xy = event.getXY();
		            	var parentXY = Ext.fly(target).getXY();
		            	var x = xy[0] - parentXY[0];
		            	var y = xy[1] - parentXY[1];
		            	var chartItem = this.down('#chart').getItemForPoint(x,y);
		            	if (chartItem != null && chartItem.record.get('category') === 'term') {
		            		var series = this.down('#chart').getSeries();
		            		series[0].disableToolTips();
		            		series[1].disableToolTips();
		            		
		            		var term = chartItem.record.get('term');
		            		
		            		var text = (new Ext.Template(this.localize('removeTerm'))).apply([term]);
		            		this.getChartMenu().queryById('remove').setText(text);
		            		text = (new Ext.Template(this.localize('nearbyTerm'))).apply([term]);
		            		var nearby = this.getChartMenu().queryById('nearby');
		            		nearby.setText(text);
		            		nearby.setDisabled(this.getApiParam('analysis') === 'tsne');
		            		
		            		this.getChartMenu().on('click', function(menu, item) {
		            			if (item !== undefined) {
		            				var term = chartItem.record.get('term');
			            			if (item.getItemId() === 'nearby') {
			            				this.getNearbyForTerm(term);
			            			} else {
			            				this.removeTerm(term);
			            			}
		            			}
		            		}, this, {single: true});
		            		this.getChartMenu().showAt(xy);
		            	}
		            }, this);
        		},
        		scope: this
        	}
        };
    	
    	var chart = Ext.create('Ext.chart.CartesianChart', config);
    	this.queryById('chartParent').insert(0, chart);
    	
    	this.queryById('chartParent').unmask();
    	
    	this.doLabels();
    	
    	if (this.getNewTerm() !== null) {
        	this.selectTerm(this.getNewTerm()[0]);
        	this.setNewTerm(null);
        }
    },
    
    getDefaultDocColor: function(returnHex) {
    	var color = this.getApplication().getColor(6, returnHex);
    	return color;
    },
    
    doLabels: function() {
    	var chart = this.queryById('chart');
    	var series = chart.getSeries();
    	var summary = chart.getSurface('chart').getItems()[0];
    	var labels = this.getApiParam("label");
    	if (labels.indexOf("summary")>-1) {summary.show();}
    	else {summary.hide();}
    	if (labels.indexOf("terms")>-1) {series[0].getLabel().show();}
    	else {series[0].getLabel().hide();}
    	if (labels.indexOf("docs")>-1) {series[1].getLabel().show();}
    	else {series[1].getLabel().hide();}
    },
    
    selectTerm: function(term, isDoc) {
    	var chart = this.down('#chart');
    	if (chart !== null) {
	    	if (term === undefined) {
				chart.getSeries()[0].setHighlightItem(null);
				chart.getSeries()[1].setHighlightItem(null);
	    	} else {
		    	var series, index;
		    	if (isDoc === true) {
		    		series = chart.getSeries()[1];
			    	index = series.getStore().findExact('title', term);
		    	} else {
			    	series = chart.getSeries()[0];
			    	index = series.getStore().findExact('term', term);
		    	}
		    	if (index !== -1) {
		    		var record = series.getStore().getAt(index);
		    		var sprite = series.getSprites()[0];
		    		// constructing series item, like in the chart series source
		    		var item = {
						series: series,
		                category: series.getItemInstancing() ? 'items' : 'markers',
		                index: index,
		                record: record,
		                field: series.getYField(),
		                sprite: sprite
		    		};
		    		series.setHighlightItem(item);
		    		if (isDoc) {
		    			chart.getSeries()[0].setHighlightItem(null);
		    		} else {
		    			chart.getSeries()[1].setHighlightItem(null);
		    		}
		    		
		    		var point = this.getPointFromIndex(series, index);
		    		this.setHighlightData({x: point[0], y: point[1], r: 50});
		    		
		    		if (this.getHighlightTask() == null) {
		    			this.setHighlightTask(Ext.TaskManager.newTask({
		        			run: this.doHighlight,
		        			scope: this,
		        			interval: 25,
		        			repeat: this.getHighlightData().r
		        		}));
		    		}
		    		this.getHighlightTask().restart();
		    	}
	    	}
    	}
    },
    
    getPointFromIndex: function(series, index) {
		var sprite = series.getSprites()[0];
		if (sprite.surfaceMatrix !== null) {
			var matrix = sprite.attr.matrix.clone().prependMatrix(sprite.surfaceMatrix);
			var dataX = sprite.attr.dataX[index];
			var dataY = sprite.attr.dataY[index];
			return matrix.transformPoint([dataX, dataY]);
		} else {
			return [0,0];
		}
    },
    
    doHighlight: function() {
    	var chart = this.down('#chart');
    	if (this.getHighlightData().r > 0) {
	    	var surf = chart.getSurface();
			var highlight = null;
			var items = surf.getItems();
			for (var i = 0; i < items.length; i++) {
				var item = items[i];
				if (item.id == 'customHighlight') {
					highlight = item;
					break;
				}
			}
			if (highlight == null) {
				surf.add({
					id: 'customHighlight',
					type: 'circle',
					strokeStyle: 'red',
					fillStyle: 'none',
					radius: this.getHighlightData().r,
					x: this.getHighlightData().x,
					y: this.getHighlightData().y
				});
			} else {
				highlight.setAttributes({
					x: this.getHighlightData().x,
					y: this.getHighlightData().y,
					radius: this.getHighlightData().r
				});
				this.getHighlightData().r -= 1.5;
				if (this.getHighlightData().r <= 0) {
					this.getHighlightData().r = 0;
					surf.remove(highlight, true);
				}
			}
			chart.redraw();
    	}
    },
    
    filterChart: function(query) {
    	if (Ext.isString(query)) query = [query];
    	var reQueries = [];
    	for (var i = 0; i < query.length; i++) {
    		var re = new RegExp(query[i]);
    		reQueries.push(re);
    	}
    	
    	// filter terms
    	var chart = this.queryById('chart');
    	var series0 = chart.getSeries()[0];
    	var label0 = series0.getLabel();
    	series0.getStore().each(function(item) {
    		var match = false;
    		if (reQueries.length == 0) match = true;
    		else {
	    		for (var i = 0; i < reQueries.length; i++) {
	    			match = match || reQueries[i].test(item.get('term'));
	    			if (match) break;
	    		}
    		}
    		item.set('disabled', !match);
    		var index = item.store.indexOf(item);
    		label0.setAttributesFor(index, {hidden: !match});
    	}, this);

		chart.redraw();
    },
    
    getCurrentTerms: function() {
    	var terms = [];
    	this.getTermStore().each(function(r) {
    		if (r.get('category') === 'term') {
    			terms.push(r.get('term'));
    		}
    	});
    	return terms;
    },
    
    getNearbyForTerm: function(term) {
    	var limit = Math.max(2000, Math.round(this.getCorpus().getWordTokensCount() / 100));
		this.setApiParams({limit: limit, target: term});
		this.loadFromApis();
		this.setApiParam('target', undefined);
    },
    
    removeTerm: function(term) {
    	var series = this.down('#chart').getSeries()[0];
    	var index = series.getStore().findExact('term', term);
    	series.getStore().removeAt(index);
    	
    	index = this.getTermStore().findExact('term', term);
    	this.getTermStore().removeAt(index);
    	
    	var newCount = this.getTermStore().getCount();
        this.queryById('limit').setRawValue(newCount);
    },
    
    loadFromApis: function(keepCurrentTerms) {
    	this.queryById('chartParent').mask(this.localize('analyzing'));
    	
    	var params = {};
    	var terms = this.getCurrentTerms();
    	if (this.getNewTerm() !== null) {
    		terms = terms.concat(this.getNewTerm());
    		this.setApiParam('limit', terms.length);
    	}
    	if (terms.length > 0) {
    		if (this.getNewTerm() !== null || keepCurrentTerms) {
    			params.query = terms.join(',');
    		}
//    		params.term = terms;
    	}
    	Ext.apply(params, this.getApiParams());
    	if (params.target != null) {
    		params.term = terms;
    	}
    	if (params.analysis === 'pca') {
    		this.getPcaStore().load({
	    		params: params
	    	});
    	} else if (params.analysis === 'tsne'){
    		this.getTsneStore().load({
	    		params: params
	    	});
    	} else if (params.analysis === 'docSim'){
    		this.getDocSimStore().load({
	    		params: params
	    	});
    	} else {
    		this.getCaStore().load({
	    		params: params
	    	});
    	}
    },
    
    interpolate: function(lambda, minSrc, maxSrc, minDst, maxDst) {
        return minDst + (maxDst - minDst) * Math.max(0, Math.min(1, (lambda - minSrc) / (maxSrc - minSrc)));
    }
});

/*
 * Adds tool tip disabling.
 */
Ext.define('Ext.chart.series.CustomScatter', {
	extend: 'Ext.chart.series.Scatter',
	
	alias: 'series.customScatter',
    type: 'customScatter',
    seriesType: 'scatterSeries',
	
	tipsDisabled: false,
	
	enableToolTips: function() {
		this.tipsDisabled = false;
	},
	
	disableToolTips: function() {
		this.tipsDisabled = true;
	},
	
    showTip: function (item, xy) {
    	if (this.tipsDisabled) {
    		return;
    	}
    	
    	this.callParent(arguments);
    }
});
Ext.define('Voyant.panel.StreamGraph', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.streamgraph',
    statics: {
    	i18n: {
    	},
    	api: {
    		limit: 5,
    		stopList: 'auto',
    		query: undefined,
    		withDistributions: 'relative',
    		bins: 50,
    		docIndex: undefined,
    		docId: undefined
    	},
		glyph: 'xf1fe@FontAwesome'
    },
    
    config: {
    	visLayout: undefined,
    	vis: undefined,
    	mode: 'corpus',
    	
    	layerData: undefined,
    	
    	graphId: undefined
    },
    
    graphMargin: {top: 20, right: 60, bottom: 110, left: 80},
    
    MODE_CORPUS: 'corpus',
    MODE_DOCUMENT: 'document',
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.setGraphId(Ext.id(null, 'streamgraph_'));
    },
    
    initComponent: function() {
        var me = this;
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		tbar: new Ext.Toolbar({
                overflowHandler: 'scroller',
				items: ['->',{
					xtype: 'legend',
					store: new Ext.data.JsonStore({
						fields: ['name', 'mark', 'active']
					}),
					listeners: {
						itemclick: function(view, record, el, index) {
							var isActive = Ext.fly(el.firstElementChild).hasCls('x-legend-inactive');
							record.set('active', isActive);
							var terms = this.getCurrentTerms();
							this.setApiParams({query: terms, limit: terms.length, stopList: undefined});
							this.loadFromCorpus();
						},
						scope: this
					}
				},'->']
			}),
			bbar: {
                overflowHandler: 'scroller',
				items: [{
                	xtype: 'querysearchfield'
                },{
	            	xtype: 'button',
	            	text: this.localize('clearTerms'),
	            	handler: function() {
	            		this.setApiParams({query: undefined});
	            		this.loadFromRecords([]);
	            	},
	            	scope: this
	            },{
	            	xtype: 'corpusdocumentselector',
	            	singleSelect: true
	            },{
	            	text: this.localize('freqsMode'),
					glyph: 'xf201@FontAwesome',
				    tooltip: this.localize('freqsModeTip'),
				    menu: {
				    	items: [{
				               text: this.localize('relativeFrequencies'),
				               checked: true,
				               itemId: 'relative',
				               group: 'freqsMode',
				               checkHandler: function(item, checked) {
				            	   if (checked) {
				                	   this.setApiParam('withDistributions', 'relative');
				                	   this.loadFromCorpus();
				            	   }
				               },
				               scope: this
				           }, {
				               text: this.localize('rawFrequencies'),
				               checked: false,
				               itemId: 'raw',
				               group: 'freqsMode',
				               checkHandler: function(item, checked) {
				            	   if (checked) {
				                	   this.setApiParam('withDistributions', 'raw');
				                	   this.loadFromCorpus();
				            	   }
				               },
				               scope: this
			           }]
				    }
	            },{
	            	xtype: 'slider',
	            	itemId: 'segmentsSlider',
	            	fieldLabel: this.localize('segments'),
	            	labelAlign: 'right',
	            	labelWidth: 70,
	            	width: 150,
	            	increment: 10,
	            	minValue: 10,
	            	maxValue: 300,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam('bins'));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({bins: newvalue});
	            			this.loadFromCorpus();
	            		},
	            		scope: this
	            	}
	            }]
			}
        });
        
        this.on('loadedCorpus', function(src, corpus) {
        	if (this.getCorpus().getDocumentsCount() == 1 && this.getMode() != this.MODE_DOCUMENT) {
				this.setMode(this.MODE_DOCUMENT);
			}
			if (!('bins' in this.getModifiedApiParams())) {
				if (this.getMode() == this.MODE_CORPUS) {
					var count = corpus.getDocumentsCount();
					var binsMax = 100;
					this.setApiParam('bins', count > binsMax ? binsMax : count);
				}
			}
    		if (this.isVisible()) {
    			this.loadFromCorpus();
    		}
        }, this);
        
        this.on('corpusSelected', function(src, corpus) {
    		if (src.isXType('corpusdocumentselector')) {
    			this.setMode(this.MODE_CORPUS);
    			this.setApiParams({docId: undefined, docIndex: undefined});
    			this.setCorpus(corpus);
        		this.loadFromCorpus();
    		}
    	});
        
        this.on('documentSelected', function(src, doc) {
        	var docId = doc.getId();
        	this.setApiParam('docId', docId);
        	this.loadFromDocumentTerms();
        }, this);
        
		this.on('query', function(src, query) {
        	var terms = this.getCurrentTerms();
        	terms.push(query);
        	this.setApiParams({query: terms, limit: terms.length, stopList: undefined});
        	if (this.getMode() === this.MODE_DOCUMENT) {
        		this.loadFromDocumentTerms();
        	} else {
        		this.loadFromCorpusTerms(this.getCorpus().getCorpusTerms());
        	}
        }, this);
		
        this.on('resize', this.resizeGraph, this);
        
        this.on('boxready', this.initGraph, this);
        
        me.callParent(arguments);
    },
    
    loadFromCorpus: function() {
    	var corpus = this.getCorpus();
		if (this.getApiParam('docId') || this.getApiParam('docIndex')) {
			this.loadFromDocumentTerms();
		} else if (corpus.getDocumentsCount() == 1) {
			this.loadFromDocument(corpus.getDocument(0));
		} else {
			this.loadFromCorpusTerms(corpus.getCorpusTerms());
		}
	},

    loadFromCorpusTerms: function(corpusTerms) {
    	var params = this.getApiParams(['limit','stopList','query','withDistributions','bins']);
		// ensure that we're not beyond the number of documents
		if (params.bins && params.bins > this.getCorpus().getDocumentsCount()) {
			params.bins = this.getCorpus().getDocumentsCount();
		}
		corpusTerms.load({
		    callback: function(records, operation, success) {
		    	if (success) {
		    		this.setMode(this.MODE_CORPUS);
			    	this.loadFromRecords(records);
		    	} else {
					Voyant.application.showResponseError(this.localize('failedGetCorpusTerms'), operation);
		    	}
		    },
		    scope: this,
		    params: params
    	});
    },
    
    loadFromDocument: function(document) {
    	if (document.then) {
    		var me = this;
    		document.then(function(document) {me.loadFromDocument(document);});
    	} else {
    		var ids = [];
    		if (Ext.getClassName(document)=="Voyant.data.model.Document") {
        		this.setApiParams({
        			docIndex: undefined,
        			query: undefined,
        			docId: document.getId()
        		});
        		if (this.isVisible()) {
                	this.loadFromDocumentTerms();
        		}
    		}
    	}
    },
    
    loadFromDocumentTerms: function(documentTerms) {
    	if (this.getCorpus()) {
        	documentTerms = documentTerms || this.getCorpus().getDocumentTerms({autoLoad: false});
    		documentTerms.load({
    		    callback: function(records, operation, success) {
    		    	if (success) {
    		    		this.setMode(this.MODE_DOCUMENT);
    		    		this.loadFromRecords(records);
    		    	}
    		    	else {
    					Voyant.application.showResponseError(this.localize('failedGetDocumentTerms'), operation);
    		    	}
    		    },
    		    scope: this,
    		    params: this.getApiParams(['docId','docIndex','limit','stopList','query','withDistributions','bins'])
        	});
    	}
    },
    
    loadFromRecords: function(records) {
    	var legendData = [];
    	var layers = [];
    	records.forEach(function(record, index) {
    		var key = record.getTerm();
    		var values = record.get('distributions');
    		for (var i = 0; i < values.length; i++) {
    			if (layers[i] === undefined) {
    				layers[i] = {};
    			}
    			layers[i][key] = values[i];
    		}
    		legendData.push({id: key, name: key, mark: this.getApplication().getColorForTerm(key, true), active: true});
    	}, this);
    	
    	this.setLayerData(layers);
    	
    	this.down('[xtype=legend]').getStore().loadData(legendData);

    	this.doLayout();
    },
    
    doLayout: function(layers) {
    	var layers = this.getLayerData();
    	if (layers !== undefined) {
    		var me = this;
    		
	    	var keys = [];
	    	this.down('[xtype=legend]').getStore().each(function(r) { keys.push(r.getId()); });
	    	
	    	var steps;
	    	if (this.getMode() === this.MODE_DOCUMENT) {
	    		steps = this.getApiParam('bins');
	    	} else {
	    		var bins = this.getApiParam('bins');
	    		var docsCount = this.getCorpus().getDocumentsCount();
	    		
	    		steps = bins < docsCount ? bins : docsCount;
	    	}
	    	
	    	this.getVisLayout().keys(keys);
	    	var processedLayers = this.getVisLayout()(layers);
	    	
	    	var width = this.body.down('svg').getWidth() - this.graphMargin.left - this.graphMargin.right;
	    	var x = d3.scaleLinear().domain([0, steps-1]).range([0, width]);
	    	
	    	var min = d3.min(processedLayers, function(layer) {
	    		return d3.min(layer, function(d) { return d[0]; });
	    	});
	    	var max = d3.max(processedLayers, function(layer) {
	    		return d3.max(layer, function(d) { return d[1]; });
	    	});
	    	
	    	var height = this.body.down('svg').getHeight() - this.graphMargin.top - this.graphMargin.bottom;
	    	var y = d3.scaleLinear().domain([min, max]).range([height, 0]);
	    	
	    	var area = d3.area()
		    	.x(function(d, i) { return x(i); })
			    .y0(function(d) { return y(d[0]); })
			    .y1(function(d) { return y(d[1]); })
			    .curve(d3.curveCatmullRom);
	    	
	    	var xAxis;
	    	if (this.getMode() === this.MODE_CORPUS) {
	    		var xAxisDomain = [];
	    		this.getCorpus().getDocuments().each(function(doc) {
	    			xAxisDomain.push(doc.getTinyLabel());
	    		});
	    		var xAxisScale = d3.scalePoint().domain(xAxisDomain).range([0, width]);    		
	    		xAxis = d3.axisBottom(xAxisScale);
	    	} else {
	    		xAxis = d3.axisBottom(x);
	    	}
	    	
	    	var yAxis = d3.axisLeft(y);
	    	
	    	var paths = this.getVis().selectAll('path').data(processedLayers, function(d) { return d; });
	    	
	    	paths
	    		.attr('d', function(d) { return area(d); })
		    	.style('fill', function(d) { return me.getApplication().getColorForTerm(d.key, true); })
				.select('title').text(function (d) { return d.key; });
	    	
	    	paths.enter().append('path')
				.attr('d', function(d) { return area(d); })
				.style('fill', function(d) { return me.getApplication().getColorForTerm(d.key, true); })
				.append('title').text(function (d) { return d.key; });
	    	
	    	paths.exit().remove();
	    	
	    	this.getVis().selectAll('g.axis').remove();
	    	
	    	this.getVis().append('g')
	    		.attr('class', 'axis x')
	    		.attr('transform', 'translate(0,'+height+')')
	    		.call(xAxis);
	    	
	    	var xAxisText;
	    	if (this.getMode() === this.MODE_CORPUS) {
	    		this.getVis().select('g.axis.x').selectAll('text').each(function() {
					d3.select(this)
						.attr('text-anchor', 'end')
						.attr('transform', 'rotate(-45)');
	    		});
	    		
	    		xAxisText = this.localize('documents');
	    	} else {
	    		xAxisText = this.localize('documentSegments');
	    	}
	    	this.getVis().select('g.axis.x').append("text")
				.attr('text-anchor', 'middle')
				.attr('transform', 'translate('+width/2+', '+(this.graphMargin.bottom-30)+')')
				.attr('fill', '#000')
				.text(xAxisText);
	    	
	    	this.getVis().append('g')
				.attr('class', 'axis y')
				.attr('transform', 'translate(0,0)')
				.call(yAxis);
	    	
	    	var yAxisText;
	    	if (this.getApiParam('withDistributions') === 'raw') {
	    		yAxisText = this.localize('rawFrequencies');
	    	} else {
	    		yAxisText = this.localize('relativeFrequencies');
	    	}
	    	this.getVis().select('g.axis.y').append("text")
				.attr('text-anchor', 'middle')
				.attr('transform', 'translate(-'+(this.graphMargin.left-20)+', '+height/2+') rotate(-90)')
				.attr('fill', '#000')
				.text(yAxisText);
    	}
    },
    
	getCurrentTerms: function() {
    	var terms = [];
    	this.down('[xtype=legend]').getStore().each(function(record) {
    		if (record.get('active')) {
    			terms.push(record.get('name'));
    		}
    	}, this);
    	return terms;
    },
	
    initGraph: function() {
    	if (this.getVisLayout() === undefined) {
	    	var el = this.getLayout().getRenderTarget();
	    	
	    	this.setVisLayout(d3.stack().offset(d3.stackOffsetWiggle).order(d3.stackOrderInsideOut));
			this.setVis(d3.select(el.dom).append('svg').attr('id',this.getGraphId()).append('g').attr('transform', 'translate('+this.graphMargin.left+','+this.graphMargin.top+')'));
			
			this.resizeGraph();
    	}
    },
    
    resizeGraph: function() {
    	var el = this.body;//getLayout().getRenderTarget();
    	var width = el.getWidth();
		var height = el.getHeight();
		
		d3.select(el.dom).select('svg').attr('width', width).attr('height', height);
		
		this.doLayout();
    }
});


/**
 * The Summary panel provides an overview of a corpus, and the content will
 * depend on whether the corpus includes one document or many.
 */
Ext.define('Voyant.panel.Summary', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.summary',
    statics: {
    	i18n: {
    	},
    	api: {
    		
    		/**
    		 * @cfg {String} stopList A list of words to exclude.
    		 * 
    		 * Stopword lists can take one of several forms and they can be combined with commas:
    		 * 
    		 * * *auto*: automatically detect the language (this is recommended and the default so it doesn't need to be specified)
    		 * * specially named stopword lists including stop.ar.arabic-lucene.txt, stop.bg.bulgarian-lucene.txt, stop.br.breton-lucene.txt, stop.ca.catalan-lucene.txt, stop.ckb.kurdish-lucene.txt, stop.cn.chinese-lawrence.txt, stop.cz.czech-lucene.txt, stop.de.citelab.txt, stop.de.german.txt, stop.el.greek-lucene.txt, stop.en.glasgow.txt, stop.en.smart.txt, stop.en.taporware.txt, stop.es.spanish.txt, stop.eu.basque-luence.txt, stop.fa.farsi-lucene.txt, stop.fr.steffens.txt, stop.fr.veronis.txt, stop.ga.ga-irish.txt, stop.gl.galician-lucene.txt, stop.hi.hindi-lucene.txt, stop.hu.hungarian.txt, stop.hy.armenian-lucene.txt, stop.id.indonesian-lucene.txt, stop.it.italian.txt, stop.ja.japanese.txt, stop.lt.lithuanian-lucene.txt, stop.lv.latvian-lucene.txt, stop.mu.multi.txt, stop.nl.dutch.txt, stop.no.norwegian.txt, stop.ro.romanian-lucene.txt, stop.se.swedish-long.txt, stop.se.swedish-short.txt, stop.th.thai-lucene.txt, stop.tr.turkish-lucene.txt
    		 * * individual words to be excluded
    		 * * URLs that point to plain text UTF-8 files with one stopword per line (lines with leading hash symbols (#) are skipped)
    		 */
    		stopList: 'auto',
    		
    		
    		start: 0,
    		
    		
    		/**
    		 * @cfg {Number} limit The number of items to include in most lists (document length, vocabulary density, most frequent terms).
    		 */
    		limit: 5,
    		
    		/**
    		 * @cfg {Number} numberOfDocumentsForDistinctiveWords The number of items to include in the list of distinctive words (similar to the limit parameter but specific to distinctive words).
    		 */
    		numberOfDocumentsForDistinctiveWords: 10
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	options: {xtype: 'stoplistoption'}
    },
    autoScroll: true,
    cls: 'corpus-summary',
    
    constructor: function(config ) {

    	Ext.apply(this, {
    		title: this.localize('title'),
    		items: {
    			itemId: 'main',
    			cls: 'main',
    			margin: 10
    		},
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			fieldLabel: this.localize('items'),
        			labelWidth: 40,
        			width: 120,
        			xtype: 'slider',
	            	increment: 5,
	            	minValue: 5,
	            	maxValue: 59,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam("limit"))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			this.loadSummary();
	            		},
	            		scope: this
	            	}
                }]
    		}]
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on("afterrender", function() {
        	this.body.addListener('click', function(e) {
    			var target = e.getTarget(null, null, true);
    			if (target && target.dom.tagName == 'A') {
    				if (target.hasCls('document-id')) {
    					var docId = target.getAttribute('val', 'voyant');
    					var doc = this.getCorpus().getDocuments().getById(docId);
    					this.dispatchEvent('documentsClicked', this, [doc]);
    				} else if (target.hasCls('corpus-type')) {
    					this.dispatchEvent('termsClicked', this, [target.getHtml()]);
    				} else if (target.hasCls('document-type')) {
    					this.dispatchEvent('documentIndexTermsClicked', this, [{
    						term: target.getHtml(),
    						docIndex: target.getAttribute("docIndex", 'voyant')
    					}]);
    				}
    			}
    		}, this);
    	})
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.rendered) {
    			this.loadSummary();
    		}
    		else {
    			this.on("afterrender", function() {
    				this.loadSummary();
    			}, this)
    		}

    	});
    	
    	// if we have a corpus, load it
    	if (config && config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus);
    	}
    	
    	this.on("resize", function() {
    		var available = this.getWidth()-200;
    		this.query("sparklineline").forEach(function(spark) {
    			if (spark.getWidth()>available) {
    				spark.setWidth(available);
    			}
    		})
    	}, this)
    },
    
    loadSummary: function() {
    	
    	var me = this;
    	
    	var main = this.queryById('main');
    	
    	main.removeAll();
    	main.add({
    		html: this.getCorpus().getString()
    	});
    	
    	var docs = this.getCorpus().getDocuments().getRange();
    	var limit = this.getApiParam('limit');
    	
    	if (docs.length>1) {
    		
    		docs.sort(function(d1, d2) {return d2.getLexicalTokensCount()-d1.getLexicalTokensCount()});
        	var docsLengthTpl = new Ext.XTemplate('<tpl for="." between="; "><a href="#" onclick="return false" class="document-id" voyant:val="{id}" data-qtip="{title}">{shortTitle}</a><span style="font-size: smaller"> (<span class="info-tip" data-qtip="{valTip}">{val}</span>)</span></a></tpl>')

        	
        	var sparkWidth;
        	if (docs.length<25) {sparkWidth=docs.length*4;}
        	else if (docs.length<50) {sparkWidth=docs.length*2;}
        	else if (docs.length>100) {
        		var available  = main.getWidth()-200;
        		sparkWidth = available < docs.length ? docs.length : available;
        	}
        	
        	var numberOfTerms = this.localize('numberOfTerms');
        	main.add({
	    		cls: 'section',
        		items: [{
		    		layout: 'hbox',
		    		align: 'bottom',
		    		items: [{
		    			html: this.localize('docsLength'),
		    			cls: 'header'
		    		}, {
		    			xtype: 'sparklineline',
		    			values: this.getCorpus().getDocuments().getRange().map(function(doc) {return doc.getLexicalTokensCount()}),
		                tipTpl: new Ext.XTemplate('{[this.getDocumentTitle(values.x,values.y)]}', {
		                	getDocumentTitle: function(docIndex, len) {
		                		return '('+len+') '+this.panel.getCorpus().getDocument(docIndex).getTitle()
		                	},
		                	panel: me 
		                }),
		    			height: 16,
		    			width: sparkWidth
		    		}]
		    	},{
	    			html: '<ul><li>'+this.localize('longest')+" "+docsLengthTpl.apply(docs.slice(0, docs.length>limit ? limit : parseInt(docs.length/2)).map(function(doc) {return {
						id: doc.getId(),
						shortTitle: doc.getShortTitle(),
						title: doc.getTitle(),
						val: doc.getLexicalTokensCount(),
						valTip: numberOfTerms
					}}))+'</li>'+
	    				'<li>'+this.localize('shortest')+" "+docsLengthTpl.apply(docs.slice(-(docs.length>limit ? limit : parseInt(docs.length/2))).reverse().map(function(doc) {return {
	    					id: doc.getId(),
	    					shortTitle: doc.getShortTitle(),
	    					title: doc.getTitle(),
	    					val: doc.getLexicalTokensCount(),
	    					valTip: numberOfTerms
	    				}}))+'</li>'
	        	}]
        	})
        	
    		docs.sort(function(d1, d2) {return d2.getLexicalTypeTokenRatio()-d1.getLexicalTypeTokenRatio()});
        	main.add({
        		cls: 'section',
        		items: [{
		    		layout: 'hbox',
		    		align: 'bottom',
		    		cls: 'section',
		    		items: [{
		    			html: this.localize("docsDensity"),
		    			cls: 'header'
		    		}, {
		    			xtype: 'sparklineline',
		    			values: this.getCorpus().getDocuments().getRange().map(function(doc) {return Ext.util.Format.number(doc.getLexicalTypeTokenRatio(),'0.000')}),
		                tipTpl: new Ext.XTemplate('{[this.getDocumentTitle(values.x,values.y)]}', {
		                	getDocumentTitle: function(docIndex, len) {
		                		return '('+len+') '+this.panel.getCorpus().getDocument(docIndex).getTitle()
		                	},
		                	panel: me 
		                }),
		    			height: 16,
		    			width: sparkWidth
		    		}]
		    	},{
	    			html: '<ul><li>'+this.localize('highest')+docsLengthTpl.apply(docs.slice(0, docs.length>limit ? limit : parseInt(docs.length/2)).map(function(doc) {return {
						id: doc.getId(),
						shortTitle: doc.getShortTitle(),
						title: doc.getTitle(),
						val: Ext.util.Format.number(doc.getLexicalTypeTokenRatio(),'0.000'),
						valTip: numberOfTerms
					}}))+'</li>'+
	    				'<li>'+this.localize('lowest')+docsLengthTpl.apply(docs.slice(-(docs.length>limit ? limit : parseInt(docs.length/2))).reverse().map(function(doc) {return {
	    					id: doc.getId(),
	    					shortTitle: doc.getShortTitle(),
	    					title: doc.getTitle(),
	    					val: Ext.util.Format.number(doc.getLexicalTypeTokenRatio(),'0.000'),
	    					valTip: numberOfTerms
	    				}}))+'</li>'
	        	}]
        	})
 
        	// words per sentence
    		docs.sort(function(d1, d2) {return d2.getAverageWordsPerSentence()-d1.getAverageWordsPerSentence()});
        	main.add({
        		cls: 'section',
        		items: [{
		    		layout: 'hbox',
		    		align: 'bottom',
		    		cls: 'section',
		    		items: [{
		    			html: this.localize("averageWordsPerSentence"),
		    			cls: 'header'
		    		}, {
		    			xtype: 'sparklineline',
		    			values: this.getCorpus().getDocuments().getRange().map(function(doc) {return Ext.util.Format.number(doc.getAverageWordsPerSentence(),'0.0')}),
		                tipTpl: new Ext.XTemplate('{[this.getDocumentTitle(values.x,values.y)]}', {
		                	getDocumentTitle: function(docIndex, len) {
		                		return '('+len+') '+this.panel.getCorpus().getDocument(docIndex).getTitle()
		                	},
		                	panel: me 
		                }),
		    			height: 16,
		    			width: sparkWidth
		    		}]
		    	},{
	    			html: '<ul><li>'+this.localize('highest')+docsLengthTpl.apply(docs.slice(0, docs.length>limit ? limit : parseInt(docs.length/2)).map(function(doc) {return {
						id: doc.getId(),
						shortTitle: doc.getShortTitle(),
						title: doc.getTitle(),
						val: Ext.util.Format.number(doc.getAverageWordsPerSentence(),'0.0'),
						valTip: numberOfTerms
					}}))+'</li>'+
	    				'<li>'+this.localize('lowest')+docsLengthTpl.apply(docs.slice(-(docs.length>limit ? limit : parseInt(docs.length/2))).reverse().map(function(doc) {return {
	    					id: doc.getId(),
	    					shortTitle: doc.getShortTitle(),
	    					title: doc.getTitle(),
	    					val: Ext.util.Format.number(doc.getAverageWordsPerSentence(),'0.0'),
	    					valTip: numberOfTerms
	    				}}))+'</li>'
	        	}]
        	})        	
    	} else { // single document, we can still show word density and average words per sentence
    		var doc = docs[0];
    		if (doc) {
            	main.add({
            		cls: 'section',
            		html:"<b>"+this.localize("docsDensity")+"</b> "+Ext.util.Format.number(doc.getLexicalTypeTokenRatio(),'0.000')
            	});    		
            	main.add({
            		cls: 'section',
            		html: "<b>"+this.localize("averageWordsPerSentence")+"</b> "+Ext.util.Format.number(doc.getAverageWordsPerSentence(),'0.0')
            	});    		
    		}
    	}
    	
    	main.add({
    		html: this.localize("mostFrequentWords"),
    		cls: 'section',
    		listeners: {
    			afterrender: function(container) {
    				container.mask(me.localize("loading"));
    				me.getCorpus().getCorpusTerms().load({
    					params: {
    						limit: me.getApiParam('limit'),
    						stopList: me.getApiParam('stopList'),
    						forTool: 'summary'
    					},
    					callback: function(records, operation, success) {
    						if (success && records && records.length>0) {
    							container.unmask();
    							Ext.dom.Helper.append(container.getTargetEl().first().first(),
			   	        			 new Ext.XTemplate('<tpl for="." between="; "><a href="#" onclick="return false" class="corpus-type keyword" voyant:recordId="{id}">{term}</a><span style="font-size: smaller"> ({val})</span></tpl>')
			   	        		 		.apply(records.map(function(term) {
			   	        		 			return {
				   	        		 			id: term.getId(),
				   	        		 			term: term.getTerm(),
				   	        		 			val: term.getRawFreq()
			   	        		 			}
		   	        		 		}))
		   	        		 	)
    						}
    					}
    				})
    			}
    		},
    		scope: this
    	})
    	
    	if (docs.length>1) {
        	main.add({
        		html: this.localize("distinctiveWords")+"<ol></ol>",
        		cls: 'section',
        		itemId: 'distinctiveWords',
        		listeners: {
        			afterrender: function(container) {
        				me.showMoreDistinctiveWords();
        			}
        		},
        		scope: this
        	})
    	}
    	
    },
     
    showMoreDistinctiveWords: function() {
    	var distinctiveWordsContainer = this.queryById('distinctiveWords');
    	var list = distinctiveWordsContainer.getTargetEl().selectNode("ol");
    	var count = Ext.dom.Query.select("li:not(.more)", list).length;
    	var numberOfDocumentsForDistinctiveWords = parseInt(this.getApiParam('numberOfDocumentsForDistinctiveWords'));
    	var range = this.getCorpus().getDocuments().getRange(count, count+numberOfDocumentsForDistinctiveWords-1);
    	if (range && Ext.isArray(range)) {
    		var docIndex = [];
    		range.forEach(function(doc) {
    			docIndex.push(doc.getIndex())
    		})
    		if (docIndex.length>0) {
    			this.getCorpus().getDocumentTerms().load({
    				addRecords: true,
    				params: {
    					docIndex: docIndex,
    					perDocLimit: parseInt(this.getApiParam("limit")),
    					limit: numberOfDocumentsForDistinctiveWords*parseInt(this.getApiParam("limit")),
						stopList: this.getApiParam('stopList'),
    					sort: 'TFIDF',
    					dir: 'DESC',
    					forTool: 'summary'
    				},
    				scope: this,
    				callback: function(records, operation, success) {
    					var docs = {};
    					if (success && records && Ext.isArray(records)) { // TODO: why wouldn't we have records here?
    						records.forEach(function(r, index, array) {
    							var i = r.getDocIndex();
    							if (!(i in docs)) {docs[i]=[]};
    							docs[i].push({
    								id: r.getId(),
    								docIndex: r.getDocIndex(),
    								type: r.getTerm(),
    								val: Ext.util.Format.number(r.get('rawFreq'),'0,000'),
    								docId: r.get('docId')
    							});

    						});
    						var len;
    						docIndex.forEach(function(index) {
    							if (docs[index]) {
        							var doc = this.getCorpus().getDocument(index);
        							len = docs[index].length; // declare for template
        		    				Ext.dom.Helper.append(list, {tag: 'li', 'voyant:index': String(index), html: 
        		    					'<a href="#" onclick="return false" class="document-id document-id-distinctive" voyant:val="'+doc.get('id')+'">'+doc.getShortTitle()+'</a>'+
        		    					this.localize('colon')+ " "+new Ext.XTemplate(this.localize('documentType')).apply({types: docs[index]})+'.'
        		    				});
    							}
    						}, this);
    						distinctiveWordsContainer.updateLayout()
    						len = numberOfDocumentsForDistinctiveWords;
    						remaining = this.getCorpus().getDocuments().getTotalCount() - count - docIndex.length;
    						if (remaining>0) {
        	    				var tpl = new Ext.Template(this.localize('moreDistinctiveWords'));
        						var more = Ext.dom.Helper.append(list, {tag: 'li', cls: 'more', html: tpl.apply([len>remaining ? remaining : len,remaining])}, true);
        						more.on("click", function() {
        							more.remove();
        							this.showMoreDistinctiveWords();
        						}, this)
    						}
    					}
    				}
    			});
    		}
    	}
    }    
});

Ext.define('Voyant.panel.TextualArc', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.textualarc',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		docIndex: 0,
    		
    		speed: 50,
    		
    		minRawFreq: 2
    			
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
    	options: [{xtype: 'stoplistoption'},{
    		xtype: 'container',
    		items: {
    			xtype: 'numberfield',
	    		name: 'minRawFreq',
	    		minValue: 1,
	    		maxValue: 10,
	    		value: 2,
	    		labelWidth: 150,
	    		labelAlign: 'right',
	    		initComponent: function() {
	    			var panel = this.up('window').panel;
	    			this.fieldLabel = panel.localize(this.fieldLabel);
	    			this.on("afterrender", function(cmp) {
			        	Ext.tip.QuickTipManager.register({
			                 target: cmp.getEl(),
			                 text: panel.localize('minRawFreqTip')
			             });
	    			});
	    			this.on('beforedestroy', function(cmp) {
                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
                	});
	    			this.callParent(arguments);
	    		},
	    		fieldLabel: 'minRawFreq'
    		}
    	}],
    	perim: [],
    	diam: undefined
	},
	
	tokensFetch: 500,
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	this.config.options[1].fieldLabel = this.localize(this.config.options[1].fieldLabel);
    	Ext.apply(this, {
    		title: this.localize('title'),
			html: '<canvas width="800" height="600"></canvas>',
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'combo',
                	itemId: 'search',
                	queryMode: 'local',
                	displayField: 'term',
                	valueField: 'term',
                	width: 90,
                	emptyText: this.localize('search'),
                	forceSelection: true,
                	disabled: true
                },{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					fieldLabel: this.localize('speed'),
					labelAlign: 'right',
					labelWidth: 40,
					width: 100,
					increment: 1,
					minValue: 0,
					maxValue: 100,
					value: 30,
					listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(parseInt(this.getApiParam("speed")));
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('speedTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    changecomplete: function(cmp, val) {
	                    	this.setApiParam('speed', val);
                    		this.isReading = val!==0
                    		this.draw();
	                    },
	                    scope: this
					}
				},{xtype: 'tbfill'}, {
	    			xtype: 'tbtext',
	    			html: this.localize('adaptation')
	    		}]
    		}]
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('boxready', function(cmp) {
			var canvas = this.getTargetEl().dom.querySelector("canvas");
	    	this.draw(canvas);

    		canvas.addEventListener('mousemove', function(evt) {
    			if (cmp.documentTerms) {
        			var rect = canvas.getBoundingClientRect(), x =  evt.clientX - rect.left, y = evt.clientY - rect.top;
        			
        			var currentTerms = {};
        			cmp.documentTerms.each(function(documentTerm) {
        				var dx = documentTerm.get('x'), dy = documentTerm.get('y');
        				if (dx>x-15 && dx<x+15 && dy>y-15 && dy<y+15) {
        					currentTerms[documentTerm.getTerm()] = true;
        					return false;
        				}
        			})
        			
        			// no need to do anything if there are no current terms and none found
        			if (Object.keys(cmp.currentTerms || {}).length==0 && Object.keys(currentTerms).length==0) {return;}

        			cmp.currentTerms = currentTerms;
        			cmp.draw(canvas); // otherwise redraw
    			}
    			
    	      }, false);
    	})
    	
    	this.on('loadedCorpus', function(src, corpus) {
			this.loadDocument();
    	}, this);
    	
    	this.on("documentselected", function(src, doc) {
    		this.setApiParam('docIndex', this.getCorpus().getDocument(doc).getIndex());
    		this.loadDocument();
    	});
    	
    	this.on("resize", function() {
    		var gutter = 20,
			availableWidth = this.getTargetEl().getWidth() - gutter - gutter,
			availableHeight = this.getTargetEl().getHeight() - gutter - gutter,
			diam = Math.max(availableWidth, availableHeight), rad = diam /2,
			ratio = Math.min(availableWidth, availableHeight) / diam,
			canvas = this.getTargetEl().dom.querySelector("canvas");
    		
			canvas.width = this.getTargetEl().getWidth();
			canvas.height = this.getTargetEl().getHeight();
			this.setDiam(diam);
			this.setPerim([]);
			var i = parseInt(diam*.75)
			while (this.getPerim().length<diam) {
	    		this.getPerim().push({
	    			x:  gutter+(availableWidth/2)+(rad * (availableWidth>availableHeight ? 1 : ratio) * Math.cos(2 * Math.PI * i / diam)),
	    			y:  gutter+(availableHeight/2)+(rad * (availableHeight>availableWidth ? 1 : ratio) * Math.sin(2 * Math.PI * i / diam))
	    		})
	    		if (i++==diam) {i=0;}
			}
			
			// TODO clear previous/current drawing
    	})
    },
    
    draw: function(canvas, ctx) {
    	canvas = canvas ||  this.getTargetEl().dom.querySelector("canvas");
    	ctx = ctx || canvas.getContext("2d");
    	ctx.clearRect(0,0,canvas.width,canvas.height);
		ctx.fillStyle = "rgba(0,0,0,.1)";
    	this.getPerim().forEach(function(p,i) {
    		if (i%3==0) {
        		ctx.fillRect(p.x-5,p.y,10,1)
    		}
    	})
    	if (this.documentTerms) {
        	this.drawTerms(canvas, ctx);
        	this.drawReading(canvas,ctx);
        	if (this.isReading) {
        		var me = this;
        		setTimeout(function() {
        			me.draw();
        		}, 10)
        	}
    	}
    },
    
    drawReading: function(canvas, ctx) {
    	ctx = ctx || this.getTargetEl().dom.querySelector("canvas").getContext("2d");
    	var delay = 2000-(parseInt(this.getApiParam('speed'))*1999/100);
    	if (this.isReading && this.documentTerms) {
    		var current = parseInt(this.readingIndex * this.getPerim().length / this.lastToken);
    		ctx.fillStyle = "purple";
    		ctx.fillRect(this.getPerim()[current].x,this.getPerim()[current].y, 5, 5)
			var first = this.readingStartTime == undefined;
			this.readingStartTime = this.readingStartTime || new Date().getTime();
			var delta = this.readingStartTime+delay-new Date().getTime();
    		if (this.sourceTerm && this.targetTerm) {
    			var maxTail = 10;
    			if (first || delta<=0) {
    				this.previousBeziers = this.previousBeziers || []; // this should be reset by tokens reader during first read
        			var sx = this.sourceTerm.get('x'), sy = this.sourceTerm.get('y'), tx = this.targetTerm.get('x'), ty = this.targetTerm.get('y'),
    					px = this.previousTerm ? this.previousTerm.get('x') : sx, py = this.previousTerm ? this.previousTerm.get('y') : sy,
    					round = 100, multiplier = .3;
    				
        			var ix, iy, xd = Math.max(round, Math.abs(sx-tx) * .5), yd = Math.max(round, Math.abs(sy-ty) * .5);
        			ix = sx > tx ? sx - xd : sx + xd;
        			iy = ty > sy ? sy + yd : sy - yd;
    				this.previousBeziers.unshift([sx,sy,ix,iy,tx,ty]);
    				if (this.previousBeziers.length>maxTail) {this.previousBeziers.pop()}
    			}
    			
    			for (var i=0; i<this.previousBeziers.length; i++) {
	        		ctx.strokeStyle="rgba(0,0,255,"+(1-(i*.1))+")";
    				var start = i+1 == this.previousBeziers.length ? 1-(delta/delay) : 0;
    				var end = i==0 ? 1-(delta/delay) : 1;
            		this.drawBezierSplit.apply(this, Ext.Array.merge([ctx], this.previousBeziers[i], [start], [end]));
    			}
    			if (delta<=0) {
        			this.readingStartTime = undefined;
        			this.read();
    			}
    		}
    		var nextReadingIndex = this.readingIndex+1;
    		for (var len=this.tokens.getCount(); nextReadingIndex<len; nextReadingIndex++) {
    			if (this.tokens.getAt(nextReadingIndex).getTerm().toLowerCase()==this.targetTerm.getTerm()) {
    				break;
    			}
    		}
    		var startReadingIndex = nextReadingIndex-parseInt(delta*(nextReadingIndex-this.readingIndex)/delay), count = this.tokens.getCount();
    		for (; startReadingIndex<nextReadingIndex; startReadingIndex++) {
    			if (startReadingIndex < count && this.tokens.getAt(startReadingIndex).isWord()) {
    				break;
    			}
    		}
    		var tokens = this.tokens.getRange(startReadingIndex, len=Math.min(this.readingIndex+50, this.tokens.getCount())).map(function(token) {
    			return token.getTerm();
    		})
	    	ctx.font = "14px sans-serif";
    		ctx.fillStyle = "rgba(0,0,0,.5)";
        	ctx.textAlign = "left";
    		ctx.fillText(tokens.join(""), canvas.width/4, canvas.height-5);
    		ctx.clearRect(canvas.width*.75, canvas.height-20, canvas.width, 30)
    	} else if (this.documentTerms && this.documentTerms.getCount()<this.documentTerms.getTotalCount()) {
    		var x = canvas.width / 4;
    		ctx.strokeStyle="rgba(0,0,0,.5)";
    		ctx.fillStyle = "rgba(0,0,0,.2)";
    		ctx.strokeRect(x,canvas.height-12,x*2,10);
    		ctx.fillRect(x,canvas.height-12,(this.documentTerms.getCount()*x*2)/this.documentTerms.getTotalCount(),10);
    	}
    },
    
    drawTerms: function(canvas, ctx) {
    	canvas = canvas || this.getTargetEl().dom.querySelector("canvas");
    	ctx = ctx || canvas.getContext("2d");
    	ctx.textAlign = "center";
    	if (this.documentTerms && this.getPerim().length > 0) {
    		this.documentTerms.each(function(documentTerm) {
    			var me = this, freq = documentTerm.getRawFreq(), term = documentTerm.getTerm(),
    				x = documentTerm.get('x'), y = documentTerm.get('y');
    			isCurrentTerm = me.currentTerms && (term in me.currentTerms);
    			isReadingTerm = this.sourceTerm && this.sourceTerm.getTerm() == term;
    	    	ctx.font = ((Math.log(freq)*(canvas.width*10/800)/Math.log(this.maxRawFreq))+(isCurrentTerm || isReadingTerm ? 10 : 5)) + "px sans-serif";
    	    	if (isCurrentTerm) {
    	    		ctx.fillStyle = "red";
    	    	} else if (isReadingTerm) {
    	    		ctx.fillStyle = "blue";
    	    	} else {
    	    		ctx.fillStyle = "rgba(0,0,0,"+((freq*.9/this.maxRawFreq)+.1)+")";
    	    	}
    	    	if (isCurrentTerm || isReadingTerm) {
    	    		ctx.strokeStyle = isCurrentTerm ? "rgba(255,0,0,.2)" : "rgba(0,255,0,.4)";
    	    		documentTerm.getDistributions().forEach(function(d, i) {
    	    			if (d>0 && this.getPerim()[i]) {
    	    				ctx.beginPath();
    	    				ctx.moveTo(x, y);
    	    				ctx.lineTo(this.getPerim()[i].x,this.getPerim()[i].y);
    	    				ctx.stroke();
    	    			}
    	    		}, this)
    	    	}
    			ctx.fillText(term, x, y);
    			
    		}, this)    		
    	}
    },
    
    read: function(index) {
    	if (Ext.isNumber(index)) {this.readingIndex=index;}
    	else {this.readingIndex++;}
    	if (this.sourceTerm) {this.previousTerm=this.sourceTerm;}
    	for (var i=this.readingIndex, len = this.tokens.getCount(); i<len; i++) {
    		var token = this.tokens.getAt(i), term = token.getTerm().toLowerCase();
    		if (term in this.termsMap) {
    			this.sourceTerm = this.termsMap[term];
    			if (this.sourceTerm.getRawFreq()>=1) {
        			this.readingIndex = i;
        			break
    			}
    		}
    	}
    	for (var i=this.readingIndex+1, len = this.tokens.getCount(); i<len; i++) {
    		var token = this.tokens.getAt(i), term = token.getTerm().toLowerCase();
    		if (term in this.termsMap) {
    			this.targetTerm = this.termsMap[term];
    			if (this.targetTerm.getRawFreq()>=1) {
        			break;
    			}
    		}
    	}
    	if (!this.tokensLoading && this.tokens.getCount()-this.readingIndex<this.tokensFetch) {
    		this.fetchMoreTokens();
    	}
    	this.draw();
    },
    
    
    loadDocument: function() {
    	if (this.documentTerms) {this.documentTerms.destroy();this.documentTerms=undefined;}
    	this.termsMap = {};
    	this.draw();
    	var doc =  this.getCorpus().getDocument(parseInt(this.getApiParam('docIndex')));
    	// if we're not in a tab panel, set the document title as part of the header
    	if (!this.up("tabpanel")) {
        	this.setTitle(this.localize('title') + " <span class='subtitle'>"+doc.getFullLabel()+"</span>");
    	}
    	this.lastToken = parseInt(doc.get('lastTokenStartOffset-lexical'));
    	this.documentTerms = doc.getDocumentTerms({
    		proxy: {
    			extraParams: {
    				stopList: this.getApiParam('stopList'),
    				bins: this.getDiam(),
    				withDistributions: 'raw',
    				minRawFreq: parseInt(this.getApiParam('minRawFreq'))
    			}
    		}
    	});
    	var search = this.queryById('search');
    	search.setDisabled(true);
    	search.setStore(this.documentTerms);
    	this.fetchMoreDocumentTerms();
    },
    
    fetchMoreDocumentTerms: function() {
    	if (!this.documentTerms) {this.loadDocument(); return;}
    	this.documentTerms.load({
    		params: {
    			start: this.documentTerms.getCount(),
    			limit: this.documentTerms.getCount() == 0 ? 10 : 250
    		},
    		callback: function(records) {
    			if (records.length>0) {
            		this.maxRawFreq = this.documentTerms.max('rawFreq');
            		records.forEach(function(documentTerm) {
            			var x = y = 0;
            			documentTerm.get('distributions').forEach(function(d, i) {
            				x += (this.getPerim()[i].x*d);
            				y += (this.getPerim()[i].y*d);
            			}, this)
            			documentTerm.set('x', x/documentTerm.getRawFreq());
            			documentTerm.set('y', y/documentTerm.getRawFreq());
            		}, this);
    				Ext.Function.defer(this.fetchMoreDocumentTerms, 0, this);
    				this.draw();
    			} else {
    				this.queryById('search').setDisabled(false);
    				this.termsMap = {};
    				this.documentTerms.each(function(documentTerm) {
    					this.termsMap[documentTerm.getTerm()] = documentTerm;
    				}, this)
    				if (this.tokens) {this.tokens.removeAll(true)}
    				this.fetchMoreTokens();
    			}
    		},
    		addRecords: true,
    		scope: this
    	})
    },
    
    fetchMoreTokens: function() {
		if (!this.tokens) {
			this.tokens = this.getCorpus().getDocument(parseInt(this.getApiParam('docIndex'))).getTokens({
				proxy: {
					extraParams: {
	    				stripTags: 'all'
					}
				}
			});
			this.noMoreTokens = false;
		} else if (this.noMoreTokens) {return;}
		
		var first = this.tokens.getCount() == 0;
		this.tokensLoading = true;
		var speed = parseInt(this.getApiParam('speed'));
    	this.tokens.load({
    		params: {
    			start: this.tokens.getCount(),
    			limit: speed==50 && first ? 200 : Math.pow(110-speed, 2)
    		},
    		callback: function(records) {
    			this.tokensLoading = false;
    			if (records.length>0) {
    				records.forEach(function(token) {
    					if (token.getTokenType()=='other') {
    						token.set('term', token.getTerm().replace(/\s+/g, " "))
    					}
    				})
        			if (first) {
        				this.previousBeziers = [];
        				// TODO
//        				if (this.getApiParam('speed') > 0) {
	        				this.isReading = true;
	        				this.read(0);
//        				}
        			}
    			} else {
    				this.noMoreTokens = true;
    			}
    		},
    		addRecords: true,
    		scope: this

    	});
    },
    
    /* The functions below adapted from http://www.pjgalbraith.com/drawing-animated-curves-javascript/ */
    
    /**
     * Animates bezier-curve
     * 
     * @param ctx       The canvas context to draw to
     * @param x0        The x-coord of the start point
     * @param y0        The y-coord of the start point
     * @param x1        The x-coord of the control point
     * @param y1        The y-coord of the control point
     * @param x2        The x-coord of the end point
     * @param y2        The y-coord of the end point
     * @param duration  The duration in milliseconds
     * @private
     */
    animatePathDrawing: function(ctx, x0, y0, x1, y1, x2, y2, duration) {
        var start = null;
        
        var step = function animatePathDrawingStep(timestamp) {
            if (start === null)
                start = timestamp;
            
            var delta = timestamp - start,
                progress = Math.min(delta / duration, 1);
            
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // Draw curve
            drawBezierSplit(ctx, x0, y0, x1, y1, x2, y2, 0, progress);
            
            if (progress < 1) {
                window.requestAnimationFrame(step);
            }
        };
        
        window.requestAnimationFrame(step);
    },
    
    /**
     * Draws a splitted bezier-curve
     * 
     * @param ctx       The canvas context to draw to
     * @param x0        The x-coord of the start point
     * @param y0        The y-coord of the start point
     * @param x1        The x-coord of the control point
     * @param y1        The y-coord of the control point
     * @param x2        The x-coord of the end point
     * @param y2        The y-coord of the end point
     * @param t0        The start ratio of the splitted bezier from 0.0 to 1.0
     * @param t1        The start ratio of the splitted bezier from 0.0 to 1.0
     * @private
     */
    drawBezierSplit: function(ctx, x0, y0, x1, y1, x2, y2, t0, t1) {
        ctx.beginPath();
        
        if( 0.0 == t0 && t1 == 1.0 ) {
            ctx.moveTo( x0, y0 );
            ctx.quadraticCurveTo( x1, y1, x2, y2 );
        } else if( t0 != t1 ) {
            var t00 = t0 * t0,
                t01 = 1.0 - t0,
                t02 = t01 * t01,
                t03 = 2.0 * t0 * t01;
            
            var nx0 = t02 * x0 + t03 * x1 + t00 * x2,
                ny0 = t02 * y0 + t03 * y1 + t00 * y2;
            
            t00 = t1 * t1;
            t01 = 1.0 - t1;
            t02 = t01 * t01;
            t03 = 2.0 * t1 * t01;
            
            var nx2 = t02 * x0 + t03 * x1 + t00 * x2,
                ny2 = t02 * y0 + t03 * y1 + t00 * y2;
            
            var nx1 = this.lerp ( this.lerp ( x0 , x1 , t0 ) , this.lerp ( x1 , x2 , t0 ) , t1 ),
                ny1 = this.lerp ( this.lerp ( y0 , y1 , t0 ) , this.lerp ( y1 , y2 , t0 ) , t1 );
            
            ctx.moveTo( nx0, ny0 );
            ctx.quadraticCurveTo( nx1, ny1, nx2, ny2 );
        }
        
        ctx.stroke();
        ctx.closePath();
    },
    
    /**
     * Linearly interpolate between two numbers v0, v1 by t
     * @private
     */
    lerp: function(v0, v1, t) {
        return ( 1.0 - t ) * v0 + t * v1;
    }
    
    
    
});

// for mysterious reasons, Ext.require loads the scripts but produces a blank page, so use loadScript instead
/*
var twicPath = Ext.Loader.getPath("resources")+"/twic/current"
Ext.Loader.loadScript(twicPath+"/css/twic.css")
Ext.Loader.loadScript(twicPath+"/lib/queue.min.js")
Ext.Loader.loadScript(twicPath+"/lib/textFlow.js")
Ext.Loader.loadScript(twicPath+"/lib/svg_helper_functions.js")
Ext.Loader.loadScript(twicPath+"/lib/class_syntax.js")
Ext.Loader.loadScript(twicPath+"/js/twic_level.js")
Ext.Loader.loadScript(twicPath+"/js/twic_panel.js")
Ext.Loader.loadScript(twicPath+"/js/twic_datashape.js")
*/


Ext.define('Voyant.panel.TopicContexts', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.topiccontexts',
    statics: {
    	i18n: {
    	},
    	api: {
    	},
		glyph: 'xf06e@FontAwesome'
    },
    
    constructor: function(config) {

    	Ext.apply(this, {
    		title: this.localize('title'),
    		cls: 'twic_body'
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);

    },
    
    listeners: {
    	loadedCorpus: function(src, corpus) {		
    		this.loadFromCorpus(corpus);
    	}
    	
    },
    
    loadFromCorpus: function(corpus) {
    	var url = Ext.Loader.getPath("resources")+"/twic/current/data/input/json"
        var twicLevel = TWiC.Level.prototype.Instance();
        twicLevel.LoadJSON(url+"/twic_corpusinfo.json", url+"/twic_corpusmap.json");
        var panel = this;

        // Once JSON has loaded, create and start the level
        twicLevel.m_queue.await(function(){

            // Create components
            var graphViews = [];
            var infoViews = [];
            var divName = "dickinson"; // NOTE: This needs to be added to twic_corpusinfo.json from serverside

            // Topic bar setup
            var topicBar = new TWiC.TopicBar({x:0, y:635}, // Position
                                             {width:1280, height:165}, // Size
                                             divName, // Name
                                             twicLevel, []); // Level and linked view(s)
            infoViews.push(topicBar);

            // Document info bar setup
            var docBar = new TWiC.DocumentBar({"x":1055, "y":0}, // Position
                                              {"width":225, "height":635}, // Size
                                              divName,  // Name
                                              twicLevel, []); // Level and linked view(s)
            infoViews.push(docBar);

            // Graph setup
            var corpusClusterView = new TWiC.CorpusClusterView({ "x":0, "y":0 }, // Position
                                                               { "width":1055, "height":635}, // Size
                                                               divName, // Name
                                                               twicLevel, [topicBar, docBar]); // Level and linked view(s)
            graphViews.push(corpusClusterView);

            // Link the corpus cluster view to the topic bar as well
            topicBar.m_linkedViews.push(corpusClusterView);

            var body = panel.getLayout().getRenderTarget();

            // Initialize the level
            twicLevel.Initialize([0,0], // Position
                                 {width: body.getWidth(), height: body.getHeight()}, // Size
                                 divName, // Name
                                 graphViews, infoViews, // TWiC graph and information panels
                                 '#'+body.getId()
            );

            // Startup the level
            twicLevel.Start();
        }.bind(twicLevel));

    }
    
})
Ext.define('Voyant.panel.TermsBerry', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.termsberry',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		context: 2,
        	numInitialTerms: 75,
    		query: undefined,
    		docIndex: undefined,
    		docId: undefined,
    		categories: undefined
    	},
		glyph: 'xf1db@FontAwesome'
    },
    config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    	
    	mode: undefined,
    	
    	scalingFactor: 3,
    	
    	minRawFreq: undefined,
    	maxRawFreq: undefined,
    	maxCollocateValue: undefined,
    	minFillValue: undefined,
    	maxFillValue: undefined,
    	
    	currentData: {},
    	blacklist: {},
    	
    	visLayout: undefined,
    	vis: undefined,
    	visInfo: undefined,
    	visId: undefined,
    	
    	currentNode: undefined,
    	
    	tip: undefined,
    	contextMenu: undefined
	},
    
	MODE_TOP: 'top',
    MODE_DISTINCT: 'distinct',
    
    MIN_TERMS: 5,
    MAX_TERMS: 500,
    
    COLLOCATES_LIMIT: 1000000, // a very large number so we get all of them
    
    MIN_SCALING: 1,
    MAX_SCALING: 5,
    
    MIN_STROKE_OPACITY: 0.1,
	MAX_STROKE_OPACITY: 0.3,
	
    layout: 'fit',
    
    constructor: function(config) {
    	this.setMode(this.MODE_TOP);
    	
    	this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.setVisId(Ext.id(null, 'termspack_'));
    },
    
    initComponent: function() {
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                   xtype: 'querysearchfield',
                   clearOnQuery: true
                },{
                	xtype: 'button',
                	text: this.localize('strategy'),
                	menu: {
	                	items: [{
	                		xtype: 'menucheckitem',
	                		group: 'strategy',
	                		checked: this.getMode() === this.MODE_TOP,
	                		text: this.localize('topTerms'),
	                		checkHandler: function(item, checked) {
	                			if (checked) {
	                				this.setMode(this.MODE_TOP);
	                				this.doLoad();
	                			}
	                		},
	                		scope: this
	                	},{
	                		xtype: 'menucheckitem',
	                		group: 'strategy',
	                		checked: this.getMode() === this.MODE_DISTINCT,
	                		text: this.localize('distinctTerms'),
	                		checkHandler: function(item, checked) {
	                			if (checked) {
	                				this.setMode(this.MODE_DISTINCT);
	                				this.doLoad();
	                			}
	                		},
	                		scope: this
	                	}]
                	}
                },{
	                fieldLabel: this.localize('numTerms'),
	    			labelWidth: 50,
	    			labelAlign: 'right',
	    			width: 120,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: this.MIN_TERMS,
	            	maxValue: this.MAX_TERMS,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam('numInitialTerms')));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParam("numInitialTerms", newvalue);
	            			this.doLoad();
	            		},
	            		scope: this
	            	}
                },{
	                fieldLabel: this.localize('context'),
	    			labelWidth: 50,
	    			labelAlign: 'right',
	    			width: 120,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: 1,
	            	maxValue: 30,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam('context'));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({context: newvalue});
	            			this.doLoad();
	            		},
	            		scope: this
	            	}
                },{
	                fieldLabel: this.localize('scaling'),
	    			labelWidth: 50,
	    			labelAlign: 'right',
	    			width: 120,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: this.MIN_SCALING,
	            	maxValue: this.MAX_SCALING,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getScalingFactor());
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			// use the inverse of the value since it'll make more sense to the user
	            			var value = Math.abs(newvalue-(this.MAX_SCALING+1));
	            			this.setScalingFactor(value);
	            			this.reload();
	            		},
	            		scope: this
	            	}
                }
                ]
    		}]
    	});
    	
    	this.setContextMenu(Ext.create('Ext.menu.Menu', {
			renderTo: Ext.getBody(),
			items: [{
				xtype: 'box',
				itemId: 'label',
				margin: '5px 0px 5px 5px',
				html: ''
			},{
		        xtype: 'menuseparator'
			},{
				xtype: 'button',
				text: 'Remove',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
						delete this.getCurrentData()[node.data.term];
						this.getBlacklist()[node.data.term] = true;
						this.setCurrentNode(undefined);
					}
					this.getContextMenu().hide();
					this.reload();
				},
				scope: this
			}]
		}));
    	
    	this.on('query', function(src, query) {
    		if (query.length > 0) {
    			this.doLoad(query);
    		}
		}, this);
    	
    	this.callParent(arguments);
    },
    
    listeners: {
    	boxready: function() {
			this.initVisLayout();
    	},
    	
    	resize: function(panel, width, height) {
    		if (this.getVisLayout() && this.getCorpus()) {
    			var el = this.getLayout().getRenderTarget();
    	    	width = el.getWidth();
    			height = el.getHeight();
    			
    			el.down('svg').set({width: width, height: height});
    			
    			this.getVisLayout().size([width, height]);
    			
    			this.reload();
    		}
    	},
    	
    	loadedCorpus: function(src, corpus) {
    		if (this.isVisible()) {
        		this.doLoad();
    		}
    	},
    	activate: function() {
    		if (this.getCorpus()) {
    			this.doLoad();
    		}
    	}
    },
    
    doLoad: function(query) {
		this.resetVis();
		if (query === undefined) {
			this.resetMinMax();
			this.setCurrentData({});
		}
    	if (this.getMode() === this.MODE_DISTINCT) {
    		this.getDistinctTerms(query);
    	} else {
    		this.getTopTerms(query);
    	}
    },
    
    reload: function() {
    	var data = this.processCollocates([]);
		if (data.length > 0) {
			this.resetVis();
			this.buildVisFromData(data);
		}
    },
    
    resetMinMax: function() {
    	this.setMinRawFreq(undefined);
    	this.setMaxRawFreq(undefined);
    	this.setMaxCollocateValue(undefined);
    	this.setMinFillValue(undefined);
    	this.setMaxFillValue(undefined);
    },
    
    resetVis: function() {
    	var vis = this.getVis();
    	if (vis) {
        	vis.selectAll('.node').remove();
    	}
    },
    
    getTopTerms: function(query) {
    	var limit = parseInt(this.getApiParam('numInitialTerms'));
    	var stopList = this.getApiParam('stopList');
    	if (query !== undefined) {
    		limit = undefined;
    		stopList = undefined;
    	}
    	this.getCorpus().getCorpusTerms().load({
    		params: {
    			query: query,
 				limit: limit,
 				stopList: stopList
 			},
		    callback: function(records, operation, success) {
		    	if (success) {
		    		this.loadFromRecords(records);
		    	}
		    },
		    scope: this
    	});
    },
    
    getDistinctTerms: function(query) {
    	var limit = parseInt(this.getApiParam('numInitialTerms'));
    	var stopList = this.getApiParam('stopList');
    	if (query !== undefined) {
    		limit = undefined;
    		stopList = undefined;
    	}
    	var perDocLimit = Math.ceil(parseInt(this.getApiParam('numInitialTerms')) / this.getCorpus().getDocumentsCount()); // ceil ensures there's at least 1 per doc
    	this.getCorpus().getDocumentTerms().load({
			params: {
				query: query,
				limit: limit,
				perDocLimit: perDocLimit,
				stopList: stopList,
				sort: 'TFIDF',
				dir: 'DESC'
			},
			callback: function(records, operation, success) {
				if (success) {
					this.loadFromRecords(records);
				}
			},
			scope: this
    	});
    },
    
    loadFromQuery: function(query) {
    	this.getCorpus().getCorpusTerms().load({
    		params: {
 				query: query
 			},
		    callback: function(records, operation, success) {
		    	if (success) {
		    		this.loadFromRecords(records);
		    	}
		    },
		    scope: this
    	});
    },
    
    loadFromRecords: function(records) {
    	if (Ext.isArray(records) && records.length>0) {
    		var maxFreq = this.getMaxRawFreq();
    		var minFreq = this.getMinRawFreq();
    		var minFillVal = this.getMinFillValue();
    		var maxFillVal = this.getMaxFillValue();
    		var terms = [];
    		records.forEach(function(r) {
    			var term = r.getTerm();
    			if (!this.getBlacklist()[term]) {
	    			var rawFreq = r.getRawFreq();
	    			var fillVal = this.getMode() === this.MODE_DISTINCT ? r.get('tfidf') : r.getInDocumentsCount();
	    			
	    			if (maxFreq === undefined || rawFreq > maxFreq) maxFreq = rawFreq;
	    			if (minFreq === undefined || rawFreq < minFreq) minFreq = rawFreq;
	    			
	    			if (maxFillVal === undefined || fillVal > maxFillVal) maxFillVal = fillVal;
	    			if (minFillVal === undefined || fillVal < minFillVal) minFillVal = fillVal;
	    			
	    			this.getCurrentData()[term] = {
	    				term: term,
	    				rawFreq: rawFreq,
	    				relativeFreq: r.get('relativeFreq'),//r.getRelativeFreq(),
	    				fillValue: fillVal,
	    				collocates: []
	    			};
	    			
	    			terms.push(term);
    			}
    		}, this);
    		
    		this.setMaxRawFreq(maxFreq);
    		this.setMinRawFreq(minFreq);
    		this.setMinFillValue(minFillVal);
    		this.setMaxFillValue(maxFillVal);
    		
    		this.getCollocatesForQuery(terms);
    	}
    },
    
    getCollocatesForQuery: function(query) {
    	var whitelist = [];
    	for (var term in this.getCurrentData()) {
    		whitelist.push(term);
    	}
    	 
    	this.setApiParams({
    		mode: 'corpus'
    	});
    	var params = this.getApiParams();
    	this.getCorpus().getCorpusCollocates().load({
    		params: Ext.apply(Ext.clone(params), {query: query, collocatesWhitelist: whitelist, limit: this.COLLOCATES_LIMIT}),
    		callback: function(records, op, success) {
    			if (success) {
    				this.buildVisFromData(this.processCollocates(records));
    			}
    		},
    		scope: this
    	});
    },
    
    processCollocates: function(records) {
    	var currentTerms = this.getCurrentData();

    	var maxCol = this.getMaxCollocateValue();
    	
    	for (var i=0; i<records.length; i++) {
    		var r = records[i];
    		var term = r.getTerm();
			var contextTerm = r.getContextTerm();
			var contextFreq = r.getContextTermRawFreq();
			
			if (maxCol === undefined || contextFreq > maxCol) {
				maxCol = contextFreq;
			}
			
			if (currentTerms[term] === undefined) {
				// should not be here
			} else {
	    		if (term != contextTerm) {
	    			currentTerms[term].collocates.push({
	    				term: contextTerm, value: contextFreq
	    			});
	    		}
			}
    	}
    	
    	this.setMaxCollocateValue(maxCol);
    	
    	var data = [];
    	for (var term in currentTerms) {
//    		if (currentTerms[term].collocates.length > 0) {
    			data.push(currentTerms[term]);
//    		}
    	}
    	return data;
    },
    
    buildVisFromData: function(data) {
    	var me = this;
    	
    	if (!this.getVis()) {return;} // not initialized
    	
    	var rootId = '$$$root$$$';
    	data.push({term: rootId, collocates:[], rawFreq:1});
    	var root = d3.stratify()
    		.id(function(d) { return d.term; })
    		.parentId(function(d) {
    			if (d.term !== rootId) return rootId;
				else return '';
			})(data)
			.sort(function(a, b) { return a.rawFreq < b.rawFreq ? 1 : a.rawFreq > b.rawFreq ? -1 : 0; })
			.sum(function(d) { return Math.pow(d.rawFreq, 1/me.getScalingFactor()); });
    	this.getVisLayout()(root);
    	
    	// join nodes with data
    	var nodes = this.getVis().selectAll('.node').data(root.descendants());
    	
    	// update
    	nodes.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
    	nodes.selectAll('circle').attr('r', function(d) { return d.r; });
    	
    	var idGet = function(term) {
    		return term.replace(/\W/g, '_'); // remove non-word characters to create valid DOM ids
    	};
    	
    	var collocateFill = d3.scalePow().exponent(1/3)
			.domain([0,this.getMaxCollocateValue()]).range(['#fff', '#bd3163']);
    	
    	var defaultFill;
    	if (this.getMode() === this.MODE_DISTINCT) {
    		defaultFill = d3.scalePow().exponent(1/5)
    			.domain([this.getMinFillValue(), this.getMaxFillValue()]).range(['#dedede', '#fff']);
    	} else {
    		defaultFill = d3.scaleLinear()
				.domain([this.getMaxFillValue(), this.getMinFillValue()]).range(['#dedede', '#fff']);
    	}
    	
    	// roughly calculate font size based on available area and number of terms
    	var size = this.getVisLayout().size();
    	var layoutRadius = Math.min(size[0], size[1]) / 2;
    	var layoutArea = Math.PI*(layoutRadius*layoutRadius);
    	var totalTerms = data.length;
    	var termArea = layoutArea / totalTerms;
    	var termRadius = Math.sqrt(termArea / Math.PI);
    	var minFontSize = termRadius / 3;
    	var scalingInverse = Math.abs(this.getScalingFactor()-(this.MAX_SCALING+1));
    	scalingInverse = Math.max(1, scalingInverse-1); // substract one to avoid too large fonts
    	var maxFontSize = minFontSize * scalingInverse;

    	var textSizer = d3.scaleLinear()//pow().exponent(1/2)
    		.domain([this.getMinRawFreq(),this.getMaxRawFreq()]).range([minFontSize, maxFontSize]);
    	
    	// enter
    	var node = nodes.enter().append('g')
    		.attr('class', 'node')
    		.style('visibility', function(d) { return d.depth > 0 ? 'visible' : 'hidden'; }) // hide root
    		.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
    		.on('click', function(d) {
    			me.dispatchEvent('termsClicked', me, [d.data.term]);
    		})
    		.on('mouseover', function(d, i) {
    			me.setCurrentNode(d);
    			
    			me.getVis().selectAll('circle')
    				.style('stroke-width', 1)
    				.style('stroke', '#111')
        			.style('fill', function(d) { return defaultFill(d.data.fillValue); });
    			
    			d3.select(this).select('circle')
    				.style('fill', '#89e1c2')
    				.style('stroke', '#26926c')
    				.style('stroke-opacity', me.MAX_STROKE_OPACITY);
    			
    			var fillLabel;
    			if (me.getMode() === me.MODE_DISTINCT) {
    				fillLabel = me.localize('tfidf');
    			} else {
    				fillLabel = me.localize('inDocs');
    			}
    			
    			if (!me.getContextMenu().isVisible()) {
	    			var info = '<b>'+d.data.term+'</b> ('+d.data.rawFreq+')<br/>'+fillLabel+': '+d.data.fillValue;
					var tip = me.getTip();
					tip.update(info);
					tip.show();
    			}
				
				for (var i = 0; i < d.data.collocates.length; i++) {
					var collocate = d.data.collocates[i];
					var match = me.getVis().selectAll('.node').filter(function(d) { return d.data.term === collocate.term; });
					match.select('circle')
						.style('fill', function(d) { return collocateFill(collocate.value); })
						.style('stroke', '#bd3163')
						.style('stroke-opacity', me.MAX_STROKE_OPACITY);
					match.select('tspan.value').text(function(d) { return collocate.value; });
				}
			})
			.on('mousemove', function() {
				me.getTip().setPosition(d3.event.pageX+5, d3.event.pageY-50);
			})
			.on('mouseout', function() {
				if (!me.getContextMenu().isVisible()) {
					me.setCurrentNode(undefined);
				}
				
				me.getVis().selectAll('circle').style('stroke-opacity', me.MIN_STROKE_OPACITY).style('stroke', '#111')
	    			.style('fill', function(d) { return defaultFill(d.data.fillValue); });
				me.getVis().selectAll('tspan.value').text('');
				me.getTip().hide();
//				me.getVisInfo().text('');
			})
			.on('contextmenu', function(d, i) {
				d3.event.preventDefault();
				me.getTip().hide();
				var menu = me.getContextMenu();
				menu.queryById('label').setHtml(d.data.term);
				menu.showAt(d3.event.pageX+5, d3.event.pageY-50);
			});
    	
    	node.append('circle')
    		.attr('id', function(d) {
    			return idGet(d.data.term);
			})
			.attr('r', function(d) { return d.r; })
			.style('fill', function(d) { return defaultFill(d.data.fillValue); })
			.style('stroke', '#111')
			.style('stroke-opacity', me.MIN_STROKE_OPACITY)
			.style('stroke-width', 1);
    	
    	node.append('clipPath').attr('id', function(d) { return 'clip-' + idGet(d.data.term); })
    		.append('use').attr('xlink:href', function(d) { return '#' + idGet(d.data.term); });
		
    	var text = node.append('text')
    		.attr('clip-path', function(d) { return 'url(#clip-' + idGet(d.data.term) + ')'; })
    		.style('font-family', function(d) { return me.getApplication().getFeatureForTerm('font', d.data.term); })
			.style('text-anchor', 'middle')
			.style('cursor', 'default');
		text.append('tspan')
			.attr('class', 'term')
			.attr('font-size', function(d) { return textSizer(d.data.rawFreq); })
			.attr('x', 0)
			.attr('y', function(d) { return textSizer(d.data.rawFreq)/4; })
			.text(function(d) { return d.data.term; });
		text.append('tspan')
			.attr('class', 'value')
			.attr('font-size', function(d) { return textSizer(d.data.rawFreq)*0.75; })
			.attr('x', 0)
			.attr('y', function(d) { return textSizer(d.data.rawFreq)+1; });
		
		// exit
    	nodes.exit().remove();
		
    },
    
    initVisLayout: function() {
    	var el = this.getLayout().getRenderTarget();
		el.update(''); // make sure to clear existing contents (especially for re-layout)
    	var width = el.getWidth();
		var height = el.getHeight();

		var me = this;
		this.setVisLayout(
			d3.pack().size([width, height]).padding(1.5)
		);
		
		var svg = d3.select(el.dom).append('svg').attr('id',this.getVisId()).attr('width', width).attr('height', height);
		this.setVis(svg.append('g'));
		
		this.setVisInfo(svg.append('text').attr('x', 10).attr('y', 10));
		
		if (this.getTip() === undefined) {
			this.setTip(Ext.create('Ext.tip.Tip', {}));
		}
    }
});
/**
 * Terms Radio tool, a visualization for term distributions.
 * 
 * <iframe src="../?corpus=austen&view=termsradio" style="max-width: 600px; height: 600px"></iframe>
 * 
 * The typical use is not to instantiate this class directly, but to embed the tool from a corpus.
 * 
 * 		var austen;
 * 		new Corpus("austen").then(function(corpus) {
 * 			austen = corpus;
 * 			austen.embed('TermsRadio'); // simply embed
 * 			austen.embed('TermsRadio', {visibleBins: 8}); // embed with parameter
 * 		});
 * 
 * @class Voyant.panel.TermsRadio
 * @author Mark Turcato
 * @author Andrew MacDonald
 */
Ext.define('Voyant.panel.TermsRadio', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.termsradio',
	config: {
		/**
		 * @private
		 */
		options: [{
			xtype: 'stoplistoption'
		}],
		/**
		 * @private
		 */
		speed: 50,
		/**
		 * @private
		 */
		termsRadio: undefined
	},
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @private (this shouldn't be modified but it needs to be part of the parameters)
    		 */
    		withDistributions: true,

    		/**
    		 * @cfg {Number} bins How many document segments to show if the corpus has a single document (default is 10); otherwise, the number of bins corresponds to the number of documents in the corpus.
    		 * 
    		 * Note that this often works in parallel with the {@link #bins} value.
    		 */
    		bins: 5
    	
    		/**
    		 * @cfg {Number} visibleBins How many segments or documents to show at once (default is 5).
    		 * 
    		 * Note that this often works in parallel with the {@link #bins} value.
    		 */
    		,visibleBins: 5
    		
    		/**
    		 * @property docIdType The document type(s) to restrict results to.
    		 * @type String|Array
    		 * @default null
    		 * @private
    		 */
    		,docIdType: null
    		
    		/**
    		 * @cfg {Number} limit Determine the number of terms to show (larger numbers may make the graph unusable).
    		 */
    		,limit: 50
    	
    		/**
        	 * @property mode What mode to operate at, either document or corpus.
        	 * @choices document, corpus
    		 * @private
        	 */
    		,mode: null
    		
    		/**
        	 * @property position The current shifted position of the visualization.
        	 * @type Integer
        	 * @default 0
    		 * @private
        	 */
    		,position: 0
    		
    		/**
    		 * @property selectedWords The words that have been selected.
    		 * @type String|Array
    		 * @default null
    		 * @private
    		 */
    		,selectedWords: []
    		
			/**
			 * @cfg {String} stopList A comma-separated list of words, a named list or a URL to a plain text list, one word per line.
			 * 
			 *  By default this is set to 'auto' which auto-detects the document's language and loads an appropriate list (if available for that language). Set this to blank to not use the default stopList.
			 *  
			 * For more information see the <a href="#!/guide/search">Stopwords documentation</a>.
			 */
    		,stopList: 'auto'
    		
    		/**
    		 * @property query The corpus type(s) to restrict results to.
    		 * @type String
    		 * @default null
    		 * @private
    		 */
    		,query: null
    		
    		/**
    		 * @property yAxisScale The scale for the y axis.
    		 * @type String
    		 * @default log
    		 * @private
    		 */
    		,yAxisScale: 'log'
    			
    		,speed: 50
    		
    		/**
    		 * @property slider Whether to show the slider
    		 * @type Boolean
    		 * @default true
    		 */
    		,slider: undefined
    	},
    	glyph: 'xf201@FontAwesome'
    }
	
	/**
	 * @private
	 */
	,constructor: function(config) {
		
		var onLoadHandler = function(mode, store, records, success, operation) {
			this.setApiParams({mode: mode});

			this.getTermsRadio().loadRecords(records);
			
			var query = this.getApiParam('query');
			// check for no results
			if (query) {
				if (records.length==0 || (records.length==1 && records[0].getRawFreq()==0)) {
					this.toastInfo({
						html: this.localize("termNotFound"),
						align: 'bl'
					});
				} else {
					this.getTermsRadio().highlightQuery(query, true);
				}
			}
		};
		
		this.corpusStore = Ext.create("Voyant.data.store.CorpusTerms", {
			listeners : {
				load: {
					fn : onLoadHandler.bind(this, 'corpus'),
					scope : this
				}
			}
		});
		
		this.documentStore = Ext.create("Voyant.data.store.DocumentTerms", {
			listeners : {
				load: {
					fn : onLoadHandler.bind(this, 'document'),
					scope : this
				}
			}
		});
		
		Ext.apply(config, {
			title: this.localize('title'),
			legendMenu: Ext.create('Ext.menu.Menu', {
				items: [
        			{text: '', itemId: 'remove', glyph: 'xf068@FontAwesome'}
        		]
        	}),
			tbar: new Ext.Toolbar({
                overflowHandler: 'scroller',
				items: {
					xtype: 'legend',
					store: new Ext.data.JsonStore({
						fields : ['name', 'mark']
					}),
					listeners: {
						itemclick: function(view, record, el, index) {
							var term = record.get('name');
							if (this.getTermsRadio().isTermSelected(term)) {
								this.getTermsRadio().doTermDeselect(term);
							} else {
								this.getTermsRadio().doTermSelect(term);
							}
						},
						itemcontextmenu: function(view, record, el, index, event) {
							event.preventDefault();
			            	var xy = event.getXY();
			            	
			            	var term = record.get('name');
			            	var text = (new Ext.Template(this.localize('removeTerm'))).apply([term]);
		            		this.legendMenu.queryById('remove').setText(text);
		            		
		            		this.legendMenu.on('click', function(menu, item) {
		            			if (item !== undefined) {
		            				this.doTermDeselect(term, true);
		            			}
		            		}, this, {single: true});
		            		this.legendMenu.showAt(xy);
						},
						scope: this
					}
				}
			}),
			bbar: {
                overflowHandler: 'scroller',
	            items: [{
	            	xtype: 'querysearchfield'
	            },{
	    			glyph: 'xf04b@FontAwesome', // start with play button, which means we're paused
	    			itemId: 'play',
	    			handler: function(btn) {
	    				var playing = btn.glyph=="xf04c@FontAwesome";
	    				if (playing) {
	    					this.getTermsRadio().continueTransition = false;
	    					this.mask(this.localize("completingTransition"))
	    					btn.setPlaying(false)
	    				}
	    				else {
	    					this.getTermsRadio().toggleRightCheck();
	    					btn.setPlaying(true);
	    				}
	    			},
	    			scope: this,
	    			setPlaying: function(bool) {
	    				this.setGlyph(bool ? "xf04c@FontAwesome" : "xf04b@FontAwesome")
	    			}
	    		},{
	    			glyph: 'xf0e2@FontAwesome',
//	    			text: this.localize('reset')
	    			tooltip : this.localize('resetTip'),
	    			listeners : {
	    				click : {fn : function() {
	    					this.queryById("play").setPlaying(false);
							this.getTermsRadio().shiftCount = 0;
							this.getTermsRadio().prepareData();
							this.getTermsRadio().redraw();
    					}				
	    					,scope : this
	    				}
	    			}
	    		},{
	    			xtype: 'label',
	    			forId: 'terms',
	    			text: this.localize('terms')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'terms',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 5,
	    			minValue : 5,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("limit")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			this.loadStore();
	            		},
	            		scope: this
	            	}
	    		},{
	    			xtype: 'label',
	    			forId: 'speed',
	    			text: this.localize('speed')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'speed',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 5,
	    			minValue : 5,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("speed")))
	            			this.setSpeed(slider.getValue())
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({speed: newvalue});
	            			this.setSpeed(newvalue)
	            		},
	            		scope: this
	            	}
	    		},{
	    			xtype: 'label',
	    			itemId: 'visibleSegmentsLabel',
	    			forId: 'visibleBins',
	    			text: this.localize('visibleSegments')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'visibleBins',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 1,
	    			minValue : 1,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("visibleBins")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({visibleBins: newvalue});
							this.numVisPoints = newvalue;
							this.loadStore();
							
							if (this.numVisPoints == this.getCorpus().getDocumentsCount()) {
								this.getTermsRadio().hideSlider();
							} else if (this.getApiParam("slider") != 'false'){
								this.getTermsRadio().showSlider();
							}
	            		},
	            		scope: this
	            	}
	    		},{
	    			xtype: 'label',
	    			itemId: 'segmentsLabel',
	    			forId: 'segments',
	    			text: this.localize('segments')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'segments',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 1,
	    			minValue : 1,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("bins")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({bins: newvalue});
							this.numDataPoints = newvalue;
							this.loadStore();
							var visibleBins = this.queryById('visibleBins');
							visibleBins.setMaxValue(newvalue) // only relevant for doc mode
	            		},
	            		scope: this
	            	}
	    		}]
			}
		});
		
		// need to add option here so we have access to localize
		this.config.options.push({
			xtype: 'combo',
			queryMode : 'local',
			triggerAction : 'all',
			forceSelection : true,
			editable : false,
			fieldLabel : this.localize('yScale'),
			labelAlign : 'right',
			name : 'yAxisScale',
			valueField : 'value',
			displayField : 'name',
			store: new Ext.data.JsonStore({
				fields : ['name', 'value'],
				data   : [{
					name : this.localize('linear'),   value: 'linear'
				},{
					name : this.localize('log'),  value: 'log'
				}]
			}),
			listeners: {
				afterrender: function(combo) {
					combo.setValue(this.getApiParam('yAxisScale'));
				},
				scope: this
			}
		});
		
		this.callParent(arguments);
		this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
		
		this.on('boxready', function(component) {
			var sliderParam = this.getApiParam('slider');
			var showSlider = sliderParam === undefined ? true : sliderParam === 'true';
			var config = {
				parent: this,
				container: this.body,
				showSlider: showSlider
			};
			this.setTermsRadio(new TermsRadio(config));
		}, this);
		
		/**
		 * @event corpusTypesSelected
		 * @type listener
		 * @private
		 */
		this.addListener('corpusTermsClicked', function(src, terms){
			if (this.getCorpus().getDocumentsCount() > 1) {
        		terms.forEach(function(term) {
        			var t = term.getTerm();
        			this.setApiParams({query: t});
        			this.loadStore();
        		});
			}
		});
		
		this.addListener('documentTermsClicked', function(src, terms){
			if(src && src.xtype==this.xtype) {return false;}
			
			terms.forEach(function(term) {
    			var t = term.getTerm();
    			this.setApiParams({query: t});
    			this.loadStore();
    		});
		});
		
		this.on('query', function(src, query){
			this.fireEvent("termsClicked", src, query);
	    });
		
		this.on("termsClicked", function(src, terms) {
			// TODO load term distribution data
			terms.forEach(function(term) {
				var queryTerm;
    			if (Ext.isString(term)) {queryTerm = term;}
    			else if (term.term) {queryTerm = term.term;}
    			else if (term.getTerm) {queryTerm = term.getTerm();}
    			
    			// TODO handling for multiple terms
    			this.setApiParams({query: queryTerm});
    			this.loadStore();
    		}, this);
    	});
		
		this.on("loadedCorpus", function(src, corpus) {
    		this.documentStore.setCorpus(corpus);
    		this.corpusStore.setCorpus(corpus);
    		
    		var params = this.getApiParams();
			if (params.type) {
				delete params.limit;
			}
			var store;
			
			var docsCount = this.getCorpus().getDocumentsCount();
			var segments = this.queryById("segments");
			var visibleBins = this.queryById("visibleBins");
			if (params.mode=='document' || docsCount == 1) {
				this.setApiParam("mode", "document");
				store = this.documentStore;
				visibleBins.setMaxValue(segments.getValue())
			} else {
				this.setApiParam("mode", "corpus");
				delete params.bins;
				store = this.corpusStore;
				segments.hide();
				this.queryById("segmentsLabel").hide();
				var visibleBins = this.queryById("visibleBins");
				visibleBins.setMaxValue(docsCount);
				if (parseInt(this.getApiParam("visibleBins")>docsCount)) {
					visibleBins.setValue(docsCount);
				}
			}
			
			// select top 3 words
			store.on('load', function(store, records) {
				for (var i = 0; i < 3; i++) {
					var r = records[i];
					if (r) {
						this.getTermsRadio().highlightRecord(r, true);
					}
				}
			}, this, {single: true});
			store.load({params: params});
    	}, this);		
	}
	
    ,loadStore: function () {
    	this.queryById('play').setPlaying(false);
		var params = this.getApiParams();
		if(this.getApiParam('mode') === 'document') { 
			this.documentStore.load({params: params});
		}
		if(this.getApiParam('mode') === 'corpus') {
			delete params.bins;
			this.corpusStore.load({params: params});
		}
	}
    
});

/**
 * Trends tool, a line graph that shows term distributions.
 * 
 * <iframe src="../?corpus=austen&view=trends" style="max-width: 500px; height: 300px"></iframe>
 * 
 * The typical use is not to instantiate this class directly, but to embed the tool from a corpus.
 * 
 * 		var austen;
 * 		new Corpus("austen").then(function(corpus) {
 * 			austen = corpus;
 * 			austen.embed('Trends'); // simply embed
 * 			austen.embed('Trends', {query: '^lov*'}); // embed with query
 * 		});
 */
Ext.define('Voyant.panel.Trends', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Voyant.data.store.Documents'],
	alias: 'widget.trends',
	config: {
	    /**
	     * @private
	     */
    	options: [{xtype: 'stoplistoption'},
    		{
    			name: 'bins',
		    	xtype: 'slider',
		    	labelAlign: 'right',
		    	width: 200,
		    	minValue: 2,
		    	maxValue: 100,
	        	listeners: {
	        		afterrender: function(slider) {
	        			var trends = slider.up("window").panel;
	        			slider.setFieldLabel(trends.localize("segmentsSlider"));
	        		}
	        	}    		
    		},{
                xtype: 'radiogroup',
		    	labelAlign: 'right',
                columns: 3,
                vertical: true,
                name: 'withDistributions',
                items: [{
                    boxLabel: 'raw',
                    name: 'withDistributions',
                    inputValue: 'raw'
                },{
                    boxLabel: 'relative',
                    name: 'withDistributions',
                    inputValue: 'relative',
                    style: 'margin-left: 1em;'
                }],
	        	listeners: {
	        		afterrender: function(radiogroup) {
	        			var panel = this.up("window").panel;
	        			this.setFieldLabel("frequencies");
	        			var val = panel.getApiParam("withDistributions");
	        			radiogroup.getBoxes().forEach(function(item) {
	        				item.setBoxLabel(panel.localize(item.inputValue));
	        				item.checked = item.inputValue==val;
	        			});
	        			this.setValue({withDistributions: val});
	        		}
	        	}
    		},{xtype: 'colorpaletteoption'}]
	},
    statics: {
    	i18n: {    		
    	},
    	api: {
    		
    		/**
    		 * @cfg {Number} limit Determine the number of terms to show (larger numbers may make the graph unusable).
    		 */
    		limit: 5,
    		
    		/**
    		 * @cfg {String} stopList A comma-separated list of words, a named list or a URL to a plain text list, one word per line.
    		 * 
    		 *  By default this is set to 'auto' which auto-detects the document's language and loads an appropriate list (if available for that language). Set this to blank to not use the default stopList.
    		 *  
    		 * For more information see the <a href="#!/guide/search">Stopwords documentation</a>.
    		 */
    		stopList: 'auto',
    		
    		/**
    		 * @cfg {String/String[]} query A query or array of queries (queries can be separated by a comma).
    		 * 
    		 * For query syntax, see the <a href="#!/guide/search">search documentation</a>.
    		 */
    		query: undefined,
    		
    		/**
    		 * @cfg {String} withDistributions Determine whether to show "raw" or "relative" frequencies (those are the two valid values).
    		 * 
    		 * The default value is "relative" (unless there's only one document in the corpus, in which case raw frequencies are shown).
    		 */
    		withDistributions: 'relative',
    		
    		/**
    		 * @cfg {Number} bins The number of segments to use.
    		 * 
    		 * The default value will depend on the nature of the corpus:
    		 * 
    		 * - corpus has one document: the default number of bins is 10
    		 * - corpus has multiple documents:
    		 *   - corpus has up to 100 documents: the default number is the size of the corpus
    		 *   - corpus has more than 1000 documents: the default number is 100
    		 */
    		bins: 10,
    		
    		/**
    		 * @cfg {Number/Number[]/String} docIndex The index of one or more documents, as a number, or numbers separated by commas or in an array.
    		 * 
    		 * The first document's index is 0 and so on.
    		 */
    		docIndex: undefined,
    		
    		/**
    		 * @cfg {String/String[]} docId The document ID of one or more documents, as a string, or strings separated by commas or in an array.
    		 */
    		docId: undefined,
    		
    		/**
    		 * @cfg {String} mode Force the mode to be either "corpus" (distribution of terms across documents) or "document" (distribution of terms within a document); usually this is correctly set by default according to whether the corpus has one document ("document") or more than one ("corpus").
    		 */
    		mode: "corpus",
    		
    		chartType: 'barline',
    		
    		labels: false
    	},
		glyph: 'xf201@FontAwesome'
    },
    
    layout: 'fit',
    documentTermsStore: undefined,
    //segments: undefined,
    
    /**
     * @private
     */
    constructor: function(config) {
    	this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
    	Ext.apply(this, {
    		title: this.localize('title'),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                },{
                	itemId: 'reset',
                	text: this.localize("reset"),
                	tooltip: this.localize("resetTip"),
                	handler: function(btn) {
                		this.setApiParams({
                			docIndex: undefined,
                			mode: undefined,
                			query: undefined
                		});
                		this.loadCorpusTerms();
                	},
                	scope: this
				},{
					text: this.localize('display'),
					tooltip: this.localize('displayTip'),
					glyph: 'xf013@FontAwesome',
					menu: {
						listeners: {
							afterrender: function(menu) {
								var val = this.getApiParam("chartType");
								menu.items.each(function(item) {
									if (item.getItemId()==val) {
										item.addCls(item.activeCls);
									}
								})
							},
							scope: this
						},
	                    defaults: {
	                        xtype: 'menuitem',
	                        handler: function(item, checked) {
	                        	if (item.xtype=="menucheckitem") { // labels
		                        	this.setApiParam("labels", item.checked);
	                        	} else {
		                        	this.setApiParam("chartType", item.getItemId());
	                        	}
	                        	this.loadCorpusTerms();
	                        },
	                        scope: this
	                    },
	                    items: [{
	                    	xtype: 'menucheckitem',
	                    	text: this.localize('labels'),
	                        tooltip: this.localize('labelsTip'),
	                        checked: this.getApiParam("labels")===true || this.getApiParam("labels")=="true"
	                    },'-',{
	                        itemId: 'area',
	                        text: this.localize('area'),
	                        tooltip: this.localize('areaTip'),
	                        glyph: 'xe76b@Sencha-Examples'
	                    },{
	                        itemId: 'bar',
	                        text: this.localize('bar'),
	                        tooltip: this.localize('barTip'),
	                        glyph: 'xe768@Sencha-Examples'
	                    },{
	                        itemId: 'line',
	                        text: this.localize('line'),
	                        tooltip: this.localize('lineTip'),
	                        glyph: 'xe773@Sencha-Examples'
	                    },{
	                        itemId: 'stacked',
	                        text: this.localize('stacked'),
	                        tooltip: this.localize('stackedTip'),
	                        glyph: 'xe6c8@Sencha-Examples'
	                    },{
	                        itemId: 'barline',
	                        text: this.localize('barline'),
	                        tooltip: this.localize('barlineTip'),
	                        glyph: 'xe779@Sencha-Examples'
	                    }]
					}
				}]
            }]
    	});
        this.callParent(arguments);
    },
    
    listeners: {
    	loadedCorpus: function(src, corpus) {
    		this.loadCorpusTerms();
    	},
    	termsClicked: function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (Ext.isString(term)) {queryTerms.push(term);}
    			else if (term.term) {queryTerms.push(term.term);}
    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
    		});
    		this.setApiParam("query", queryTerms && queryTerms.length>0 ? queryTerms : undefined);
    		this.loadCorpusTerms();
    	},
    	corpusTermsClicked: function(src, terms) {
    		this.setApiParam("query", terms.map(function(term) {return term.getTerm()}));
    		this.loadCorpusTerms();
    	},
    	documentSelected: function(src, document) {
			this.setApiParam("docIndex", this.getCorpus().getDocument(document).getIndex());
    		this.loadDocumentTerms();
    	},
    	documentsClicked: function(src, documents) {
    		if (documents.length==1) {
    			this.fireEvent("documentSelected", this, documents[0])
    		}
    	},
    	query: function(src, query) {
			this.fireEvent("termsClicked", this, query)
    	}
    },
    
    loadCorpusTerms: function(params) {
    	// if our corpus only has one document or if we have docIndex d
    	if (
    		this.getCorpus().getDocumentsCount()<2 || // only one document
    		this.getApiParam("mode")=="document" || // in document mode
    		Array.from(this.getApiParam("docIndex") || "").length>0 // we have a docIndex defined
    		) {
    		return this.loadDocumentTerms();
    	}
    	if (!this.getApiParam("query")) {
        	this.getCorpus().getCorpusTerms().load({
        		params: {
        			limit: 5,
        			stopList: this.getApiParam("stopList")
        		},
        		callback: function(records, operation, success) {
        			if (records.length==0) {
        				if (operation && operation.error) {
        					this.showError(this.localize("noResults")+"<p style='color: red'>"+operation.error+"</p>")
        				} else {
        					this.showError(this.localize("noResults"))
        				}
        			} else {
            			this.setApiParam("query", records.map(function(r) {return r.getTerm()}))
            			this.loadCorpusTerms();
        			}
        		},
        		scope: this
        	})
    		return;
    	}
    	params = params || {};
    	//this.segments.hide();
    	var withDistributions = this.getApiParam("withDistributions");
    	Ext.applyIf(params, {
    		bins: this.getCorpus().getDocumentsCount(),
			limit: 100, // should have query, so no limit 
	    	stopList: "" // automatic queries should be stopped already
    	});
    	var docLabels = this.getCorpus().map(function(doc) {return doc.getTinyTitle()})
    	if (Ext.Array.unique(docLabels).length<docLabels.length) { // we have duplicates, add index
    		docLabels = docLabels.map(function(doc,i) {return (i+1)+")"+ doc})
    	}
    	Ext.applyIf(params, this.getApiParams());
    	this.getCorpus().getCorpusTerms().load({
    		params: params,
    		callback: function(records, operation, success) {
    			var data = [], series = [], chartType = this.getApiParam('chartType');
    			records.forEach(function(record, index) {
    	    		var term = record.get('term'), docIndex = record.get("docIndex");
    	    		var color = this.getApplication().getColorForTerm(term, true);
    	    		record.get('distributions').forEach(function(r, i) {
    	    			if (!data[i]) {
    	    				data[i] = {"index": docLabels[i]};
    	    			}
    	    			data[i]["_"+index] = withDistributions=='relative' ? r.toFixed(7) : r;
    	    			data[i]["term"+index] = term;
    	    		}, this);
    	    		
    	    		
    	    		if (chartType!='bar') {
    	    			var kinds = chartType=='barline' ? ["bar","line"] : [chartType];
    	    			kinds.forEach(function(kind) {
    	    	        	series.push({
    	    	        		type: kind=='stacked' ? 'bar' : kind,
    	    	    			title: term,
    	    	    			xField: 'index',
    	    	    			yField: '_'+index,
    	    	    			term: term,
    	    	    			colors: [color],
    	    	    			label: chartType=='barline' && kind=='bar' ? {
    	    	    				display: 'none'
    	    	    			} : {
    	    	    				field: "term"+index
    	    	    			}
    	    	        	})
    	    			}, this);
    	    		}
    			}, this);
    			
    			var terms = records.map(function(r) {return r.getTerm()})
    			var colors = terms.map(function(term) {
	    			return  this.getApplication().getColorForTerm(term, true);
	    		}, this);
	    		if (chartType=='bar') {
		    		series.push({
		    			type:'bar',
		    			title: terms,
			    		colors: colors,
		    			xField: 'index',
		    			yField: data.length>0 ? Object.keys(data[0]).filter(function(field) {return field.charAt(0)=="_"}) : undefined,
    	    			label: {
    	    				field: records.map(function(r,i) {return "term"+i;})
    	    			}
		    		})
	    		}
	    		
    	    	var store = Ext.create('Ext.data.JsonStore', {
    	    		fields: data.length>0 ? Object.keys(data[0]) : undefined,
    	    		data: data
    	    	});
    	    	
    			this.buildChart({
        			store: store,
        			series: series,
        			axes: [{
                		type: 'numeric',
                		position: 'left',
                		increment: 1,
                		title: {
                			text: this.localize(this.getApiParam("withDistributions")+"Title")
                		}
        			},{
        				type: 'category',
                		position: 'bottom',
                		title: {
                			text: this.localize("corpusTitle")
                		}
                		
        			}]
    			})
    		},
    		scope: this
    	});
  
    },
    
    getItemToolTip: function (toolTip, record, ctx) {
    	
    	var parts = ctx.field.split("_"),
    		docIndex = parts.length==2 ? ctx.index : parts[2],
    		pos = parseInt(parts[1]),
    		title = ctx.series.getTitle(),
    		term = Ext.isArray(title) ? title[pos] : title,
    		colors = ctx.series.getColors(),
    		color = colors.length==1 ? colors[0] : colors[pos];
        var html = "<span class='x-legend-item-marker' style='background:"+color+
        		"; left: 2px;'></span> <span style='padding-left: 1.2em; font-weight: bold;'>"+
        		term+"</span>: "+record.get(ctx.field)+
    			"<br/><i>"+this.getCorpus().getDocument(docIndex).getShortTitle()+"</i>"
		if (this.getApiParam("mode")=="corpus") {
    		html+="<div style='font-size: smaller'>"+this.localize('dblClickItem')
		} else {
			html+="<br/>"+this.localize('segment')+" "+(ctx.index+1)
		}
    	toolTip.setHtml(html);
    },
    

    loadDocumentTerms: function(params) {
    	if (!this.getApiParam("query")) {
        	this.getCorpus().getCorpusTerms().load({
        		params: {
        			limit: this.getCorpus().getDocumentsCount()<2 ? 5 : 2,
        			stopList: this.getApiParam("stopList")
        		},
        		callback: function(records, operation, success) {
        			this.setApiParam("query", records.map(function(r) {return r.getTerm()}))
        			this.loadDocumentTerms();
        		},
        		scope: this
        	})
    		return;
    	}
    	//this.segments.show();
    	this.setApiParam("mode", "document"); // just to be sure
    	params = params || {};
    	var withDistributions = this.getApiParam("withDistributions");
    	Ext.applyIf(params, {
			limit: 0, // always have query, so no limit, no stopList
			sort: 'termasc',
			stopList: undefined
    	});
    	var docLabels = this.getCorpus().map(function(doc) {return doc.getTinyTitle()})
    	var singleDoc;
    	if (this.getCorpus().getDocumentsCount()==1) {
    		singleDoc=this.getCorpus().getDocument(0)
    	}
    	else {
    		singleDoc=this.getCorpus().getDocument(this.getApiParam("docIndex"))
    	}
    	Ext.applyIf(params, this.getApiParams());
    	
    	this.getCorpus().getDocumentTerms().load({
    		params: params,
    		callback: function(records, operation, success) {
    			var data = [], series = [],  chartType = this.getApiParam('chartType');
    			if (!singleDoc) { // legend is easier to read if sorted by term then doc
        			records.sort(function(a,b) {
        				if (a.getTerm()==b.getTerm()) {
        					return a.getDocIndex() - b.getDocIndex()
        				}
        				return a.getTerm().localeCompare(b.getTerm())
        			})
    			}
    			records.forEach(function(record, index) {
    	    		var term = record.get('term');
    	    		var docIndex = record.get('docIndex');
    	    		var color = singleDoc ? this.getApplication().getColorForTerm(term, true) : this.getApplication().getColor(docIndex, true);
    	    		var docIndex = record.get('docIndex');
    	    		record.get('distributions').forEach(function(r, i) {
    	    			if (!data[i]) {
    	    				data[i] = {docIndex: docIndex, index: (i+1)};
    	    			}
    	    			data[i]["_"+index+"_"+docIndex] = withDistributions=='relative' ? r.toFixed(7) : r;
    	    			data[i]["term"+index] = term;
    	    		}, this);

    	    		if (chartType!='bar') {
    	    			var kinds = chartType=='barline' ? ["bar","line"] : [chartType];
    	    			kinds.forEach(function(kind) {
    	    	        	series.push({
    	    	        		type: kind=='stacked' ? 'bar' : kind,
    	    	    			title: singleDoc ? term : (docIndex+1)+") "+term,
    	    	    			xField: 'index',
    	    	    			yField: '_'+index+"_"+docIndex,
    	    	    			term: term,
    	    	    			colors: [color],
    	    	    			label: chartType=='barline' && kind=='bar' ? {
    	    	    				display: 'none'
    	    	    			} : {
    	    	    				field: "term"+index
    	    	    			}
    	    	        	})
    	    			}, this);
    	    		}
    	    		
    			}, this);
    			
	    		if (chartType=='bar') {
	    			var isOneTerm = Ext.Array.unique(records.map(function(r) {return r.getTerm()})).length;
	    			var terms = records.map(function(r) {return (1+r.get("docIndex"))	+") "+r.getTerm()})
	    			var colors = records.map(function(r) {
		    			return  isOneTerm ? this.getApplication().getColor(r.get("docIndex"), true) : this.getApplication().getColorForTerm(r.getTerm(), true);
		    		}, this);

		    		series.push({
		    			type:'bar',
		    			title: terms.length>0 ? terms : this.localize("noResults"),
			    		colors: colors,
		    			xField: 'index',
		    			yField: data.length>0 ? Object.keys(data[0]).filter(function(field) {return field.charAt(0)=="_"}) : undefined,
		    			label: {
		    				field: terms
		    			}
		    		})
	    		}

    			
    	    	var store = Ext.create('Ext.data.JsonStore', {
    	    		fields: data.length>0 ? Object.keys(data[0]) : undefined,
    	    		data: data
    	    	});

    			this.buildChart({
        			store: store,
        			series: series,
        			axes: [{
                		type: 'numeric',
                		position: 'left',
                		title: {
                			text: this.localize(this.getApiParam("withDistributions")+"Title")
                		}
        			},{
        				type: 'category',
                		position: 'bottom',
                		title: {
                			text: this.localize("segmentsTitle") + (singleDoc ? " ("+singleDoc.getShortTitle()+")" : "")
                		}
                		
        			}]
    			})
    		},
    		scope: this
    	});
  
    },

    
    buildChart: function(config) {
    	var chartType = this.getApiParam('chartType'), labels = false;
    	if (this.getApiParam("labels")===true || this.getApiParam("labels")=="true") {labels=true}
    	
    	Ext.applyIf(config, {
    		cls: this.getApiParam("mode")
    	});

    	config.series.forEach(function(serie) {
    		Ext.applyIf(serie, {
				stacked: serie.type=='bar' ? false : true,
				showInLegend: chartType=='barline' && serie.type=='line' ? false : true,
    			smooth: true,
    			showMarkers: serie.type=='bar' ? false : true,
    			marker: chartType=='barline' && serie.type=='line' ? null : {
    			    type: 'circle',
    			    radius: 2
    			},
                style: {
                    lineWidth: 1,
                    fillOpacity: chartType=='barline' && serie.type=='bar' ? .01 : 1,
                    strokeOpacity: chartType=='barline' && serie.type=='bar' ? .1 : 1
                },
                highlight: true,
                highlightCfg: {
                	scaling: serie.type=="bar" ? 1.1 : 2
                },
    			label: {
//    				display: 'none'
    			},
    			tooltip: {
                    trackMouse: true,
                    renderer: this.getItemToolTip,
                    scope: this
    			},
                listeners: {
                	itemclick: function(chart,item,event,eOpts ) {
            			if (this.clickTimer) {clearTimeout(this.clickTimer);}
            			if (this.blockClick) {return;} // set by dblclick to avoid menu disappearing
            			this.blockClick = true // block other clicks within a sec
            			Ext.defer(function() {
            				this.blockClick = false;
            			}, 1000, this);
                		if (this.getApiParam("mode")=="document") {
                			var parts = item.field.split("_"),
                				docIndex = parts[2],
                				doc = this.getCorpus().getDocument(docIndex),
                				tokens = doc.get('tokensCount-lexical'),
                				position = parseInt(item.index  * tokens / parseInt(this.getApiParam("bins")))
                			this.dispatchEvent("documentIndexTermsClicked", this, [{
                    			term: item.series.term,
                    			docIndex: parts[2],
                    			position: position
                    		}]);                			
                		} else {
                			if (this.clickTimer) {clearTimeout(this.clickTimer);}
                			var me = this;
                			this.clickTimer = setTimeout(function() {
                    			me.dispatchEvent("documentIndexTermsClicked", me, [{
                        			term: item.series.term,
                        			docIndex: item.index
                        		}]);
                			}, 300)
                			
                		}
                	},
                	itemdblclick: function(chart,item,event,eOpts )  {
            			if (this.clickTimer) {clearTimeout(this.clickTimer);}
            			// block future single clicks to allow menu to appear
            			this.blockClick = true
            			Ext.defer(function() {
            				this.blockClick = false;
            			}, 1000, this);
            			// block future clicks
                		if (this.getApiParam("mode")!="document") {
                			var m = Ext.create('Ext.menu.Menu', {
                				items: [{
                	    				text: this.localize("drillTerm"),
                	    				tooltip: this.localize("drillTermTip"),
//                	    				glyph: 'xf02d@FontAwesome',
                	    				handler: function() {
                	    					this.setApiParams({
                	    						mode: 'document',
                	    						query: item.series.term
                	    					});
                	    					this.loadDocumentTerms();
                	    				},
                	    				scope: this
                					},{
                	    				text: this.localize("drillDocument"),
                	    				tooltip: this.localize("drillDocumentTip"),
//                	    				glyph: 'xf02d@FontAwesome',
                	    				handler: function() {
                	    					this.setApiParams({
                	    						mode: 'document',
                	    						docIndex: item.index
                	    					});
                	    					this.loadDocumentTerms();
                	    				},
                	    				scope: this
                					}],
                					listeners: {
                						hide: function(m) {
                							// defer hiding otherwise click handler not called
                							Ext.defer(function() {this.destroy()}, 200, m)
                						},
                						scope: this
                					}
                			}).showAt(event.pageX, event.pageY) 
                		}
                	},
                	scope: this
                }
    		})
    		Ext.applyIf(serie.label, {
                display: 'over',
                field: 'index',
                fontSize: 11,
                translateY: chartType=='line' ? 9 : undefined
    		});
    		if (!labels) {serie.label.display="none";} // hide label 
    	}, this)
    	Ext.applyIf(config, {
    		animation: true,
    	    plugins: {
    	        ptype: 'chartitemevents',
    	        moveEvents: true
    	    },
    		legend: {
    			docked:'top',
    			listeners: {
    				itemclick: function(legend, record, dom, index) {
    					// make sure to hide related series
    					if (legend.getStore().getCount()<legend.chart.series.length && this.getApiParam("chartType")=="barline") {
        					var term = record.get("name"), disabled = record.get("disabled");
        					legend.chart.series.forEach(function(serie) {
        						if (serie.getTitle()==term) {
        							serie.setHidden(disabled);
        							
        						}
        					})
        					legend.chart.redraw(); // not working?
    					}
    				},
    				scope: this
    			}
    		},
    		interactions: ['itemhighlight','crosszoom'],
    	    listeners: {}
    	});
    	Ext.applyIf(config.listeners, {
	        itemhighlightchange: function (chart, item) {
	            chart.el.dom.style.cursor = item ? 'pointer' : '';
	        },
	        afterrender : function() {
	        	return // TODO: this seems to cause problems, perhaps not destroying properly?
	        	Ext.defer(function() { // seem to need to defer
		        	Ext.tip.QuickTipManager.register({
		        		target: this.getTargetEl().down(".x-legend-container"),
	                 	text: this.localize("toggleTip")
		        	});
	        	},1, this)
	        	
	        },
	        scope: this
    	})
    	config.axes.forEach(function(axis) {
    		Ext.applyIf(axis, {
    			title: {},
    			label: {}
    		})
    		Ext.applyIf(axis.title, {scaling: .75});
    		Ext.applyIf(axis.label, {scaling: .75});
    		if (axis.type=='category') {
    			var titles = "";
    			config.store.each(function(r) {titles+=r.get("index")})
    			if (titles.length>this.getTargetEl().getWidth()/9) {
            		Ext.applyIf(axis.label, {rotate: {degrees:-30}});
    			}
        		Ext.applyIf(axis, {
        			labelInSpan: true
        		})
    		}
    	}, this)
    	    	
    	// remove existing chart
    	this.query('chart').forEach(function(chart) {this.remove(chart, true);}, this);
    	
    	// create new chart
		var chart = Ext.create("Ext.chart.CartesianChart", config);
    	this.add(chart);
    },
    
    reloadFromChart: function() {
    	var chart = this.down('chart');
    	if (chart) {
    		var terms = [];
    		chart.series.forEach(function(serie) {
    			terms.push(serie.getTitle());
    		});
    		this.fireEvent("termsClicked", this, terms);
    	}
    }


 });
Ext.define('Voyant.panel.NoTool', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.notool',
    statics: {
    	i18n: {
    	},
    	api: {
    		tool: undefined
    	}
    },
    config: {
    	html: undefined,
    	notYetImplemented: ["Centroid","DocumentInputAdd","DocumentTypeCollocateFrequenciesGrid","EntitiesBrowser","Equalizer","FeatureClusters","Flowerbed","KwicsTagger","Lava","Mandala","MicroSearch","NetVizApplet","PaperDrill","RezoViz","Sunburst","Termometer","Ticker","TokensViz","ToolBrowser","ToolBrowserLarge","VoyeurTagline","WordCloud","VoyeurTagline","WordCountFountain"]
    },
    constructor: function() {
    	Ext.apply(this, {
    		title: this.localize('title')
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
	listeners: {
		boxready: function(container, width, height) {
			var tool = this.getApiParam("notool");

			if (tool) {
				if (Ext.isArray(tool)) {tool=tool[0]}
				
				var msg = "";
				
				// check to see if this is a tool that's recognized but not implemented
				var oldTools = this.getNotYetImplemented();
				for (var i=0, len=oldTools.length; i<len; i++) {
					if (tool==oldTools[i]) {
						return Ext.Msg.show({
						    title: this.localize('error'),
						    message: new Ext.Template(this.localize('notImplemented')).applyTemplate([tool]),
						    buttons: Ext.Msg.YESNO,
							buttonText: {yes: this.localize("currentButton"), no: this.localize("oldButton")},
						    icon: Ext.Msg.ERROR,
						    scope: this,
						    fn: function(btn) {
						    	var url;
						    	if (btn=='yes') {
						    		url = this.getNewUrl();
						    	}
						    	else {
						    		url = "http://voyant-tools.org/tool/"+tool+"/";
							    	var query = Ext.Object.fromQueryString(document.location.search)
							    	delete query['tool']
							    	queryString = Ext.Object.toQueryString(query);
							    	if (queryString) {
								    	url += "?"+queryString
							    	}
						    	}
						    	window.location.replace(url);
						    }
						});
					}
				}

				Ext.Msg.show({
				    title: this.localize('error'),
				    message: new Ext.Template(this.localize('badToolSpecified')).applyTemplate([tool]),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR,
				    scope: this,
				    fn: function(btn) {
				    	window.location.replace(this.getNewUrl());
				    }
				});
				
			}
			
			// no tool specified, so just redirect
			else if (!this.config.html) {
				Ext.Msg.show({
				    title: this.localize('error'),
				    message: this.localize('noToolSpecified'),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR,
				    scope: this,
				    fn: function(btn) {
				    	window.location.replace(this.getNewUrl());
				    }
				});
			}
		}
	},
	getNewUrl: function() {
    	var query = Ext.Object.fromQueryString(document.location.search)
    	delete query['tool']
    	queryString = Ext.Object.toQueryString(query);
    	return this.getApplication().getBaseUrl()+(queryString ? "?"+queryString : "")
	}
});
Ext.define('Voyant.panel.VoyantFooter', {
	extend: 'Ext.container.Container',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.voyantfooter',
    statics: {
    	i18n: {
    	}
    },
	height: 18,
	cls: 'x-tab-bar-default voyant-footer',
	listeners: {
		boxready: function(container, width, height) {
			var parts = [
				"<a href='"+container.getBaseUrl()+"docs/' target='voyantdocs'>"+container.localize('voyantTools')+"</a> ",
				", <a href='http://stefansinclair.name/'>St&eacute;fan Sinclair</a> &amp; <a href='http://geoffreyrockwell.com'>Geoffrey Rockwell</a>",
				" (<a href='http://creativecommons.org/licenses/by/4.0/' target='_blank'><span class='cc'>c</span></a> "+ new Date().getFullYear() +")",
				" <a class='privacy' href='"+this.getBaseUrl()+"docs/#!/guide/about-section-privacy-statement' target='top'>"+container.localize('privacy')+"</a>",
				" v. "+Voyant.application.getVersion() + (Voyant.application.getBuild() ? " ("+Voyant.application.getBuild()+")" : "")
			];
			var footer = '';
			var footerWidth = 0;
			var partWidth;
			var el = container.getEl();
			for (var i=0;i<parts.length;i++) {
				partWidth = el.getTextWidth(parts[i].replace(/data-qtip.+?-->/,">").replace(/<.+?>/g, ""));
				if (footerWidth+partWidth < width) {
					footer += parts[i];
					footerWidth += partWidth;
				}
			}
			container.update(footer);
        	Ext.tip.QuickTipManager.register({
                target: container.getTargetEl().dom.querySelector(".privacy"),
                text: this.localize('privacyMsg')
            });
		},
		beforedestroy: function(container) {
    		Ext.tip.QuickTipManager.unregister(container.getTargetEl().dom.querySelector(".privacy"));
    	}
	}
});
Ext.define('Voyant.panel.VoyantHeader', {
	extend: 'Ext.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.voyantheader',
    statics: {
    	i18n: {
    	}
    },
    constructor: function(config) {
    	Ext.apply(this, {
    		id: 'voyantheader',
    		title: '',
    		layout : 'fit',
    		html: '<div id="logo-container"></div>',
    		collapseMode : undefined,
			collapsible: true,
			animCollapse: false,
			titleCollapse: false,
			floatable: false,
			header: true,
			hideCollapseTool: true,
			listeners: {
				collapse: this.onCollapse
			},
			titleAlign: 'center'
    	});
        this.callParent(arguments);
        
        Ext.applyIf(config, {
    		moreTools: ['corpusset','scatterplot','termsradio'],
			includeTools: {
				save: true,
				plus: true,
				help: true,
				language: this.getLanguageToolMenu(),
				home: {
					type: 'home',
					tooltip: this.localize("homeTip"),
					xtype: 'toolmenu',
	                glyph: 'xf015@FontAwesome',
	        		handler: function(btn) {
	        			var panel = this.up("panel")
	        			Ext.Msg.confirm(panel.localize('home'), panel.localize('homeConfirm'), function(buttonId) {
	        				if (buttonId=='yes') {
	        					document.location.href = panel.getBaseUrl()
	        				}
	        			}, this);
	        		}
				}
			}
        })
        
    	this.mixins['Voyant.panel.Panel'].constructor.call(this, config);
    },
    
    onCollapse: function(panel) {
    	// the title may be in flux when collapsing, so call defer setting of title
    	Ext.defer(function() {this.setTitle("<img src='"+this.getBaseUrl()+"resources/images/voyant-logo-tiny.png' style='vertical-align: middle' alt='Voyant Tools' /> "+this.localize('title'))}, 10, panel)
    }
});

Ext.define('Voyant.panel.CorpusSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.VoyantTabPanel','Voyant.panel.Cirrus', 'Voyant.panel.Summary', 'Voyant.panel.CorpusTerms', 'Voyant.panel.Reader', 'Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts', 'Voyant.panel.Phrases', 'Voyant.panel.DocumentTerms','Voyant.panel.CorpusCollocates','Voyant.panel.CollocatesGraph','Voyant.panel.StreamGraph','Voyant.panel.TermsBerry'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.corpusset',
	isConsumptive: true,
	statics: {
		i18n: {
		},
		api: {
			panels: undefined
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'border',
	header: false,
	items: [{
    	region: 'west',
    	flex: 3,
    	layout: 'fit',
        moreTools: ['cirrus','corpusterms'],
        xtype: 'voyanttabpanel',
    	split: {width: 5},
    	tabBarHeaderPosition: 0,
    	items: [{
	    	xtype: 'cirrus'
    	},{
	    	xtype: 'corpusterms'
    	}, {
    		xtype: 'collocatesgraph'
    	}]
    },{
        region: 'center',
        flex: 3,
        layout: 'fit',
        xtype: 'voyanttabpanel',
    	tabBarHeaderPosition: 0,
        items: [{
	        xtype: 'reader' // termsradio added and set to default during loadedCorpus below when in non-consumptive mode
        },{
	        xtype: 'termsberry'
        }]
    }, {
    	region: 'east',
    	flex: 3,
    	layout: 'fit',
        xtype: 'voyanttabpanel',
    	split: {width: 5},
    	tabBarHeaderPosition: 0,
    	moreTools: ['trends','collocatesgraph','corpuscollocates'],
        items: [{
	    	xtype: 'trends'
        },{
	    	xtype: 'documentterms'
        }]
    }, {
    	region: 'south',
    	flex: 2,
    	split: {width: 5},
    	layout: 'border',
//    	layout: {
//    		type: 'hbox',
//    		align: 'stretch'
//    	},
    	items: [{
				layout: 'fit',
				region: 'center',
    			flex: 1,
    	        xtype: 'voyanttabpanel',
    	    	split: {width: 5},
    	    	tabBarHeaderPosition: 0,
    			moreTools: ['summary','documents','phrases'],
    			items: [{
	    			xtype: 'summary'
    			},{
	    			xtype: 'documents'
    			},{
	    			xtype: 'phrases'
    			}]
    		},{
				layout: 'fit',
				region: 'east',
    			flex: 1,
    	        xtype: 'voyanttabpanel',
    	    	split: {width: 5},
    	    	tabBarHeaderPosition: 0,
    			moreTools: ['contexts','documentterms'],
    			items: [{
	    			xtype: 'contexts'
    			},{
	    			xtype: 'bubblelines' // is set to default during loadedCorpus below when in non-consumptive mode
    			},{
	    			xtype: 'correlations'
    			}]
    	}]
    }],
    listeners: {
    	boxready: function() {
    		var panelsString = this.getApiParam("panels");
    		if (panelsString) {
    			var panels = panelsString.toLowerCase().split(",");
    			var tabpanels = this.query("voyanttabpanel");
    			for (var i=0, len=panels.length; i<len; i++) {
    				var panel = panels[i];
    				if (panel && Ext.ClassManager.getByAlias('widget.'+panel) && tabpanels[i]) {
    					var tabpanel = tabpanels[i];
    					if (tabpanel.getActiveTab().isXType(panel)) {continue;} // already selected
    					tabpanel.items.each(function(item, index) {
    						if (item.isXType(panel)) {
    							this.setActiveTab(index)
    							return false
    						}
    					}, tabpanel)
    					if (tabpanel.getActiveTab().isXType(panel)) {continue;} // already switched
    					tabpanel.getActiveTab().replacePanel(panel); // switch to specified panel
    				}
    			}
    		}
    		// add an easter egg
    		var cirrus = this.down('cirrus');
    		var me = this;
    		if (cirrus) {
    			var toolbar = cirrus.down('toolbar');
    			toolbar.add({xtype: 'tbfill'})
    			toolbar.add({
    				text: ' ',
    				listeners: {
    					click: {
    						fn: function() {
	        					me.add({
	        						region: 'north',
	        						width: '100%',
	    							html: '<div align="center"><table><tr><td><img src="http://stefansinclair.name/wordpress/wp-content/uploads/2011/07/Sinclair_Stefan_small.jpg" style="height: 60px"></td><td style="text-align: center; padding-left: 2em; padding-right: 2em;">By Athena, you found us hidden<br>up here between the panels!</td><td><img src="http://geoffreyrockwell.com/images/home_09.jpg" style="height: 60px"></td></tr></table></div>'
	        					})
	        				}, single: true
    					},
    					render: function(b) {
    						b.getTargetEl().dom.className=''
    					}
    				}
    			});
    		}
    		
    	},
    	loadedCorpus: function(src, corpus) {
    		if (this.hasCorpusAccess(corpus)==false && !this.getApiParam('panels')) {
    			var tabpanels = this.query("voyanttabpanel");
//    			tabpanels[1].add({xtype: 'termsradio'}); // reader
    			tabpanels[1].setActiveTab(1); // reader
    			tabpanels[1].getActiveTab().fireEvent("loadedCorpus", src, corpus); // make sure to load corpus
    			tabpanels[4].setActiveTab(1); // contexts
    		}
    		if (corpus.getDocumentsCount()>30) {
    			var bubblelines = this.down('bubblelines');
    			if (bubblelines) {
    				bubblelines.up('voyanttabpanel').remove(bubblelines)
    			}
    		}
    	},
    	panelChange: function(src) {
    		var panels = [];
    		this.query("voyanttabpanel").forEach(function(item) {
    			panels.push(item.getActiveTab().xtype)
    		})
    		this.getApplication().setApiParam('panels', panels.join(','))
    	}
    }
})
Ext.define('Voyant.panel.ScatterSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.ScatterPlot','Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.scatterset',
	statics: {
		i18n: {
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'hbox',
	header: false,
	items: [{
    	flex: 3,
    	height: '100%',
        xtype: 'scatterplot'
    },{
    	split: {width: 5},
        flex: 1,
    	height: '100%',
        layout: 'vbox',
        defaults: {
        	width: '100%',
        	flex: 1
        },
        items: [{
        	xtype: 'documents',
        	collapsible: true
        },{
        	xtype: 'trends',
        	collapsible: true
        },{
        	xtype: 'contexts',
        	collapsible: true
        }]
    }]
})
Ext.define('Voyant.panel.Subset', { 
	
	
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel','Voyant.util.Downloadable'],
	alias: 'widget.subset',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		documentFilename: ['pubDate','title'],
    		documentFormat: 'SOURCE'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	options: {
    		xtype: 'stoplistoption'
    	},
		inDocumentsCountOnly: false,
		stopList: 'auto',
		store: undefined
    },
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);    	
    },
    
    
    initComponent: function(config) {
        var me = this;

        Ext.applyIf(me, {
        	introHtml: '',
        	fieldItems: [{
	        		xtype: 'querysearchfield',
	        		fieldLabel: this.localize('titleLabel'),
	        		tokenType: 'title'
        		},{
	        		xtype: 'querysearchfield',
	        		fieldLabel: this.localize('authorLabel'),
	        		tokenType: 'author'
        		},{
	        		xtype: 'querysearchfield',
	        		fieldLabel: this.localize('lexicalLabel')
        	}],
        	fieldColumns: 2
        });
        
        Ext.applyIf(me, {
        	intro: {
        		margin: '5 0 5 0',
        		layout: 'center',
        		items: {
        			itemId: 'intro',
            		html: me.introHtml
        		}
        	},
        	fields: {
				xtype: 'container',
        		layout: 'center',
        		items: {
    				xtype: 'container',
        			maxWidth: 1200,
        			layout: {
        				type: 'table',
        				columns: me.fieldColumns
        			},
        			// wrap in another container otherwise the tip won't work
        			items: me.fieldItems.map(function(item) {return {
        				xtype: 'container',
            			defaults: {
            				margin: '5 10 5 10',
                    		inDocumentsCountOnly: me.getInDocumentsCountOnly(),
                    		stopList: me.getStopList(),
                    		showAggregateInDocumentsCount: true,
                    		isDocsMode: true,
                    		flex: 1,
                    		maxWidth: 800,
                    		labelAlign: 'right'
            			},
        				items: Ext.applyIf(item, {
        					fieldLabel: me.localize((item.tokenType ? item.tokenType : 'lexical')+'Label')
        				})
        			}}, this)
        		}
        	},
        	foot: {
        		layout: 'center',
        		margin: '20 0 0 0',
        		items: {
        			xtype: 'container',
        			layout: {
        				type: 'hbox',
        				align: 'middle'
        			},
        			defaults: {
    	        		margin: '0 5 0 5',
//    	        		scale: 'large',
    	        		width: 200
        			},
        			items:  [{
    	        		xtype: 'button',
    	        		itemId: 'export',
	                    glyph: 'xf08e@FontAwesome',
    	        		text: this.localize('sendToVoyantButton'),
    	        		handler: me.handleSendToVoyant,
    	        		scope: me
            		},{
    	        		xtype: 'button',
				    	glyph: 'xf019@FontAwesome',
    	        		itemId: 'download',
    	        		text: this.localize('downloadButton'),
    	        		handler: me.handleExport,
    	        		scope: me
            		},{
            			xtype: 'container',
            			hidden: true,
            			itemId: 'statuscontainer',
            			layout: 'vbox',
            			items: [{
            				itemId: 'status',
            				bodyStyle: 'text-align: center',
            				width: 200
            			},{
            				xtype: 'container',
            				width: 200,
            				items: {
            	    			xtype: 'sparklineline',
            	    			chartRangeMin: 0,
            	    			itemId: 'sparkline',
            	    			margin: '0 0 0 10',
            	    			values: [1,1],
            	    			height: 20,
            	    			width: 200
            				}
            			}]
            		}]
        		}
        	}
        })

        Ext.applyIf(me, {
        	items: [me.intro, me.fields, me.foot]
        });
        
    	me.on('loadedCorpus', function(src, corpus) {
    		me.getStore().setCorpus(corpus);
    		if (me.getInitialConfig('introHtml')==undefined && me.getInitialConfig('intro')==undefined) {
    			 me.queryById('intro').setHtml(corpus.getString())
    		}
    	}, me);
    	
    	me.on('query', function(src, queries) {
    		this.performAggregateQuery(this.getAggregateQuery());
    	});
    	
    	me.setStore(Ext.create('Voyant.data.store.DocumentQueryMatches'))
        me.callParent([config]);
        
    },
    
    handleSendToVoyant: function() {
    	if (!this.getStore().lastOptions || !this.getStore().lastOptions.params.query) {
    		// there's currently no query, so give the option of opening the current corpus in a new window
    		Ext.Msg.alert(this.localize('sendToVoyantButton'), new Ext.XTemplate(this.localize('sendToVoyantNoQuery')).apply([this.getBaseUrl()+"?corpus="+this.getStore().getCorpus().getId()]))
    	} else {
    		// try spawning a new corpus with the query
    		var me = this;
        	this.mask("Creating corpus");
        	this.getStore().load({
        		params: {
        			query: this.getStore().lastOptions.params.query,
        			createNewCorpus: true
        		},
        		callback: function(records, operation, success) {
        			me.unmask();
        			if (success && records && records.length==1) {
            			var corpus = operation.getProxy().getReader().metaData;
        				var url = me.getBaseUrl()+"?corpus="+corpus;
        				me.openUrl(url);
        			}
        		}
        	})
    	}
    },
    
    handleExport: function() {
    	if (!this.getStore().lastOptions || !this.getStore().lastOptions.params.query) {
    		this.downloadFromCorpusId(this.getStore().getCorpus().getId());
    	} else {
    		var record = this.getStore().getAt(0);
    		if (this.getStore().lastOptions.params.query && record && record.getCount()==0) {
    			this.showMsg({message: this.localize('noMatches')})
    		} else {
    	    	this.getStore().load({
    	    		params: {
    	    			query: this.getStore().lastOptions.params.query,
    	    			createNewCorpus: true,
    	    			temporaryCorpus: true
    	    		},
    	    		callback: function(records, operation, success) {
    	    			if (success && records && records.length==1) {
    	    	    		this.downloadFromCorpusId(operation.getProxy().getReader().metaData);
    	    			}
    	    		},
    	    		scope: this
    	    	})
    		}
    	}
    },
    
    openDownloadCorpus: function(corpus) {
		var url = this.getTromboneUrl()+"?corpus="+corpus+"&tool=corpus.CorpusExporter&outputFormat=zip"+
			"&zipFilename=DownloadedVoyantCorpus-"+corpus+".zip"+
			(this.getApiParam("documentFormat") ? "&documentFormat="+this.getApiParam("documentFormat") : '')+
			(this.getApiParam("documentFilename") ? "&documentFilename="+this.getApiParam("documentFilename") : '')
		this.openUrl(url)
    },

    performAggregateQuery: function(query) {
    	var me = this, statuscontainer = me.queryById('statuscontainer'), status = me.queryById('status'), spark = me.queryById('sparkline');
		if (statuscontainer) {statuscontainer.show();}
		if (status) {status.setHtml(new Ext.XTemplate('{0:plural("documents")} matching.').apply([0]))}
		if (spark) {spark.setValues([0,0]);}
    	if (query) {
        	var docsCount = this.getStore().getCorpus().getDocumentsCount();
        	this.getStore().load({
        		params: {
        			query: query,
        			withDistributions: true,
        			bins: docsCount > 100 ? 100 : docsCount 
        		},
        		callback: function(records, operation, success) {
        			var exp = me.queryById('export');
        			var spark = me.queryById('sparkline');
        			if (success && records && records.length==1) {
        				if (status) {
        					status.setHtml(new Ext.XTemplate('{0:plural("document")} matching.').apply([records[0].getCount()]))
        				}
        				if (spark) {
            				spark.setValues(records[0].getDistributions())
        				}
        			}
        		}
        	})
    	} else if (this.getStore().lastOptions) { // set query to undefined so that send/export buttons work properly
    		this.getStore().lastOptions.params.query = undefined
    	}
    },
    
    getAggregateQuery: function() {
		var aggregateQueries = [];
		Ext.ComponentQuery.query('field', this).forEach(function(field) {
			if (field.getTokenType && field.getValue) {
				var tokenType = field.getTokenType();
				var vals = Ext.Array.from(field.getValue());
				if (vals.length>0) {
					if (vals.length>0) {
        				aggregateQueries.push("+("+vals.map(function(val) {
        					return tokenType+":"+val
        				}).join("|")+")");
					}
				}
			}
		})
		return aggregateQueries.join(" ");
    }
})

Ext.define('Voyant.panel.CollocatesSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.ScatterPlot','Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.collocatesset',
	statics: {
		i18n: {
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'vbox',
	header: false,
	items: [{
		layout: 'hbox',
		align: 'stretch',
		width: '100%',
		height: '100%',
		flex: 2,
        defaults: {
        	width: '100%',
        	height: '100%',
        	flex: 1,
        	frame: true,
        	border: true
        },
        items: [{
        	xtype: 'corpusterms'
        },{
        	xtype: 'documentterms'
        },{
        	xtype: 'corpuscollocates'
        }]
    },{
    	width: '100%',
    	height: '100%',
    	split: {width: 5},
		layout: 'hbox',
		flex: 3,
        defaults: {
        	width: '100%',
        	height: '100%',
        	flex: 1,
        	frame: true,
        	border: true
        },
        items: [{
        	xtype: 'contexts'
        },{
        	xtype: 'collocatesgraph'
        }]
    }]
})
Ext.define('Voyant.panel.BubblelinesSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.Bubblelines','Voyant.panel.Contexts', 'Voyant.panel.Reader'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.bubblelinesset',
	statics: {
		i18n: {
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'vbox',
	header: false,
	items: [{
		width: '100%',
		height: '100%',
    	xtype: 'bubblelines',
    	flex: 5
    },{
    	width: '100%',
    	height: '100%',
    	split: {width: 5},
		layout: 'hbox',
		flex: 4,
        defaults: {
        	width: '100%',
        	height: '100%',
        	flex: 1,
        	frame: true,
        	border: true
        },
        items: [{
        	xtype: 'contexts'
        },{
        	xtype: 'reader'
        }]
    }]
})
Ext.define('Voyant.panel.CustomSet', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.customset',
	statics: {
		i18n: {
		},
		api: {
			layout: undefined,
			tableLayout: undefined
		},
		glyph: 'xf17a@FontAwesome'
	},
	header: false,
	height: '100%',
	width: '100%',
	
    constructor: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // force api load
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
		if (this.getApiParam('layout')) {
			Ext.apply(this,{
				layout: 'border',
				items: []
			})
		} else if (this.getApiParam('tableLayout')) {
			this.initTableLayout();
		}
		this.callParent()
    },
	
	listeners: {
		loadedCorpus: function(src, corpus) {
			if (this.getApiParam('layout')) { // not sure why, but we seem to need to fire event for child panels
				this.query("panel").forEach(function(p) {
					p.fireEvent("loadedCorpus", src, corpus);
				})
			}
		},
		boxready: function(panel) {
			if (this.getApiParam('layout')) {
				this.initBorderLayoutComponents();
			} else if (this.getApiParam('tableLayout')) {
		    	this.doTableSizing();
		    	this.on('resize', function(panel, newwidth, newheight, oldwidth, oldheight) {
					if (oldwidth !== undefined && oldheight !== undefined) {
			        	var widthRatio = newwidth/oldwidth;
			        	var heightRatio = newheight/oldheight;
			        	this.doTableSizing(widthRatio, heightRatio);
					}
				}, this);
			} else {
				this.showError(this.localize('noLayoutSpecified'))
			}
		}
		
	},
	
	initBorderLayoutComponents: function() {
        var layoutString = decodeURI(this.getApiParam('layout'))
        	.replace(/r1/g, 'region')
	        .replace(/i1/g, 'items')
	        .replace(/s1/g, 'split')
	        .replace(/c1/g, 'collapsible')
	        .replace(/c2/g, 'collapsed')
	        .replace(/w1/g, 'width')
	        .replace(/h1/g, 'height')
	        .replace(/p1/g, '%')
	        .replace(/"x1":"/g, '"xtype":"')
	        .replace(/c3/g, 'center')
	        .replace(/n1/g, 'north')
	        .replace(/e1/g, 'east')
	        .replace(/s2/g, 'south')
	        .replace(/w2/g, 'west')
	    	.replace(/"xtype":"(\w+)"/g, function(match, tool) {
            	if (!Ext.ClassManager.getByAlias("widget."+tool.toLowerCase())) {
		            if (tool=="Links") {tool="CollocatesGraph";}
		            else if (tool=="CorpusGrid") {tool="Documents";}
		            else if (tool=="CorpusSummary") {tool="Summary";}
		            else if (tool=="CorpusTypeFrequenciesGrid") {tool="CorpusTerms";}
		            else if (tool=="DocumentInputAdd") {tool="CorpusTerms";}
		            else if (tool=="DocumentTypeCollocateFrequenciesGrid") {tool="CorpusTerms";}
		            else if (tool=="DocumentTypeFrequenciesGrid") {tool="DocumentTerms";}
		            else if (tool=="DocumentTypeKwicsGrid") {tool="Contexts";}
		            else if (tool=="TypeFrequenciesChart") {tool="Trends";}
		            else if (tool=="VisualCollocator") {tool="CollocatesGraph";}
		            else {tool="NoTool"}
            	}
            	return '"xtype":"'+tool.toLowerCase()+'"'+(tool=="NoTool" ? ',"html":"'+new Ext.Template(panel.localize('noSuchTool')).applyTemplate([tool])+'"' : '')
		    })
        
        var items;
        try {
            items = Ext.decode(layoutString);
        } catch (e) {
            items = {region: 'center', html: '<div>Error constructing layout:'+e+'</div>'};
        }
        
        if (items == null) {
        	items = {region: 'center', html: '<div>Error: no layout information found.</div>'}
        }
        
        this.addBorderLayouts(items);

        this.on("add", function(custom, cmp) {
        	cmp.on("boxready", function(cmp) {
//        		cmp.query("panel").forEach(function(p) {
//        			custom;
////        			debugger
//        		})
        	})
        })
        this.add(items);
//        .on("boxready", function() {
//        	debugger
//            if (this.getCorpus()) { // we may have loaded the corpus after the layout, so refire the event
//            	this.getApplication().dispatchEvent("loadedCorpus", this.getApplication(), corpus);
//            }
//        })
        
	},
	
	addBorderLayouts: function(items) {
    	var size = Ext.getBody().getSize();
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (Ext.isString(item.width)) {
            	item.width = Math.round(size.width * parseInt(item.width) / 100);
            } else if (Ext.isString(item.height)) {
            	item.height = Math.round(size.height * parseInt(item.height) / 100);
            }
            if (item.items && item.items.length > 1) {
                item.layout = 'border';
                this.addBorderLayouts(item.items);
            } else {
                item.layout = 'fit';
            }
        }
	},
	
	initTableLayout: function() {
    	Ext.suspendLayouts();
    	
    	var tableLayout = decodeURI(this.getApiParam('tableLayout'));
    	if (tableLayout && tableLayout.charAt(0)!="{" && tableLayout.charAt(0)!="[") {
    		var cells = [];
    		tableLayout.split(/,\s*/).forEach(function(cell) {
    			cells.push(/^"'/.test(cell) ? cell : '"'+cell+'"');
    		});
    		tableLayout = "["+cells.join(",")+"]"; // treat as simple comma-separated string
    	}
    	var layout = Ext.decode(tableLayout);
    	if (Ext.isArray(layout)) {
    		layout = {
        		cells: layout
        	};
    	}
    	if (!layout.numCols && layout.cells && Ext.isArray(layout.cells)) {
    		if (layout.cells.length < 3) {
    			layout.numCols = layout.cells.length;
    		} else if (layout.cells.length < 5) {
    			layout.numCols = Math.ceil(layout.cells.length / 2);
    		} else {
    			layout.numCols = Math.ceil(layout.cells.length / 3);
    		}
    	}
        if (layout.numCols != null && layout.cells && Ext.isArray(layout.cells)) {
        	var items = [];
        	for (var i = 0; i < layout.cells.length; i++) {
        		var cell = layout.cells[i];
        		if (Ext.isObject(cell)) {
        			cell.cellWidth = parseFloat(cell.width) || undefined;
        			cell.cellHeight = parseFloat(cell.height) || undefined;
        			delete cell.width;
        			delete cell.height;
            		items.push(cell);
        		} else if (Ext.isArray(cell)) {
        			var colspan = 1, rowspan = 1; xtype = undefined;
        			if (cell[0] && Ext.isNumber(cell[0])) {
        				colspan = cell[0];
        				cell.shift();
        			}
        			if (cell[0] && Ext.isString(cell[0])) {
        				xtype = cell[0];
        				cell.shift();
        			}
        			if (cell[0] && Ext.isNumber(cell[0])) {
        				rowspan = cell[0];
        			}
        			if (xtype) {
        				items.push({
        					colspan: colspan,
        					rowspan: rowspan,
        					xtype: xtype
        				})
        			}
        		} else if (Ext.isString(cell)) {
        			items.push({
        				xtype: cell,
        				colspan: 1,
        				rowspan: 1
        			})
        		}
        	}
        	
        	Ext.apply(this, {
        		layout: {
        			type: 'table',
        			width: '100%',
    				height: '100%',
        			columns: layout.numCols,
        			tableAttrs: {
            			style: {
            				width: '100%',
            				height: '100%'
            			}
            		},
            		tdAttrs: {
            			style: {
            				padding: '0px',
            				verticalAlign: 'top'
            			}
            		}
        		},
        		defaults: { // place holder values to ensure that the children are rendered
            		width: 10,
            		height: 10,
            		border: true
            	},
        		items: items
        	});
        } else {
        	this.showError("badTableLayoutDefinition")
        }
    	
    	Ext.resumeLayouts();		
	},
	doTableSizing: function(widthRatio, heightRatio) {
    	var sizeMap = {};
    	
    	var table = this.getTargetEl().down(".x-table-layout");
    	var tableSize = table.getSize(false);
    	
    	var rows = table.dom.rows;
    	for (var i=0; i<rows.length; i++) {
    		var cells = rows[i].cells;
    		for (var j=0; j<cells.length; j++) {
    			var cell = cells[j];
    			var cellEl = Ext.get(cell);
    			var panelEl = cellEl.down('.x-panel');
    			var cmpId = panelEl.id;
    			
    			var size;
    			if (widthRatio !== undefined && heightRatio !== undefined) {
    				size = panelEl.getSize(false);
    				size.width = size.width * widthRatio;
            		size.height = size.height * heightRatio;
            		// FIXME multiple resize calls gradually reduce size
    			} else {
    				var sizeObj = cellEl.getSize(false);
    				
    				var cmp = Ext.getCmp(cmpId);
    				var widthPercent = cmp.initialConfig.cellWidth;
    				var heightPercent = cmp.initialConfig.cellHeight;
    				
    				if (widthPercent !== undefined) {
    					sizeObj.width = tableSize.width * (widthPercent/100);
    					cellEl.setWidth(sizeObj.width);
    				}
    				if (heightPercent !== undefined) {
    					sizeObj.height = tableSize.height * (heightPercent/100);
    					cellEl.setHeight(sizeObj.height);
    				}
    				
    				size = sizeObj; 
    			}
    			
    			sizeMap[cmpId] = size;
    		}
    	}
    	
    	for (var id in sizeMap) {
    		var size = sizeMap[id];
    		Ext.getCmp(id).setSize(size);
    	}

    	this.updateLayout();
	}
})
Ext.define('Voyant.panel.Veliza', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
    xtype: 'veliza',
	autoScroll: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		script: '',
    		message: undefined
    	},
		glyph: 'xf0e6@FontAwesome'
    },
    config: {
    	previous: []
    },
    
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        var me = this;
        Ext.apply(this, {
    		title: this.localize('title'),
    		glyph: 'xf0e6@FontAwesome',
    	    layout: {
    	        type: 'border',
    	        align: 'stretch'
    	    },
    		items: [{
    			itemId: 'chat',
	    		html: "<form class='chat'></form>",
	    		region: 'center',
	    		flex: 2,
	    		autoScroll: true
    		},{
    			itemId: 'script',
    			xtype: 'form',
    			region: 'east',
    			split: true,
    			title: this.localize('scriptEditor'),
        	    layout: {
        	        type: 'vbox',
        	        align: 'stretch'
        	    },
    			items: [{
    				html: new Ext.XTemplate(this.localize('scriptIntro')).apply([me.getBaseUrl()+"docs/#!/guide/veliza"])
    			},{
    				xtype: 'textarea',
    				name: 'editor',
    				fieldStyle: "white-space: pre",
    				value: me.getApiParam('script'),
    				flex: 1,
    				listeners: {
    					afterrender: function(editor) {
    						editor.mask(me.localize('loadingScript'));
    						Ext.Ajax.request({
    							url: me.getTromboneUrl(),
    							params: {
    								tool: 'corpus.Veliza',
    								script: me.getApiParam('script')
    							}
    						}).then(function(response) {
    							var obj = Ext.decode(response.responseText);
    							if (obj && obj.veliza && obj.veliza.script) {
    								editor.setValue(obj.veliza.script);
    								editor.resetOriginalValue();
    							} else if (obj && obj.veliza && obj.veliza.id) {
    								me.setApiParam('script', obj.veliza.id);
    							} else {
    								me.showError(me.localize('unableFetchScript'));
    							}
    							editor.unmask()
    						}, function(response) {
    							me.showError(response)
    						})
    					},
    					scope: this
    				}
    			}],
    			collapsed: true,
    			collapsible: true,
    			flex: 1
    		}],
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			xtype: 'textfield',
        			itemId: 'chatfield',
        			emptyText: this.localize("typeAndEnter"),
        			flex: 1,
        			listeners: {
                        specialkey: function(field, e){
                            if (e.getKey() == e.ENTER) {
                            	me.handleUserSentence(field.getValue())
                            	field.setValue("");
                            }
                        }
                    }
                },{
        			xtype: 'button',
        			text: this.localize('send'),
        			handler: function() {
        				var tf = this.up("toolbar").down('textfield');
        				me.handleUserSentence(tf.getValue(), false);
        				tf.setValue('');
        			}
        		},{
        			xtype: 'button',
        			text: this.localize('fromCorpus'),
        			handler: function() {
        				me.handleUserSentence("", true)
        			}
        		}]
    		}]
        })
             
        this.callParent();
        
    	this.on('boxready', function(cmp) {
    		cmp.addSentence("fromThem", "Hello, I'm Veliza, and I'm here to talk to you about your texts (you may know my sister <a href='https://en.wikipedia.org/wiki/ELIZA' target='_blank'>Eliza</a> she's a famous psychotherapist). I'm just learning to talk about text documents, but please, let me know about any anxieties you're feeling about your texts. Type a message in the box below and hit enter. Or, if you're feeling playful, hit the <i>from text</i> bottom in the lower right-hand corner to fetch a sentence from the corpus.");
    		this.sendApiParamMessage();
    	})

    }, 
    
    sendApiParamMessage: function() {
		if (this.getApiParam('message')) {
			if (this.getCorpus()) {
				var sentences = Ext.Array.from(this.getApiParam('message'));
				var sentence = sentences.shift();
				if (sentence) {
					if (sentences) {
						this.setApiParam("message", sentences);
					}
					this.handleUserSentence(sentence, undefined, true)
					
				}
			} else {
				// try to wait for the corpus to be loaded
				Ext.defer(this.sendApiParamMessage, 100, this, [true])
			}
		}
    },
    
    
    handleUserSentence: function(sentence, fromCorpus, noScroll) {
    	sentence = sentence.trim();
    	if (sentence || fromCorpus) {
    		if (sentence) {
    	    	this.addSentence("myMessage", sentence);
    		}
	    	this.mask();
    		var me = this;
    		var editor = this.getComponent('script').down('textarea');
    		Ext.Ajax.request({
    			url: this.getApplication().getTromboneUrl(),
    			params: {
    				corpus: me.getCorpus() ? me.getCorpus().getId() : undefined,
    				tool: 'corpus.Veliza',
    				sentence: sentence,
    				//previous: this.getPrevious(),
    				fromCorpus: fromCorpus ? true : false,
    				script: editor.isDirty() ? editor.getValue() : this.getApiParam('script'),
    				noCache: Ext.id()
    			},
    		    success: function(response, opts) {
    		    	me.unmask();
    		    	var response = Ext.decode(response.responseText);
    		    	if (response.veliza.id) {
    		    		me.setApiParam('script', response.veliza.id);
    		    		editor.resetOriginalValue();
    		    	}
    		    	var veliza = response.veliza.response;
    		    	var hidden = veliza.match(/<\!-- (.+?) -->/);
    		    	if (hidden) {
    		    		var json =  Ext.decode(hidden[1]);
    		    		for (key in json.params) {
    		    			json.params[key] = json.params[key].trim();
    		    		}
    		    		veliza += "<br/><iframe width='"+(json.width ? json.width : '100%')+"' height='"+(json.height ? json.height : '250px')+"' src='"+me.getApplication().getBaseUrl()+'tool/'+json.tool+'/?corpus='+me.getCorpus().getId()+'&minimal=true&'+Ext.Object.toQueryString(json.params)+"'></iframe>"
    		    	}
    		    	var sentence = response.veliza.sentence;
    		    	me.setPrevious(response.veliza.previous);

    		    	if (fromCorpus) {
    		    		meta = response.veliza.docIndex > -1 ? me.getCorpus().getDocument(response.veliza.docIndex).getShortLabel() : undefined;
    		    		me.addSentence("myMessage", sentence, meta);
        			    	Ext.Function.defer(function() {
                		    	this.addSentence("fromThem", veliza);
                		    	if (!noScroll) {
                    		    	this.body.scroll('b', Infinity)                		    		
                		    	}
        			    	}, 500, me);
    		    	} else {
        		    	me.addSentence("fromThem", veliza);
        		    	if (!noScroll) {
            		    	me.body.scroll('b', Infinity)                		    		
        		    	}
    		    	}
    		    	if (me.getApiParam("message")) { // any more messages to show?
    		    		me.sendApiParamMessage();
    		    	}
    		    },
    		    failure: function(response, opts) {
    		    	me.showResponseError("Unable to get response from Veliza.", response);
    		    }
    		})
    	}
    },

    addSentence: function(speaker, sentence, meta) {
    	var body = this.getComponent('chat').body;
    	var el = body.down("form").insertHtml('beforeEnd', '<div class="message"><div class="'+speaker+'"><p>'+sentence+'</p>'+(meta ? "<date>"+meta+"</date>" : "")+'</div></div>', true);
    	body.scroll('b', Infinity);
    }
});
Ext.define('Voyant.panel.WordTree', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.wordtree',
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		stopList: 'auto',
    		context: 10,
    		limit: 100
    	},
		glyph: 'xf0e8@FontAwesome'
    },
    
    config: {
    	tree: undefined,
    	kwicStore: undefined,
    	options: {xtype: 'stoplistoption'},
    	numBranches: 5,
    	lastClick: 1
    },
    
    doubleClickDelay: 300,
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                },
                	'<span data-qtip="'+this.localize('poolTip')+'" class="info-tip">'+this.localize('pool')+"</span>"
                , {
                	xtype: 'slider',
                	itemId: 'poolSlider',
                	minValue: 10,
                	value: 100,
                	maxValue: 1000,
                	increment: 5,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getApiParam('limit'));
                		},
                		changecomplete: function(slider, newValue) {
                			this.setApiParam('limit', slider.getValue());
                			this.reload();
                		},
                		scope: this
                	}
                }, 
                	'<span data-qtip="'+this.localize('branchesTip')+'" class="info-tip">'+this.localize('branches')+"</span>"
    			,{
                
                	xtype: 'slider',
                	itemId: 'branchesSlider',
                	minValue: 2,
                	value: 5,
                	maxValue: 15,
                	increment: 1,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getNumBranches());
                		},
                		changecomplete: function(slider, newValue) {
                			this.setNumBranches(slider.getValue());
                			this.reload();
                		},
                		scope: this
                	}
                },
            	'<span data-qtip="'+this.localize('contextTip')+'" class="info-tip">'+this.localize('context')+"</span>"
            	, {
                	xtype: 'slider',
                	itemId: 'contextSlider',
                	minValue: 3,
                	value: 10,
                	maxValue: 20,
                	increment: 2,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getApiParam('context'));
                		},
                		changecomplete: function(slider, newValue) {
                			this.setApiParam('context', slider.getValue());
                			this.reload();
                		},
                		scope: this
                	}
                }]
    		}]
        });
        
        this.setKwicStore(Ext.create('Voyant.data.store.Contexts', {
        	parentPanel: this,
        	proxy: {
        		extraParams: {
                	stripTags: 'all'            			
        		}
        	},
        	listeners: {
        		load: function(store, records, success, operation) {
        			if (success) {
        				this.parseRecords(records);
        			}
        		},
        		scope: this
        	}
        }));
        
        this.on('loadedCorpus', function(src, corpus) {
        	var corpusTerms = corpus.getCorpusTerms({autoLoad: false});
    		corpusTerms.load({
    		    callback: function(records, operation, success) {
    		    	if (success && records.length>0) {
    		    		var firstTerm = records[0].getTerm();
    		    		this.setRoot(firstTerm);
    		    	}
    		    },
    		    scope: this,
    		    params: {
    				limit: 1,
    				query: this.getApiParam('query'),
    				stopList: this.getApiParam('stopList')
    			}
        	});
        }, this);
        
        this.on('query', function(src, query) {
    		if (query !== undefined && query != '') {
    			this.setRoot(query);
    		}
        }, this);
        
        this.on('termsClicked', function(src, terms) {
        	var queryTerms = [];
    		terms.forEach(function(term) {
    			if (Ext.isString(term)) {queryTerms.push(term);}
    			else if (term.term) {queryTerms.push(term.term);}
    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
    		});
    		this.setRoot(queryTerms);
		}, this);
        
        this.on('documentTermsClicked', function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.setRoot(queryTerms);
    	}, this);
        
        this.on('resize', function(panel, width, height) {
        	var tree = this.getTree();
        	if (tree !== undefined) {
        		tree.visWidth(width).visHeight(height);
        		// TODO preserve expanded branches
        		tree.redraw();
        	}
		}, this);
        
        this.on('boxready', this.initGraph, this);
        
        this.callParent(arguments);
    },
    
    parseRecords: function(records) {
    	var parsedRecords = [];
		for (var i = 0; i < records.length; i++) {
			var r = records[i];
			var pr = {
				id: i,
				prefix: r.getLeft().trim().split(/\s+/),
				hit: r.getMiddle(),
				suffix: r.getRight().trim().split(/\s+/)
			};
			parsedRecords.push(pr);
		}
		
		// find top tokens and sort records by them
		var prefixTokenCounts = {};
		var suffixTokenCounts = {};
		for (var i = 0; i < parsedRecords.length; i++) {
			var pr = parsedRecords[i];
			var prefixToken = pr.prefix[pr.prefix.length-1];
			var suffixToken = pr.suffix[0];
			if (prefixTokenCounts[prefixToken]) {
				prefixTokenCounts[prefixToken]++;
			} else {
				prefixTokenCounts[prefixToken] = 1;
			}
			if (suffixTokenCounts[suffixToken]) {
				suffixTokenCounts[suffixToken]++;
			} else {
				suffixTokenCounts[suffixToken] = 1;
			}
		}
		
		var sortableTokens = [];
		for (var i = 0; i < parsedRecords.length; i++) {
			var pr = parsedRecords[i];
			var prefixToken = pr.prefix[pr.prefix.length-1];
			var suffixToken = pr.suffix[0];
			
			sortableTokens.push({
				suffix: suffixToken, suffixCount: suffixTokenCounts[suffixToken],
				prefix: prefixToken, prefixCount: prefixTokenCounts[prefixToken]
			});
			
		}
		
		var prioritizeSuffix = false;
		// multi-sort
		sortableTokens.sort(function(a, b) {
			var s1 = a.suffixCount;
			var s2 = b.suffixCount;
			
			var p1 = a.prefixCount;
			var p2 = b.prefixCount;
			
			if (prioritizeSuffix) {
				if (s1 > s2) return -1;
				if (s1 < s2) return 1;
				if (p1 > p2) return -1;
				if (p1 < p2) return 1;
			} else {
				if (p1 > p2) return -1;
				if (p1 < p2) return 1;
				if (s1 > s2) return -1;
				if (s1 < s2) return 1;
			}
			
			return 0;
		});
		
		var len = Math.min(this.getNumBranches(), sortableTokens.length);
		var topSuffixTokens = [];
		var topPrefixTokens = [];
		for (var i = 0; i < len; i++) {
			topSuffixTokens.push(sortableTokens[i].suffix);
			topPrefixTokens.push(sortableTokens[i].prefix);
		}
		
		// use top tokens to limit results
		var prefixes = [], hits = [], suffixes = [], ids = [];
		for (var i = 0; i < parsedRecords.length; i++) {
			var parsedRecord = parsedRecords[i];
			if (topSuffixTokens.indexOf(parsedRecord.suffix[0]) != -1 || topPrefixTokens.indexOf(parsedRecord.suffix[0]) != -1) {
				prefixes.push(parsedRecord.prefix);
				hits.push(parsedRecord.hit);
				suffixes.push(parsedRecord.suffix);
				ids.push(parsedRecord.id);
			}
		}
		
		var caseSensitive = false;
		var fieldNames = ["token", "POS"];
		var fieldDelim = "/";
		var distinguishingFieldsArray = ["token", "POS"];
		this.getTree().setupFromArrays(prefixes, hits, suffixes, ids, caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);
		
		if (!this.getTree().succeeded()) {
			this.toastInfo({
   				html: this.localize("emptyText"),
   				align: 'bl'
   			});
		}
    },
    
    initGraph: function() {
    	var el = this.getLayout().getRenderTarget();
    	var w = el.getWidth();
    	var h = el.getHeight();
    	
    	var dt = new doubletree.DoubleTree();
    	dt.init('#'+el.getId())
    		.visWidth(w).visHeight(h)
    		.handlers({
    			click: this.clickHandler.bind(this)
    		});
    	
    	this.setTree(dt);
    	
    	// explicitly set dimensions
//    	el.setWidth(el.getWidth());
//    	el.setHeight(el.getHeight());
    },
    
    clickHandler: function(node) {
    	var now = new Date().getTime();
    	if (this.getLastClick() && now-this.getLastClick()<this.doubleClickDelay) {
    		this.setLastClick(1);
    		var terms = [], parent = node;
        	while (parent != null) {
        		terms.push(parent.name);
        		parent = parent.parent;
        	}
        	this.getApplication().dispatchEvent('termsClicked', this, [terms.reverse().join(" ")]);
    	} else {
    		this.setLastClick(now);
    	}
    },
    
//    doubleClickHandler: function(node) {
//// dispatch phrase click instead of recentering (which can be done with search)
////    	this.setRoot(node.name);
//    },
//    
    setRoot: function(query) {
    	this.setApiParam('query', this.stripPunctuation(query));
		this.getKwicStore().load({params: this.getApiParams()});
    },
    
    reload: function() {
    	var query = this.getApiParam('query');
    	if (query !== undefined) {
    		this.setRoot(query);
    	}
    },
    
    stripPunctuation: function(value) {
    	if (Ext.isString(value)) return value.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');
    	else {
    		var values = [];
    		value.forEach(function(v) {
    			values.push(v.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, ''));
    		});
    		return values;
    	}
    	return '';
    }
});


Ext.define('Voyant.panel.WordWall', {
    extend: 'Ext.panel.Panel',
    mixins: ['Voyant.panel.Panel','Voyant.util.DiacriticsRemover'],
    alias: 'widget.wordwall',
    statics: {
        i18n: {
        },
        api: {
            limit: 500,
            stopList: 'auto'
        },
        glyph: 'xf1e0@FontAwesome'
    },
    
    config: {
        visId: undefined,
        vis: undefined,
        simulation: undefined, // force layout
        nodes: undefined, // svg nodes
        tempNodes: undefined, // used to calculate text size and bounding boxes
        zoom: undefined,

        terms: undefined,
        segments: undefined,

        filterOutUniqueTerms: true, // whether to remove terms that don't appear in all segments

        currentSegment: undefined,
        segmentTerms: undefined,
        segmentTermsQueue: [],

        segmentDelay: 5000, // delay before displaying new segment data
        segmentDelayTimer: undefined,
        
        webWorker: undefined,
        isSimulating: false, // are we running a webworker simulation?
        
        transitionTime: 2000, // time to transition between old and new nodes
        isTransitioning: false, // are we transitioning between nodes?
        

        minFreq: undefined,
        maxFreq: undefined,
        letterDistribution: undefined,
        
        frequencyScale: undefined,

        xForceStrength: 0.2,
        yForceStrength: 0.1,
        
        chargeStrength: -75,
        chargeDistance: 100,

        minFontSize: 7,
        maxFontSize: 60
    },

    count: 0,

    MIN_TERMS: 10,
    MAX_TERMS: 2000,
    
    MIN_SCALING: 1,
    MAX_SCALING: 20,
    
    debugMsg: false,

    constructor: function(config) {
        this.mixins['Voyant.util.DiacriticsRemover'].constructor.apply(this, arguments);

        this.setVisId(Ext.id(null, 'wordwall_'));

        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        Ext.apply(this, {
            title: this.localize('title'),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [this.localize('terms'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: this.MIN_TERMS,
                    maxValue: this.MAX_TERMS,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getApiParam('limit'));
                        },
                        changecomplete: function(slider, newValue) {
                            this.setApiParam('limit', slider.getValue());
                            this.initLoad();
                        },
                        scope: this
                    }
                },this.localize('delay'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 1,
                    maxValue: 60,
                    increment: 1,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getSegmentDelay()/1000);
                        },
                        changecomplete: function(slider, newValue) {
                            this.setSegmentDelay(slider.getValue()*1000);
                            this.restartSegmentTimer();
                        },
                        scope: this
                    }
                },this.localize('transition'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 100,
                    maxValue: 5000,
                    increment: 1,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getTransitionTime());
                        },
                        changecomplete: function(slider, newValue) {
                            this.setTransitionTime(slider.getValue());
                        },
                        scope: this
                    }
                },this.localize('xStrength'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 0,
                    maxValue: 1000,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getXForceStrength()*1000);
                        },
                        changecomplete: function(slider, newValue) {
                            this.setXForceStrength(slider.getValue()/1000);
                        },
                        scope: this
                    }
                },this.localize('yStrength'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 0,
                    maxValue: 1000,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getYForceStrength()*1000);
                        },
                        changecomplete: function(slider, newValue) {
                            this.setYForceStrength(slider.getValue()/1000);
                        },
                        scope: this
                    }
                },this.localize('chargeStrength'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: -1000,
                    maxValue: 0,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getChargeStrength());
                        },
                        changecomplete: function(slider, newValue) {
                            this.setChargeStrength(slider.getValue());
                        },
                        scope: this
                    }
                },this.localize('chargeDistance'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 0,
                    maxValue: 1000,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getChargeDistance());
                        },
                        changecomplete: function(slider, newValue) {
                            this.setChargeDistance(slider.getValue());
                        },
                        scope: this
                    }
                },{
                    xtype: 'button',
                    text: this.localize('stop'),
                    handler: function(b) {
                        if (b.getText() === this.localize('stop')) {
                            clearInterval(this.getSegmentDelayTimer());
                            b.setText(this.localize('start'))
                        } else {
                            this.restartSegmentTimer();
                            b.setText(this.localize('stop'));
                        }
                    },
                    scope: this
                },{
                    itemId: 'status',
                    xtype: 'tbtext',
                    text: ''
                }]
            }]
        });
        
        this.on('loadedCorpus', function(src, corpus) {
            if (this.isVisible()) {
                this.initLoad();
            }
        }, this);
        
        this.on('resize', function(panel, width, height) {
            var vis = Ext.get(this.getVisId());
            if (vis) {
                var el = this.body;//this.getLayout().getRenderTarget();
                var elHeight = el.getHeight();
                var elWidth = el.getWidth();
                
                vis.el.dom.setAttribute('width', elWidth);
                vis.el.dom.setAttribute('height', elHeight);
//                this.getSimulation()
//                    .force('x', d3.forceX(elWidth/2))
//                    .force('y', d3.forceY(elHeight/2));
            }
        }, this);
        
        this.callParent(arguments);
    },
    
    initVis: function() {
        var el = this.getLayout().getRenderTarget();
        el.update('');
        var width = el.getWidth();
        var height = el.getHeight();

        var svg = d3.select(el.dom).append('svg').attr('id',this.getVisId()).attr('class', 'wordWall').attr('width', width).attr('height', height);
        var g = svg.append('g');
        this.setVis(g);
        
        this.setNodes(g.append('g').attr('class', 'nodes').selectAll('.node'));

        this.setTempNodes(g.append('g').attr('class', 'tempNodes').selectAll('text'));

        if (this.getWebWorker() === undefined) {
            this.setWebWorker(new Worker(this.getBaseUrl()+'resources/d3/WordWallWorker.js'));
            this.getWebWorker().onmessage = this.handleWebWorkerMessage.bind(this);
        }
    },

    initLoad: function() {
        this.initVis();
        
        this.count = 0;

        var params = this.getApiParams();
        params.tool = 'corpus.CorpusSegmentTerms';
        
        Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: params,
            success: function(response) {
                var data = Ext.decode(response.responseText);
                this.setSegments(data.corpusSegmentTerms.segments);

                var terms = data.corpusSegmentTerms.terms;
                if (this.getFilterOutUniqueTerms()) {
                    terms = terms.filter(function(el, index) { return el.rawFreqs.indexOf(0) == -1 });
                }

                this.setTerms(terms);
                
                this.setCurrentSegment(this.getSegments().length);
                this.getNextSegment();

                this.restartSegmentTimer();
            },
            failure: function(response) {
                if (this.debugMsg) console.log('failed', response);
            },
            scope: this
        })
    },

    restartSegmentTimer: function() {
        clearInterval(this.getSegmentDelayTimer());

        this.setSegmentDelayTimer(setInterval(function() {
            this.updateNodePositions();
        }.bind(this), this.getSegmentDelay()));
    },

    getNextSegment: function() {
        var index = this.getCurrentSegment();
        index++;
        if (index >= this.getSegments().length) {
            index = 0;
        }
        this.setCurrentSegment(index);
        if (this.debugMsg) console.log('getNextSegment', index);
        this.processTermsForSegment(this.getCurrentSegment());
    },

    processTermsForSegment: function(segmentIndex) {
        var min = Number.MAX_VALUE;
        var max = Number.MIN_VALUE;
        var letterDistMap = {a:0,b:0,c:0,d:0,e:0,f:0,g:0,h:0,i:0,j:0,k:0,l:0,m:0,n:0,o:0,p:0,q:0,r:0,s:0,t:0,u:0,v:0,w:0,x:0,y:0,z:0};

        this.getTerms().forEach(function(d) {
            d.id = this.idGet(d.term);
            // d.value = d.rawFreqs.reduce(function(sum, value) {
            //     return sum+value;
            // });
            d.value = d.rawFreqs[segmentIndex];
            if (d.value > 0) {
                if (d.value < min) {
                    min = d.value;
                }
                if (d.value > max) {
                    max = d.value;
                }

                d.title = d.term+' ('+d.value+')';

                var firstLetter = this.removeDiacritics(d.term.charAt(0)).toLowerCase();
                d.letter = firstLetter;
                if (letterDistMap[firstLetter] === undefined) {
                    letterDistMap[firstLetter] = 0;
                }
                letterDistMap[firstLetter]++;
            }
        }, this);

        this.setSegmentTerms(this.getTerms().filter(function(d) {
            return d.value > 0;
        }));

        this.setMinFreq(min);
        this.setMaxFreq(max);

        var letterDist = [];
        for (var letter in letterDistMap) {
            var count = letterDistMap[letter];
            var percent = count / this.getTerms().length;
            letterDist.push({letter: letter, percent: percent});
        }
        letterDist.sort(function(a, b) {
            if (a.letter < b.letter) return -1;
            if (a.letter > b.letter) return 1;
            return 0;
        });
        this.setLetterDistribution(letterDist);

        this.calculateNodeSizes(this.getSegmentTerms());
        this.runSimulation(this.getSegmentTerms());
    },

    // determine each node's font size and bounding box and store them for later use
    calculateNodeSizes: function(terms) {
        var nodes = this.getTempNodes().data(terms, function(d) { return d.id; });
        
        var fontSizer = function(value) {
            var t = Math.min(1, terms.length / this.MAX_TERMS);
            var exponent = t*2+1;
            value = this.getFrequencyScale()(value);
            var val = d3.scalePow().exponent(exponent).domain([0, 1]).range([this.getMinFontSize(), this.getMaxFontSize()])(value);
            return val;
        }.bind(this);

        var bboxTotal = 0;

        nodes.enter().append('text')
            .attr('fill-opacity', 0)
            .attr('font-family', function(d) { return 'Arial'; })//return me.getApplication().getFeatureForTerm('font', d.term); })
            .attr('font-size', function(d) {
                var fontSize = fontSizer(d.value);
                d.fontSize = fontSize;
                return fontSize;
            })
            .text(function(d) { return d.term; })
            .each(function(d) {
                var bbox = this.getBBox();
                d.bbox = {};
                d.bbox.x = bbox.x;
                d.bbox.y = bbox.y;
                d.bbox.width = bbox.width;
                d.bbox.height = bbox.height;

                bboxTotal += bbox.width*bbox.height;
            })
            .remove();

        var el = this.getLayout().getRenderTarget();
        var width = el.getWidth();
        var height = el.getHeight();

        // adapt font size to available space
        var availableSpace = width*height;
        if (bboxTotal > availableSpace*0.6) {
            this.setMaxFontSize(this.getMaxFontSize()*0.9);
            this.setMinFontSize(this.getMinFontSize()*0.9);
            this.calculateNodeSizes(terms);
        } else if (bboxTotal < availableSpace*0.5) {
            this.setMaxFontSize(this.getMaxFontSize()*1.1);
            this.setMinFontSize(this.getMinFontSize()*1.1);
            this.calculateNodeSizes(terms);
        }
    },

    runSimulation: function(terms) {
        this.setIsSimulating(true);

        var el = this.getLayout().getRenderTarget();
        var width = el.getWidth();
        var height = el.getHeight();

        // pass all the info to the worker
        if (this.debugMsg) console.time("runSim");
        this.getWebWorker().postMessage({
            terms: terms,
            width: width,
            height: height,
            minFreq: this.getMinFreq(),
            maxFreq: this.getMaxFreq(),
            xForceStrength: this.getXForceStrength(),
            yForceStrength: this.getYForceStrength(),
            chargeDistance: this.getChargeDistance(),
            chargeStrength: this.getChargeStrength(),
            letterDistribution: this.getLetterDistribution()
        });
    },

    handleWebWorkerMessage: function(event) {
        switch (event.data.type) {
            case "progress":
                var t = event.data.progress;
                var percent = parseInt(t * 100);
                this.getDockedItems()[1].getComponent('status').update(percent+'%');
                break;
            case "msg":
                if (this.debugMsg) console.log(event.data.msg);
                break;
            case "end":
                if (this.debugMsg) console.timeEnd("runSim");
                // TODO adjust segment delay if it's less than the runSim time
                this.getDockedItems()[1].getComponent('status').update('');
                this.setIsSimulating(false);
                this.getSegmentTermsQueue().push(event.data.nodes);
                break;
        }
    },

    updateNodePositions: function() {
        if (this.getIsTransitioning()) {
            Ext.Function.defer(this.updateNodePositions, 100, this);
        } else {
            this.count++;
            var nodes = this.getSegmentTermsQueue().shift();
            if (this.debugMsg) console.log('queue length', this.getSegmentTermsQueue().length);
            if (nodes === undefined) {
                if (this.debugMsg) console.log('no nodes', this.count);
                if (this.getIsSimulating() === false) {
                    this.getNextSegment();
                }
            } else {
                this.setIsTransitioning(true);
                if (this.getSegmentTermsQueue().length == 0) {
                    this.getNextSegment();
                }
                
                var nodeUpdate = this.getNodes().data(nodes, function(d) { return d.id; });

                nodeUpdate.transition().duration(this.getTransitionTime()).attr('transform', function(d) {
                    var x = d.x;
                    var y = d.y;
                    return 'translate('+x+','+y+')';
                });

                var nodeEnter = nodeUpdate.enter().append('g')
                    .attr('class', 'node')
                    .attr('id', function(d) { return d.id; })
                    .attr('transform', function(d) {
                        var x = d.x;
                        var y = d.y;
                        return 'translate('+x+','+y+')';
                    })
                    .attr('fill-opacity', 0);

                nodeEnter.append('title').text(function(d) { return d.title; });

                nodeEnter.append('text')
                    .attr('font-family', function(d) { return 'Arial'; })//return me.getApplication().getFeatureForTerm('font', d.term); })
                    .attr('font-size', function(d) { return d.fontSize; })
                    .attr('fill', function(d) { return this.getApplication().getFeatureForTerm('color', d.term); }.bind(this))
                    .style('cursor', 'pointer')
                    .style('user-select', 'none')
                    .attr('alignment-baseline', 'middle')
                    .text(function(d) { return d.term; });

                nodeEnter.transition().duration(this.getTransitionTime()).attr('fill-opacity', 1);

                var allNodes = nodeEnter.merge(nodeUpdate);

                allNodes.select('text').transition().duration(this.getTransitionTime())
                    .attr('font-size', function(d) { return d.fontSize; });

                nodeUpdate.exit().transition().duration(this.getTransitionTime()).attr('fill-opacity', 0).remove();

                setTimeout(function() {
                    this.setIsTransitioning(false);
                }.bind(this), this.getTransitionTime());

                this.setNodes(allNodes);
            }
        }
    },

    updateMinFreq: function() {
        this.setFrequencyScale(d3.scaleLog().domain([this.getMinFreq(), this.getMaxFreq()]).range([0, 1]));
    },

    updateMaxFreq: function() {
        this.setFrequencyScale(d3.scaleLog().domain([this.getMinFreq(), this.getMaxFreq()]).range([0, 1]));
    },

    zoomToFit: function(paddingPercent, transitionDuration) {
    	var bounds = this.getVis().node().getBBox();
    	var width = bounds.width;
    	var height = bounds.height;
    	var midX = bounds.x + width/2;
    	var midY = bounds.y + height/2;
    	var svg = this.getVis().node().parentElement;
    	var fullWidth = svg.clientWidth;
    	var fullHeight = svg.clientHeight;
    	var scale = (paddingPercent || 0.8) / Math.max(width/fullWidth, height/fullHeight);
    	var translate = [fullWidth/2 - scale*midX, fullHeight/2 - scale*midY];
 
    	d3.select(svg)
    		.transition()
    		.duration(transitionDuration || 500)
    		.call(this.getZoom().transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale));
    },
    
    idGet: function(term) {
        return term.replace(/\W/g, '_');
    }
    
});
// heavy lifting for the LDA from https://github.com/mimno/jsLDA with tweaks to fit into a Voyant object scope

Ext.define('Voyant.panel.Topics', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel','Voyant.widget.LiveSearchGrid'],
	alias: 'widget.topics',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		numTopics: 25,
    		limit: 10,
    		iterations: 100,
    		perDocLimit: 1000,
    		query: undefined
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	/**
    	 * @private
    	 */
    	options: [{xtype: 'stoplistoption'},{
	        xtype: 'numberfield',
	        name: 'perDocLimit',
	        fieldLabel: 'maximum words per document',
	        labelAlign: 'right',
	        value: 1000,
	        minValue: 1,
	        step: 100,
	        listeners: {
    	        afterrender: function(field) {
    	        	var win = field.up("window");
    	        	if (win && win.panel) {
        	        	field.setValue(parseInt(win.panel.getApiParam('perDocLimit')))
    	        		field.setFieldLabel(win.panel.localize("perDocLimit"))
    	        	}
    	        },
		        change: function(field, val) {
		        	var win = field.up("window");
		        	if (val>5000 && win && win.panel) {
		        		win.panel.toastInfo({
		        			html: win.panel.localize("perDocLimitHigh"),
		        			anchor: win.getTargetEl(),
		        			align: 'tr',
		        			maxWidth: 400
		        		})
		        	}
		        }
	        }
	    },{
	        xtype: 'numberfield',
	        name: 'iterations',
	        fieldLabel: 'iterations per run',
	        labelAlign: 'right',
	        value: 100,
	        minValue: 1,
	        maxValue: 10000,
	        step: 50,
	        listeners: {
    	        afterrender: function(field) {
    	        	var win = field.up("window");
    	        	if (win && win.panel) {
        	        	field.setValue(parseInt(win.panel.getApiParam('iterations')))
    	        		field.setFieldLabel(win.panel.localize("iterations"))
    	        	}
    	        }
	        }
	    }],
    	
    	corpus: undefined,
    	
    	documentTopicSmoothing : 0.1,
    	topicWordSmoothing : 0.01,
    	vocabularySize : 0,
    	 vocabularyCounts : {},
    	 stopwords : {},
    	 docSortSmoothing : 10.0,
    	 sumDocSortSmoothing : 10.0 * 25, // update?
    	 requestedSweeps : 0,
    	 wordTopicCounts : {},
    	 topicWordCounts : [],
    	 tokensPerTopic : [],
    	 topicWeights : Array(25),
    	 documents: [],
    	 progress: undefined,
    	 totalIterations: 0,
    	 exportGridAll: false
    	
    },
    
    zeros: function(count, val) {
    	val = val || 0;
    	var ret = Array(count)
    	for (var i=0; i<count; i++) {ret[i]=val;}
    	return ret;
    },
    
    constructor: function(config ) {
    	var me = this;
    	Ext.apply(this, {
    		title: this.localize('title'),
    		layout: {
    	        type: 'hbox',
    	        pack: 'start',
    	        align: 'stretch'
    	    },
	        store: {
	            fields: ['topic', 'scores'],
	            data: []
	        },
    		columns: [{
    			text: this.localize("topic"),
    			tooltip: this.localize("topicTip"),
    			flex: 3,
        		dataIndex: 'topic',
                sortable: false
            },{
                xtype: 'widgetcolumn',
                text: this.localize("scores"),
                tooltip: this.localize("scoresTip"),
                flex: 1,
                dataIndex: 'scores',
                widget: {
                    xtype: 'sparklineline',
                    tipTpl: new Ext.XTemplate('{[this.getDocumentTitle(values.x,values.y)]}', {
                    	getDocumentTitle: function(docIndex, score) {
                    		return this.panel.getCorpus().getDocument(docIndex).getTitle()+"<br>coverage: "+Ext.util.Format.number(score*100, "0,000.0")+"%"
                    	},
                    	panel: me 
                    })
               }
            }],
            dockedItems: {
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items:[
                       '<span class="info-tip" data-qtip="'+this.localize('searchTip')+'">'+this.localize('search')+'</span>'
                    ,{
                    xtype: 'textfield',
                    name: 'searchField',
                    hideLabel: true,
                    width: 80,
                    listeners: {
                        change: {
                            fn: me.onTextFieldChange,
                            scope: me,
                            buffer: 500
                        }
                    }
                },
                	'<span class="info-tip" data-qtip="'+this.localize('limitTermsTip')+'">'+this.localize('limitTerms')+'</span>'
                ,{ 
	    			width: 80,
                    hideLabel: true,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: 1,
	            	maxValue: 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("limit")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			this.postSweep();
	            		},
	            		scope: this
	            	}
                },
                	'<span class="info-tip" data-qtip="'+this.localize('numTopicsTip')+'">'+this.localize('numTopics')+'</span>'
                ,{ 
	    			width: 80,
                    hideLabel: true,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: 1,
	            	maxValue: 200,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("numTopics")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({numTopics: newvalue});
	            			this.loadFromExistingDocuments();
	            		},
	            		scope: this
	            	}
                },{
            		text: new Ext.Template(this.localize('runIterations')).apply([100]),
            		itemId: 'iterations',
					glyph: 'xf04b@FontAwesome',
            		tooltip: this.localize('runIterationsTip'),
            		handler: this.runIterations,
            		scope: this
            	},{
                	xtype: 'tbtext',
                	itemId: 'done'
                },{xtype: 'tbfill'}, {
	    			xtype: 'tbtext',
	    			html: this.localize('adaptation')
	    		}]
            }
    	});

        this.callParent(arguments);
        

    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.resetData();
        
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		this.setCorpus(corpus);
    		if (this.rendered) {
    			this.initialize();
    		}
    		else {
    			this.on("afterrender", function() {
    				this.initialize();
    			}, this)
    		}

    	});
    	
    	this.on('query', function(src, query) {
    		this.setApiParam('query', query);
    		this.updateSearchResults();
    	})
    	
    },
    
    loadStopwords: function() {
    	this.mask(this.localize("loadingStopWords"));
    	Ext.Ajax.request({
    	    url: this.getTromboneUrl(),
    	    params: {
        		tool: 'resource.KeywordsManager',
    			stopList: this.getApiParam('stopList'),
    			corpus: this.getCorpus() ? this.getCorpus().getAliasOrId() : undefined
    	    },
    	    success: function(response, req) {
    	    	this.unmask();
    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	var stopwords = {};
    	    	json.keywords.keywords.forEach(function(stop) {
    	    		stopwords[stop]=1;
    	    	})
    	    	this.setStopwords(stopwords);
    	    	this.loadDocuments();
    	    },
    	    scope: this
    	})
    },
    
    loadDocuments: function() {
    	this.mask(this.localize("loadingDocuments"));
    	var corpus = this.getCorpus();
    	if (corpus) {
        	Ext.Ajax.request({
        	    url: this.getTromboneUrl(),
        	    params: {
            		tool: 'corpus.DocumentTokens',
        			corpus: corpus.getAliasOrId(),
        			outputFormat: "text",
        			template: "docTokens2idsAndText",
        			limit: 0,
        			noOthers: true,
        			perDocLimit: corpus.getDocumentsCount()==1 ? undefined : parseInt(this.getApiParam('perDocLimit'))
        		},
        	    success: function(response, req) {
        	    	this.unmask();
        	    	this.mask(this.localize("parsingDocuments"));
        	    	var lines = response.responseText.trim().split(/(\r\n|\r|\n)/);
        	    	if (lines.length==1) { // one document, so segment
        	    		var parts = lines[0].split(': ');
        	    		if (parts.length>1) {
            	    		var doc = corpus.getDocument(parts[0]);
            	    		var allwords = parts[1].split(' ');
            	    		var totalWords = doc.getLexicalTokensCount();
            	    		if (totalWords<10) {
            	    			bins = totalWords
            	    		} else if (totalWords<1000) {
            	    			bins = 10
            	    		} else {
            	    			bins = 100
            	    		}
            	    		var bins = 10;
            	    		var wordsPerBin = Math.floor(allwords.length/bins);
            	    		for (var i=0; i<bins; i++) {
            	    			var text = allwords.slice(i*wordsPerBin,(i*wordsPerBin)+wordsPerBin).join(" ");
                	    		this.parseLine(parts[0]+"-"+i+"\t"+parts[0]+"-"+i+"\t"+text);
            	    		}
        	    		}
        	    	} else {
            	    	lines.forEach(function(line) {
            	    		var parts = line.split(': ');
            	    		if (parts.length>1) {
                	    		var doc = corpus.getDocument(parts[0]);
                	    		this.parseLine(parts[0]+"\t"+doc.getTinyLabel()+"\t"+parts[1]);
            	    		}
            	    	}, this);
        	    	}
        	    	this.unmask();
        	    	this.runIterations();
        	    },
        	    scope: this
        	})
    	}
    },
    
    resetData: function() {
    	var numTopics = parseInt(this.getApiParam('numTopics'));
	 	this.setVocabularyCounts({});
		this.setSumDocSortSmoothing(this.getDocSortSmoothing()*numTopics);
		this.setRequestedSweeps(0);
		this.setWordTopicCounts({});
		this.setTopicWordCounts([]);
		this.setTokensPerTopic(this.zeros(numTopics));
		this.setTopicWeights(this.zeros(numTopics));
		this.setDocuments([]);
		this.setTotalIterations(0);
    },
    
    loadFromExistingDocuments: function() {

    	// not quite efficient, but at least we don't have to reload from server
    	var data = this.getDocuments().map(function(doc) {return doc.id+"\t"+doc.date+"\t"+doc.originalText});
    	
    	this.resetData(); // reset all data before starting over
    	
    	data.forEach(function(doc) {
    		this.parseLine(doc);
    	}, this);
    	
    	this.runIterations();
    },
    
    runIterations: function() {
    	var sweeps = this.getRequestedSweeps();
    	var iterations = parseInt(this.getApiParam('iterations'));
    	sweeps+=parseInt(iterations);
    	this.setTotalIterations(this.getTotalIterations()+iterations);
    	this.setRequestedSweeps(sweeps)
    	if (!this.getProgress()) {
    		var progress = Ext.MessageBox.show({
    			title: this.localize("runningIterations"),
    			message: new Ext.Template(this.localize('runningIterationsCount')).apply([sweeps]),
    			progress: true,
    			progressText: '',
    			target: sweeps,
    			customUpdateProgress: function(val) {
     			   this.updateProgress((this.config.target-val)*this.config.target, " iterations");
     		   	}
    		});
    		this.setProgress(progress);
    		this.updateProgress(sweeps);
    	}
    	this.sweep();
    },
    
    updateProgress: function(sweeps) {
    	var progress = this.getProgress(), sweeps = this.getRequestedSweeps();
    	if (progress) {
    		var target = progress.cfg.target;
        	var val = (target-sweeps)/target;
        	progress.updateProgress(val, (parseInt(val)*100) +"% done");
    	}
    },
    
    sweep: function() {

    	var startTime = Date.now(), numTopics = parseInt(this.getApiParam('numTopics')),
    		vocabularySize = this.getVocabularySize(), topicWordSmoothing = this.getTopicWordSmoothing(),
    		tokensPerTopic = this.getTokensPerTopic(), documents = this.getDocuments(),
    		wordTopicCounts = this.getWordTopicCounts(), topicWeights = this.getTopicWeights(), 
    		documentTopicSmoothing = this.getDocumentTopicSmoothing()
    		
    		
    	var topicNormalizers = this.zeros(numTopics);
    	for (var topic = 0; topic < numTopics; topic++) {
    		topicNormalizers[topic] = 1.0 / (vocabularySize * topicWordSmoothing + tokensPerTopic[topic]);
    	}

    	for (var doc = 0; doc < documents.length; doc++) {
    		var currentDoc = documents[doc];
    		var docTopicCounts = currentDoc.topicCounts;
    		
    		for (var position = 0; position < currentDoc.tokens.length; position++) {
    			var token = currentDoc.tokens[position];
    			if (token.isStopword) { continue; }

    			tokensPerTopic[ token.topic ]--;
    			var currentWordTopicCounts = wordTopicCounts[ token.word ];
    			currentWordTopicCounts[ token.topic ]--;
    			if (currentWordTopicCounts[ token.topic ] == 0) {
    			  //delete(currentWordTopicCounts[ token.topic ]);
    			}
    			docTopicCounts[ token.topic ]--;
    			topicNormalizers[ token.topic ] = 1.0 / (vocabularySize * topicWordSmoothing + tokensPerTopic[ token.topic ]);

    			var sum = 0.0;
    			for (var topic = 0; topic < numTopics; topic++) {
    				if (currentWordTopicCounts[ topic ]) {
    				  topicWeights[topic] =
    				    (documentTopicSmoothing + docTopicCounts[topic]) *
    				    (topicWordSmoothing + currentWordTopicCounts[ topic ]) *
    					topicNormalizers[topic];
    				}
    				else {
    				  topicWeights[topic] =
    				    (documentTopicSmoothing + docTopicCounts[topic]) *
    					topicWordSmoothing *
    					topicNormalizers[topic];
    				}
    				sum += topicWeights[topic];
    			}
    		    
    			// Sample from an unnormalized discrete distribution
    			var sample = sum * Math.random();
    		    var i = 0;
    		    sample -= topicWeights[i];
    		    while (sample > 0.0) {
    		      i++;
    		      sample -= topicWeights[i];
    		 	}
    			token.topic = i;
    			
    			tokensPerTopic[ token.topic ]++;
    			if (! currentWordTopicCounts[ token.topic ]) {
    				currentWordTopicCounts[ token.topic ] = 1;
    			}
    			else {
    				currentWordTopicCounts[ token.topic ] += 1;
    			}
    			docTopicCounts[ token.topic ]++;
    			
    			topicNormalizers[ token.topic ] = 1.0 / (vocabularySize * topicWordSmoothing + tokensPerTopic[ token.topic ]);
    		}
    	}
    	
    	var sweeps = this.getRequestedSweeps()-1;
    	this.setRequestedSweeps(sweeps);
    	var progress = this.getProgress();
    	if (sweeps>0) {
    		this.updateProgress(sweeps);
    		Ext.defer(this.sweep, 0, this);
    	} else {
    		progress.close();
    		this.setProgress(undefined);
    		this.postSweep();
    	}
    	
    },
    
    postSweep: function(){
    	this.sortTopicWords();
    	var store = this.getStore();
    	var done = new Ext.Template(this.localize('totalDone')).apply([Ext.util.Format.number(parseInt(this.getTotalIterations()), "0,000")]);
    	this.down('#done').setHtml(done);
    	
		var numTopics = parseInt(this.getApiParam('numTopics')),
			topicWordCounts = this.getTopicWordCounts(),
			data = [], documents = this.getDocuments(),
			docSortSmoothing = this.getDocSortSmoothing(),
			sumDocSortSmoothing = this.getSumDocSortSmoothing();
			
		var limit = parseInt(this.getApiParam('limit'));
		for (var topic = 0; topic < numTopics; topic++) {
			var scores = documents.map(function (doc, i) {
//				console.warn(doc, doc.topicCounts[topic], docSortSmoothing, doc.tokens.length, sumDocSortSmoothing);
				  return (doc.topicCounts[topic] + docSortSmoothing) / (doc.tokens.length + sumDocSortSmoothing);
			});
			
			data.push({
				topic: this.topNWords(topicWordCounts[topic], limit),
				scores: scores
			})
		}
    	store.loadData(data)
    },
    
    topNWords: function(wordCounts, n) { return wordCounts.slice(0,n).map( function(d) { return d.word; }).join(" "); },
    
    sortTopicWords: function() {
    	var topicWordCounts = this.getTopicWordCounts(), numTopics = parseInt(this.getApiParam('numTopics')),
    		wordTopicCounts = this.getWordTopicCounts();

    	  topicWordCounts = [];
    	  for (var topic = 0; topic < numTopics; topic++) {
    	    topicWordCounts[topic] = [];
    	  }

    	  for (var word in wordTopicCounts) {
    	    for (var topic in wordTopicCounts[word]) {
    	      topicWordCounts[topic].push({"word":word, "count":wordTopicCounts[word][topic]});
    	    }
    	  }

    	  for (var topic = 0; topic < numTopics; topic++) {
    	    topicWordCounts[topic].sort(this.byCountDescending);
    	  }

    	  this.setTopicWordCounts(topicWordCounts);
    },
    
    byCountDescending: function(a,b) {return b.count - a.count; },
    
    initialize: function() {
    	// make sure we have the right number of iterations in our label (especially after an options change)
    	var val = new Ext.Template(this.localize('runIterations')).apply([Ext.util.Format.number(parseInt(this.getApiParam('iterations')), "0,000")]);
    	var iterations = this.down('#iterations').setText(val)
    	this.loadStopwords();
    },
    
    parseLine: function ( line ) {
    	
    	// for simplicity, create locally scoped variables of these
    	var stopwords = this.getStopwords(), vocabularyCounts = this.getVocabularyCounts(),
	    	tokensPerTopic = this.getTokensPerTopic(), vocabularySize=this.getVocabularySize(),
	    	vocabularyCounts = this.getVocabularyCounts(), documents = this.getDocuments(),
	    	numTopics = parseInt(this.getApiParam('numTopics')),
	    	wordTopicCounts = this.getWordTopicCounts();
    	
    	  if (line == "") { return; }
    	  var docID = documents.length;
    	  var docDate = "";
    	  var fields = line.split("\t");
    	  var text = fields[0];  // Assume there's just one field, the text
    	  if (fields.length == 3) {  // If it's in [ID]\t[TAG]\t[TEXT] format...
    	    docID = fields[0];
    	    docDate = fields[1]; // do not interpret date as anything but a string
    	    text = fields[2];
    	  }

    	  var tokens = [];
    	  var rawTokens = text.toLowerCase().split(' '); // xsl should only use space between tokens
    	  if (rawTokens == null) { return; }
    	  var topicCounts = this.zeros(numTopics);

    	  rawTokens.forEach(function (word) {
    	    if (word !== "") {
    	      var topic = Math.floor(Math.random() * numTopics);
    		  
    		  if (word.length <= 2) { stopwords[word] = 1; }
    		  
    		  var isStopword = stopwords[word];
    		  if (isStopword) {
    			  // Record counts for stopwords, but nothing else
    			  if (! vocabularyCounts[word]) {
    				  vocabularyCounts[word] = 1;
    			  }
    			  else {
    			  	vocabularyCounts[word] += 1;
    			  }
    		  }
    		  else {
    		      tokensPerTopic[topic]++;
    		      if (! wordTopicCounts[word]) {
    		        wordTopicCounts[word] = {};
    		        vocabularySize++;
    		        vocabularyCounts[word] = 0;
    		      }
    		      if (! wordTopicCounts[word][topic]) {
    		        wordTopicCounts[word][topic] = 0;
    		      }
    		      wordTopicCounts[word][topic] += 1;
    		      vocabularyCounts[word] += 1;
    		      topicCounts[topic] += 1;
    	      }
    	      tokens.push({"word":word, "topic":topic, "isStopword":isStopword });
    	    }
    	  });
    	  this.setVocabularySize(vocabularySize); // set this scalar
    	  
    	  documents.push({ "originalOrder" : documents.length, "id" : docID, "date" : docDate, "originalText" : text, "tokens" : tokens, "topicCounts" : topicCounts});
    	}
    
});

// assuming Cirrus library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Via', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.via',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		limit: 100,
    		docIndex: undefined
    	},
		glyph: 'xf06e@FontAwesome'
    },
    
    config: {
    	mode: undefined,
    	options: [
    		{xtype: 'stoplistoption'},
    		{
	    		xtype: 'listeditor',
	    		name: 'whiteList'
    	    },
    	    {xtype: 'categoriesoption'}
    	]
    },
    
    layout: 'fit',
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function (config) {
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			xtype: 'corpusdocumentselector',
        			singleSelect: true
        		},{
        			fieldLabel: this.localize('visible'),
        			labelWidth: 40,
        			width: 120,
        			xtype: 'slider',
	            	increment: 10,
	            	minValue: 10,
	            	maxValue: 1000,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam("limit"))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			this.loadFromCorpus(this.getCorpus());
	            		},
	            		scope: this
	            	}
                }]
    		}]
    	});

    	this.callParent(arguments);
    	
    	
    },
    
    listeners: {
    	resize: function(panel, width, height) {
//    		if (this.getCorpus()) {
//        		this.loadFromCorpus(this.getCorpus())
//    		}
    	},
    	
    	loadedCorpus: function(src, corpus) {
    		var langs = corpus.get("languageCodes");
    		var val = Ext.Array.each(langs, function(lang) {
    			if (lang!='en') {
    				this.showError(this.localize('englishOnly'));
    				return false;
    			}
    		}, this);
    		if (corpus.getWordTokensCount()>100000 && !this.getApiParam("docIndex")) {
    			this.setApiParam("docIndex", 0)
    		}
    		this.loadFromCorpus(corpus);
    	},
    	
    	corpusSelected: function(src, corpus) {
    		this.setApiParam("docIndex", "");
    		this.loadFromCorpus(corpus)
    	},
    	
    	documentSelected: function(src, document) {
    		this.setApiParam("docIndex", document.getIndex());
    		this.loadFromCorpus(this.getCorpus())
    	}
    	
    	
    },
    
    loadFromCorpus: function(corpus) {
    	var me = this;
    	this.mask(this.localize("loading"))
    	var params = this.getApiParams();
    	var a = corpus.loadRelatedWords(params).then(function(relatedWords) {
    		me.unmask()
    		var edges = relatedWords.map(function(item) {return {source: item.getSource(), target: item.getTarget()}})
    		var graph = me.down("voyantnetworkgraph");
    		if (graph) {
    			graph.loadJson({edges: edges});
    		} else {
    			graph = Ext.create("Voyant.widget.VoyantNetworkGraph", {
        			edges: edges,
        			listeners: {
        				nodeclicked: function(src, node) {
        					me.dispatchEvent('termsClicked', me, [node.term]);
        				}
        			}
        		})
        		me.add(graph)
    		}
    	}, function(response) {
    		me.unmask();
    		if (response.timedout) {
    			me.showError(me.localize('timedout'));
    		} else {
        		me.showError(response);
    		}
    	});
    }
});
Ext.define("Voyant.notebook.editor.button.Add", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperadd',
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
    		tooltip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf067@FontAwesome',
	textAlign: 'left',
	listeners: {
		click: function(btn, e) {
        	this.findParentByType('notebook').fireEvent("notebookWrapperAdd", this.findParentByType("notebookeditorwrapper"), e);
		}
	}
})
Ext.define("Voyant.notebook.editor.button.Edit", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperedit',
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
    		toolTip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf040@FontAwesome',
	listeners: {
		click: function() {
        	this.findParentByType('notebook').fireEvent("notebookWrapperEdit", this.findParentByType("notebookeditorwrapper"));
		}
	}
})
Ext.define("Voyant.notebook.editor.button.Counter", {
	extend: "Ext.toolbar.TextItem",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrappercounter',
	statics: {
		i18n: {
		}
	},
	config: {
		order: 0
	},
	cls: 'notebookwrappercounter',
	constructor: function(config) {
    	Ext.apply(this, {
    		toolTip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	setOrder: function(pos) {
		this.callParent(arguments);
		this.updateHtml();
	},
	updateHtml: function() {
		var pos = this.getOrder()+1;
		var lnk = 'spyralcounter_'+pos;
		this.setHtml('<a name="'+lnk+'" id="'+lnk+'" href="#'+lnk+'">'+pos+'</a>');
	}
})
Ext.define("Voyant.notebook.editor.button.MoveDown", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrappermovedown',
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
    		tooltip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf063@FontAwesome',
	textAlign: 'left',
	listeners: {
		click: function() {
        	this.findParentByType('notebook').fireEvent("notebookWrapperMoveDown", this.findParentByType("notebookeditorwrapper"));
		}
	}
})
Ext.define("Voyant.notebook.editor.button.MoveUp", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrappermoveup',
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
    		tooltip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf062@FontAwesome',
	textAlign: 'left',
	listeners: {
		click: function() {
        	this.findParentByType('notebook').fireEvent("notebookWrapperMoveUp", this.findParentByType("notebookeditorwrapper"));
		}
	}
})
Ext.define("Voyant.notebook.editor.button.Remove", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperremove',
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
    		tooltip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf014@FontAwesome',
	textAlign: 'left',
	listeners: {
		click: function() {
			Ext.Msg.show({
				buttons: Ext.Msg.OKCANCEL,
				icon: Ext.MessageBox.QUESTION,
				msg: this.localize("confirmRemove"),
				title: this.localize("confirmRemoveTitle"),
				fn: function(buttonId) {
					if (buttonId=='ok') {
			        	this.findParentByType('notebook').fireEvent("notebookWrapperRemove", this.findParentByType("notebookeditorwrapper"));
					}
				},
				scope: this
			})
		}
	}
})
Ext.define("Voyant.notebook.editor.button.Movement", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	requires: ["Voyant.notebook.editor.button.MoveUp", "Voyant.notebook.editor.button.MoveDown", "Voyant.notebook.editor.button.Remove"],
	alias: 'widget.notebookwrappermovement',
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
    		tooltip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf07d@FontAwesome',
	menu: [
		{
        	xtype: 'notebookwrappermoveup'
        },{
        	xtype: 'notebookwrappermovedown'
        },{
        	xtype: 'notebookwrapperremove'
        }
	]
})
Ext.define("Voyant.notebook.editor.button.Run", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperrun',
	statics: {
		i18n: {
		}
	},
	glyph: 'xf04b@FontAwesome'
})
Ext.define("Voyant.notebook.editor.button.RunAll", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperrunall',
	statics: {
		i18n: {
		}
	},
	glyph: 'xf04e@FontAwesome',
	constructor: function(config) {
		config = config || {};
		config.tooltip = this.localize('tip');
		this.callParent(arguments);
	}
})
Ext.define("Voyant.notebook.editor.button.RunUntil", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperrununtil',
	statics: {
		i18n: {
		}
	},
	glyph: 'xf050@FontAwesome',
	constructor: function(config) {
		config = config || {};
		config.tooltip = this.localize('tip');
		this.callParent(arguments);
	}
})
Ext.define("Voyant.notebook.editor.EditorWrapper", {
	extend: "Ext.panel.Panel",
	mixins: ["Voyant.util.Localization"],
	requires: ["Voyant.notebook.editor.button.Movement","Voyant.notebook.editor.button.Add"],
	alias: "widget.notebookeditorwrapper",
	cls: "notebook-editor-wrapper",
	config: {
		content: '',
		isEditing: false
	},
	border: false,
	bodyBorder: false,
	initComponent: function() {
		var me = this;
		this.on("afterrender", function(){
			this.getDockedItems().forEach(function(tb) {
				tb.getTargetEl().setVisibilityMode(Ext.dom.Element.VISIBILITY);
			});
			//this.setActiveMode(false);
			this.body.on("click", function() {
				this.removeCls("notebook-editor-wrapper-hover");
				this.setActiveMode(true); // added for touch devices
			}, this);
			this.mon(this.getEl(), "mouseover", function() {
				this.setActiveMode(true);
			}, this);
			this.mon(this.getEl(), "mouseout", function() {
				this.setActiveMode(false);
			}, this);			
		}, this);
		this.callParent(arguments);
	},
	setActiveMode: function(mode) {
		this.getDockedItems().forEach(function(tb) {
			if (tb.dock=='right') {
				tb.items.each(function(item) {
					if (item.hasCls("notebookwrappercounter")==false) {
						item.getTargetEl().setVisibility(mode);
					}
				})
			} else {
				tb.getTargetEl().setVisibility(mode);
			}
		}, this);
		if (!this.getIsEditing()) {
			if (mode) {
				this.body.addCls("notebook-editor-wrapper-hover");
			} else {
				this.body.removeCls("notebook-editor-wrapper-hover");
			}
		}
	}
})
Ext.define("Voyant.notebook.editor.CodeEditor", {
	extend: "Ext.Component",
	alias: "widget.notebookcodeeditor", 
	mixins: ["Voyant.util.Localization",'Voyant.notebook.util.Embed'],
	embeddable: ["Voyant.notebook.editor.CodeEditor"],
	cls: 'notebook-code-editor',
	config: {
		theme: 'ace/theme/chrome',
		mode: 'ace/mode/javascript',
		content: '',
		docs: undefined,
		isChangeRegistered: false,
		editor: undefined,
		editedTimeout: undefined,
		lines: 0
	},
	statics: {
		i18n: {
		},
		api: {
			content: undefined
		}
	},
	constructor: function(config) {
		this.callParent(arguments);
	},
	listeners: {
		boxready: function() {
			var me = this;
			var editor = ace.edit(Ext.getDom(this.getEl()));
			editor.$blockScrolling = Infinity;
			editor.getSession().setUseWorker(true);
			editor.setTheme(this.getTheme());
			editor.getSession().setMode(this.getMode());
			editor.setOptions({minLines: 6, maxLines: this.getMode().indexOf("javascript")>-1 ? Infinity : 10, autoScrollEditorIntoView: true, scrollPastEnd: true});
			editor.setHighlightActiveLine(false);
			editor.renderer.setShowPrintMargin(false);
			editor.renderer.setShowGutter(false);
			editor.setValue(this.getContent() ? this.getContent() : this.localize('emptyText'));
			editor.clearSelection();
		    editor.on("focus", function() {
		    	me.getEditor().renderer.setShowGutter(true);
		    }, this);
		    editor.on("change", function(ev, editor) {
		    		var lines = editor.getSession().getScreenLength();
		    		if (lines!=me.getLines()) {
		    			me.up('notebookcodeeditorwrapper').setSize({height: lines*editor.renderer.lineHeight+editor.renderer.scrollBar.getWidth()})
		    			me.setLines(lines);
		    		}
			    	if (me.getIsChangeRegistered()==false) {
			    		me.setIsChangeRegistered(true);
				    	var wrapper = me.up('notebookcodeeditorwrapper');
				    	if (wrapper) {
				    		wrapper.setIsRun(false);
				    		var notebook = wrapper.up(notebook);
				    		if (notebook) {notebook.setIsEdited(true);}
				    	}
			    	} else {
			    		if (!me.getEditedTimeout()) { // no timeout, so set it to 30 seconds
							me.setEditedTimeout(setTimeout(function() {
								me.setIsChangeRegistered(false);
							}, 30000));
			    		}
			    	}
		    }, this);
		    editor.on("blur", function() {
		    	me.getEditor().renderer.setShowGutter(false);
		    });
			editor.commands.addCommand({
				name: 'run',
			    bindKey: {win: "Shift-Enter", mac: "Shift-Enter"}, // additional bindings like alt/cmd-enter don't seem to work
			    exec: function(editor) {
			    	var wrapper = me.up('notebookcodeeditorwrapper');
			    	if (wrapper) {
			    		wrapper.run();
			    	}
			    }				
			});
			this.setEditor(editor);
			
			ace.config.loadModule('ace/ext/tern', function () {
	            me.getEditor().setOptions({
	                /**
	                 * Either `true` or `false` or to enable with custom options pass object that
	                 * has options for tern server: http://ternjs.net/doc/manual.html#server_api
	                 * If `true`, then default options will be used
	                 */
	                enableTern: {
	                    /* http://ternjs.net/doc/manual.html#option_defs */
	                    defs: me.docs ? ['ecma5', me.docs] : [],
	                    plugins: {
	                        doc_comment: {
	                            fullDocs: true
	                        }
	                    },
	                    /**
	                     * (default is true) If web worker is used for tern server.
	                     * This is recommended as it offers better performance, but prevents this from working in a local html file due to browser security restrictions
	                     */
	                    useWorker: true
	                },
	                /**
	                 * when using tern, it takes over Ace's built in snippets support.
	                 * this setting affects all modes when using tern, not just javascript.
	                 */
	                enableSnippets: true,
	                
	                /**
	                 * when using tern, Ace's basic text auto completion is enabled still by deafult.
	                 * This settings affects all modes when using tern, not just javascript.
	                 * For javascript mode the basic auto completion will be added to completion results if tern fails to find completions or if you double tab the hotkey for get completion (default is ctrl+space, so hit ctrl+space twice rapidly to include basic text completions in the result)
	                 */
	                enableBasicAutocompletion: true
	            });
	        });
		},
		removed: function(cmp, container) {
			if (cmp.getEditor()) {
				cmp.getEditor().destroy();
			}
		}
		
	},
	
	switchModes: function(mode) {
		this.setMode('ace/mode/'+mode);
		this.getEditor().getSession().setMode(this.getMode());
		this.getEditor().setOptions({maxLines: this.getMode().indexOf("javascript")>-1 ? Infinity : 10});

	},
	
	getValue: function() {
		return this.getEditor().getValue();
	}
})
Ext.define("Voyant.notebook.editor.CodeEditorWrapper", {
	extend: "Voyant.notebook.editor.EditorWrapper",
	requires: ["Voyant.notebook.editor.CodeEditor","Voyant.notebook.editor.button.Run",,"Voyant.notebook.editor.button.RunAll"],
	alias: "widget.notebookcodeeditorwrapper",
	cls: 'notebook-code-wrapper',
	statics: {
		i18n: {
		}
	},
	config: {
		isRun: false
	},
	layout: {
		type: 'vbox',
		align: 'stretch'
	},
	height: 130,
	border: false,
	constructor: function(config) {

		this.results = Ext.create('Ext.Component', {
			align: 'stretch',
			cls: 'notebook-code-results',
			html: Ext.Array.from(config.output).join("")
		});
		
		this.editor = Ext.create("Voyant.notebook.editor.CodeEditor", {
			content: Ext.Array.from(config.input).join("\n"),
			docs: config.docs,
			mode: 'ace/mode/'+(config.mode ? config.mode : 'javascript')
		});
		
		Ext.apply(this, {
			dockedItems: [{
			    xtype: 'toolbar',
			    dock: 'left',
			    defaults: {
			    	textAlign: 'left'
			    },
			    items: [
					{
						xtype: 'notebookwrapperadd'
					},{
						xtype: 'notebookwrapperrun',
						listeners: {
							click: {
								fn: this.run,
								scope: this
							}
						}
					},{
						xtype: 'notebookwrapperrununtil',
						listeners: {
							click: {
								fn: function() {
									this.up('notebook').runAllCode(this)
								},
								scope: this
							}
						}
					},{
						xtype: 'button',
						glyph: 'xf1c9@FontAwesome',
						tooltip: this.localize('codeModeTip'),
						listeners: {
							click: function() {
								var me = this;
								new Ext.Window({
								    title: 'Resize Me',
								    layout: 'fit',
								    width: 200,
								    items: [{
										xtype: 'form',
										layout: {
											type: 'vbox',
											align: 'stretch'
										},
										bodyPadding: 10,
										items: [{
											xtype: 'fieldset',
											title: this.localize("modeCode"),
											items: {
							                    xtype : 'radiofield',
							                    boxLabel : this.localize('modeJavascript'),
							                    name  : 'codeMode',
							                    inputValue: 'javascript',
							                    flex  : 1													
											}
										},{
											xtype: 'fieldset',
											title: this.localize("modeData"),
											items: [{
												items: {
								                    xtype : 'radiofield',
								                    boxLabel : this.localize('modeJson'),
								                    name  : 'codeMode',
								                    inputValue: 'javascript',
								                    flex  : 1													
												}
											},{
												items: {
								                    xtype : 'radiofield',
								                    boxLabel : this.localize('modeText'),
								                    name  : 'codeMode',
								                    inputValue: 'text',
								                    flex  : 1													
												}
											},/*{
												items: {
								                    xtype : 'radiofield',
								                    boxLabel : this.localize('modeCsv'),
								                    name  : 'codeMode',
								                    inputValue: 'csv',
								                    flex  : 1													
												}
											},{
												items: {
								                    xtype : 'radiofield',
								                    boxLabel : this.localize('modeTsv'),
								                    name  : 'codeMode',
								                    inputValue: 'tsv',
								                    flex  : 1													
												}
											},*/{
												items: {
								                    xtype : 'radiofield',
								                    boxLabel : this.localize('modeHtml'),
								                    name  : 'codeMode',
								                    inputValue: 'html',
								                    flex  : 1													
												}
											},{
												items: {
								                    xtype : 'radiofield',
								                    boxLabel : this.localize('modeXml'),
								                    name  : 'codeMode',
								                    inputValue: 'xml',
								                    flex  : 1													
												}
											}]
										}]
								    }],
								   buttons: [{
								        text: this.localize('ok'),
								        handler: function() {
								        	var win = this.up('window'); values = win.down('form').getForm().getValues();
								        	me.switchModes(values.codeMode);
								        	win.close();
								        }
								    },{
								        text:  this.localize('cancel'),
								        handler: function() {
								        	this.up('window').close();
								        }
								    }]
								}).show();
							},
							scope: this
						}
					}
			    ]
			},{
			    xtype: 'toolbar',
			    dock: 'right',
			    items: [{
			    		xtype: 'notebookwrappercounter',
			    		order: config.order
			    	},{
		        		xtype: 'notebookwrapperremove'
		        	},{
			        	xtype: 'notebookwrappermoveup'
			        },{
			        	xtype: 'notebookwrappermovedown'
			        }
			    ]
			}],
			items: [this.editor, this.results]
		});
		
        this.callParent(arguments);
        
	},
	
	initComponent: function(config) {
		var me = this;
		me.on("afterrender", function() {
			if (this.editor && this.editor.getMode() != 'ace/mode/javavscript') {
				this.switchModes(this.editor.getMode(), true)
			}
			this.getTargetEl().on("resize", function(el) {
				var height = 20;
				me.items.each(function(item) {height+=item.getHeight();})
				me.setSize({height: height});
			})
		}, this);
		me.callParent(arguments);
	},
	
	switchModes: function(mode, light) {
		var runnable = mode.indexOf('javascript')>-1;
		this.down('notebookwrapperrun').setVisible(runnable);
		this.down('notebookwrapperrununtil').setVisible(runnable);
		this.results.setVisible(runnable);
		if (!light) {
			this.editor.switchModes(mode);
		}
	},
	
	run: function(runningAll) {
		if (this.editor.getMode()=='ace/mode/javascript') { // only run JS
			if (runningAll===true) {
				this._run();
			} else {
				var notebook = this.up('notebook');
				Ext.Array.each(notebook.query('notebookcodeeditorwrapper'), function(wrapper) {
					if (wrapper==this) {this._run(); return false;} // break
					if (wrapper.editor && wrapper.editor.getMode() == 'ace/mode/javascript' && wrapper.getIsRun()==false) {
						Ext.Msg.confirm(this.localize('previousNotRunTitle'), this.localize('previousNotRun'), function(btnId) {
							if (btnId=='yes') {
								notebook.runAllCode();
							} else {
								this._run();
							}
						}, this)
					}
				}, this);
			}
		}
	},
	
	_run: function() {
		this.results.show();
		this.results.update(' ');
		this.results.mask('working');
		var code = this.editor.getValue();
		var success = false;
		try {
			Voyant.notebook.util.Show.TARGET = this.results.getEl(); // this is for output
			Voyant.notebook.Notebook.currentBlock = this; // this is to tie back in to the block
			
			// I'd like to be able to run this in another scope/context, but it
			// doesn't seem possible for the type of code that's being run
			eval.call(window, code);
			
			Ext.defer(this.tryToUnmask, 20, this);
		}
		catch (e) {
			this.results.unmask();
			Voyant.application.releaseAllDeferred();
			Voyant.notebook.util.Show.showError(e);
		}
		this.setIsRun(true);
		return success;
	},
	
	clearResults: function() {
		this.results.show();
		
		var panel = this.results.el.down('.x-panel');
		if (panel) {
			var id = panel.id;
			var cmp = Ext.getCmp(id);
			if (cmp) {
				cmp.destroy();
			} else {
				panel.destroy();
			}
		} else {
			this.results.update(' ');
		}
		
		this.getTargetEl().fireEvent('resize');
	},
	
	tryToUnmask: function() {
		if (Voyant.application.getDeferredCount()==0) {
			for (var key in window) {
				if (typeof window[key] == 'object' && window[key] && key!="opener" && window[key].isFulfilled &&  window[key].isFulfilled()) {
					window[key] = window[key].valueOf();
				}
			}
			this.results.unmask();
			if (this.results.getTargetEl().getHtml().trim().length==0) {
				this.results.hide();
			}
			this.getTargetEl().fireEvent('resize');
		}
		else {
			Ext.defer(this.tryToUnmask, 20, this);
		}
	},
	
	getContent: function() {
		var toReturn = {
			input: this.editor.getValue(),
			mode: this.editor.getMode().split("/").pop()
		}
		if (toReturn.mode=='javascript') {
			var el = this.results.getTargetEl(), resultEl = el.dom.cloneNode(true);
			toReturn.output = resultEl.innerHTML;
			if (!resultEl.style.height) {
				toReturn.output = "<div style='height: "+el.getHeight()+"px'>"+toReturn.output+"</div>";
			}
		}
		return toReturn;
	}
})
Ext.define("Voyant.notebook.editor.TextEditor", {
	extend: "Ext.Component",
	mixins: ["Voyant.util.Localization"],
	alias: "widget.notebooktexteditor",
	cls: 'notebook-text-editor',
	config: {
		ckeditorConfig : { // when upgrading ckeditor, remember to copy stopediting plugin
			toolbar:  [
				    	{ name: 'basicstyles', items: [ 'Bold', 'Italic', '-', 'RemoveFormat' ] },
				    	{ name: 'paragraph', items: [ 'NumberedList', 'BulletedList', '-', 'Justify', 'Outdent', 'Indent', 'Blockquote', 'JustifyLeft', 'JustifyCenter', 'JustifyRight' ] },
				    	{ name: 'colors', items: [ 'TextColor', 'BGColor' ] },
				    	{ name: 'styles', items: [ 'Styles', 'Format' ] },
				    	{ name: 'links', items: [ 'Link', 'Unlink', 'Anchor'] },
				    	{ name: 'insert', items: [ 'Image', 'Table' ] },
				    	{ name: 'document', items: [ 'Sourcedialog', 'Stopediting'] }
		    ],
		    extraPlugins: 'stopediting,sourcedialog,justify,colorbutton',
		    removePlugins: 'iframe',
			allowedContent: true,
			toolbarCanCollapse: true,
			startupFocus: true
		},
		editor: undefined,
		isEditRegistered: false,
		currentHeight: 0
	},
	statics: {
		i18n: {
		}
	},
	border: false,
	constructor: function(config) {
		Ext.apply(this, {
			html: config.content ? config.content : this.localize("emptyText")
		});
        this.callParent(arguments);
	},
	listeners: {
		boxready: function(cmp) {
			this.getTargetEl().on("click", function(e, t) {
				if (t.tagName!="A") {
					this.handleClick(cmp);
				}
			}, this);
		},
		removed: function(cmp, container) {
			// properly remove editor
			if (cmp.getEditor()) {
				cmp.getEditor().focusManager.blur(true); //focusManager bug workaround, see: https://dev.ckeditor.com/ticket/16825
				cmp.getEditor().destroy();
			}
		}
	},
	
	handleClick: function(cmp) {
		if (!cmp.getEditor() || (cmp.getEditor() && cmp.getEditor().readOnly)) {
			var el = this.getTargetEl();
			el.set({contenteditable: true});
			this.findParentByType("notebookeditorwrapper").setIsEditing(true);
			if (!cmp.getEditor()) {
				var editor = CKEDITOR.inline( el.dom, this.getCkeditorConfig() );
				editor.on("blur", function(evt) {
//					cmp.setEditor(undefined);
					cmp.findParentByType("notebookeditorwrapper").setIsEditing(false).getEl().fireEvent("mouseout");
//					el.set({contenteditable: false});
					editor.setReadOnly(true);
				})
				editor.on("change", function() {
					var editorHeight = editor.container.$.clientHeight;
					if (editorHeight!=this.getCurrentHeight()) {
						this.findParentByType("notebookeditorwrapper").setHeight(editorHeight);
						this.setCurrentHeight(editor.container.$.clientHeight)
					}
					if (!this.getIsEditRegistered()) {
						this.findParentByType("notebook").setIsEdited(true);
						this.setIsEditRegistered(true);

					} else {
						var me = this; // make sure to allow edits to be auto-saved every 30 seconds
						setTimeout(function() {
							me.setIsEditRegistered(false);
						}, 30000);
					}
				}, this)
				this.setEditor(editor);
			} else {
				cmp.getEditor().setReadOnly(false);
			}
		}
	},
	
	getContent: function() {
		return this.getTargetEl().dom.innerHTML;
	}
})
Ext.define("Voyant.notebook.editor.TextEditorWrapper", {
	extend: "Voyant.notebook.editor.EditorWrapper",
	requires: ["Voyant.notebook.editor.TextEditor","Voyant.notebook.editor.button.Edit"],
	alias: "widget.notebooktexteditorwrapper",
	cls: 'notebook-text-wrapper',
	config: {
		content: ''
	},
	minHeight: 85,
	constructor: function(config) {
		Ext.apply(this, {
			items: [{
				xtype: 'notebooktexteditor',
				content: Ext.Array.from(config.input).join("")
			}],
			dockedItems: [{
			    xtype: 'toolbar',
			    dock: 'left',
			    items: [{
				    	xtype: 'notebookwrapperadd'
					}
			    ]
			},{
			    xtype: 'toolbar',
			    dock: 'right',
			    items: [{
			    		xtype: 'notebookwrappercounter',
			    		order: config.order
			    	},{
		        		xtype: 'notebookwrapperremove'
		        	},{
			        	xtype: 'notebookwrappermoveup'
			        },{
			        	xtype: 'notebookwrappermovedown'
			        }
			    ]
			}]
		});
        this.callParent(arguments);
	},
	
	getContent: function() {
		return this.items.get(0).getContent();
	}
})
/**
 * @class Notebook
 * A Spyral Notebook. This should never be instantiated directly, but there are useful static methods that can be called.
 */
Ext.define('Voyant.notebook.Notebook', {
	alternateClassName: ["Notebook"],
	extend: 'Ext.panel.Panel',
	requires: ['Voyant.notebook.editor.CodeEditorWrapper','Voyant.notebook.editor.TextEditorWrapper','Voyant.notebook.util.Show','Voyant.panel.Cirrus','Voyant.panel.Summary'],
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.notebook',
    statics: {
    	i18n: {
    	},
    	api: {
    		input: undefined
    	},
    	
    	currentBlock: undefined,
 
    	/**
    	 * Get a global deferred object (which can be use to ensure that focus remains in a code block while asynchronous actions happen).
    	 * 
    	 * 	var deferred = Notebook.getDeferred();
    	 * 	// ... some asynchronous code
    	 * 	deferred.resolve();
    	 */
    	getDeferred: function() {
    		return Voyant.application.getDeferred();
    	},
    	
    	/**
    	 * This returns the contents of the previous data block (even if there are other kinds of blocks in between).
    	 * A data block is a code editing block that has been changed from the default mode "javascript" to another mode
    	 * (like text). You can change the mode of a block in Spyral by clicking the format icon in the left toolbar
    	 * for an existing code block.
    	 */
    	getDataFromBlock: function(where) {
    		if (Voyant.notebook.Notebook.currentBlock) {
    			var previous = Voyant.notebook.Notebook.currentBlock;
    			while(previous) {
    				previous = previous.previousSibling();
    				if (previous && previous.isXType("notebookcodeeditorwrapper")) {
    					if (previous.editor.getMode()=='ace/mode/javascript') {
    						// we have a JS editor, and we don't want the code, but we have to check for embedded results
    						var iframe = previous.results.getTargetEl().dom.querySelector("iframe");
    						if (iframe) {
    							var win = iframe.contentWindow; editor = win.document.querySelector(".ace_editor");
    							if (editor && win.ace) {
    								var e = win.ace.edit(editor);
    								if (e.getSession().getMode().$id!='ace/mode/javascript') {
    									return e.getValue();
    								}
    							}
    						}
    					} else {
    						return previous.getContent().input;
    					}
    				}
    			}
    		}
    		showError("Unable to find data to load");
    	},
    	
    	/**
    	 * This fetches content from a URL, often resolving cross-domain data constraints.
    	 * 
    	 * @param {String} url The URL load
    	 * @param {Object} [config] configuration options:
    	 * - format: json|xml|text (which will determine what kind of object is returned)
    	 */
    	loadDataFromUrl: function(url, config) {
    		var dfd = Voyant.application.getDeferred();
    		var params = {
       		     url: Voyant.application.getTromboneUrl(),
    		     params: {
    		    	 fetchData: url
    		     },
    		     scope: this
    		}
    		if (config && config.format) {params.format = config.format}
    		if (config && "timeout" in config) {params.timeout = config.timeout}
    		Ext.Ajax.request(params).then(function(response, opts) {
    			 if (config && config.format) {
    				 if (config.format.toLowerCase()=='json') {
    					 return dfd.resolve(Ext.decode(response.responseText))
    				 } else if (config.format.toLowerCase()=='xml') {
    					 parser = new DOMParser();
    					 xmlDoc = parser.parseFromString(response.responseText,"text/xml");
    					 return dfd.resolve(xmlDoc)
    				 }
    			 }
    			 dfd.resolve(response.responseText);
    		 },
    		 function(response, opts) {
    			 Voyant.application.showResponseError((response.statusText=="communication failure" ? "Unable to load data, the connection timedout." : "Unable to load data"), response); // can't seem to scope right
    		     console.log('server-side failure with status code ' + response.status);
    			 dfd.reject(response.responseText);
    		 });
    		
    		return dfd.promise;
    	},
    	
        /**
         * Formats the passed number according to the passed format string.
         *
         * By default, "," is expected as the thousand separator, and "." is expected as the decimal separator.
         *
         * Examples (123456.789):
         * 
         * - `0` - (123457) show only digits, no precision
         * - `0.00` - (123456.79) show only digits, 2 precision
         * - `0.0000` - (123456.7890) show only digits, 4 precision
         * - `0,000` - (123,457) show comma and digits, no precision
         * - `0,000.00` - (123,456.79) show comma and digits, 2 precision
         * - `0,0.00` - (123,456.79) shortcut method, show comma and digits, 2 precision
         * - `0.####` - (123,456.789) Allow maximum 4 decimal places, but do not right pad with zeroes
         * - `0.00##` - (123456.789) Show at least 2 decimal places, maximum 4, but do not right pad with zeroes
         *
         * @param {Number} v The number to format.
         * @param {String} formatString The way you would like to format this text.
         * @return {String} The formatted number.
         */
		formatNumber: function(number, format) {
    			return Ext.util.Format.number(number, format);
    		},
    		
    		getTarget: function() {
    			return Voyant.notebook.util.Show.TARGET;
    		},
    		
    		getStopwords: function(id) {
    			var dfd = this.getDeferred();
    			if (id && id in Voyant.widget.StopListOption.stoplists) {
    				id = Voyant.widget.StopListOption.stoplists[id];
    			}
    	    		Ext.Ajax.request({
	    	    	    url: Voyant.application.getTromboneUrl(),
	    	    	    params: {
	    	        		tool: 'resource.KeywordsManager',
	    	    			stopList: id
	    	    	    },
	    	    	    success: function(response){
	    	    	    		var json = Ext.util.JSON.decode(response.responseText);
	    	    	    		var keywords = json.keywords.keywords;
	    	    	    		dfd.resolve(keywords);
	    	    	    },
		    	    	scope: this
	    	    	});
    	    		return dfd.promise;
    		}
    	
    },
    config: {
        /**
         * @private
         */
    	metadata: {},
        /**
         * @private
         */
    	version: 2.0,
        /**
         * @private
         */
    	isEdited: false,
        /**
         * @private
         */
    	saveItTool: undefined,
    	
        /**
         * @private
         */
		autoSaveTimer: undefined,
		
        /**
         * @private
         */
		initialAutoSaveChecked: false

    },
    
    docs: {
    	"!name": "Voyant"
    },
    
    /**
     * @private
     */
    constructor: function(config) {
    	config = config || {};
    	var me = this;
    	var libs = ["Corpus","Notebook","NetworkGraph","VoyantTable"];
    	this.docsLoading = libs.length;
    	libs.forEach(function(lib) {
    		 Ext.Ajax.request({
    			 url: this.getBaseUrl()+"docs/ace/"+lib+".json",
    			 scope: this
    		 }).then(function(response, opts) {
    		     var docs = Ext.decode(response.responseText);
    		     var moreTemplate = new Ext.XTemplate("<a href='../../docs/#!/api/"+lib+"{0}'>more</a>");
    		     me.docs[lib] = {
	    	        "!type": "fn(config) -> Corpus",
	                "!url": "",
	                "!doc": docs.short_doc + moreTemplate.apply([])
    		     }
    		     docs.members.forEach(function(member) {
    		    	 if (!member['private'] && member.tagname=='method') {
			    		me.docs[lib][member.name] = {
				    	        "!type": "fn()",
				                "!url": "",
				                "!doc": member.short_doc + moreTemplate.apply(["-"+member.id])
			    		}
    		    	 }
    		     })
    		     me.docsLoading--;
    		 },
    		 function(response, opts) {
    		     me.docsLoading--;
    		     console.log('server-side failure with status code ' + response.status);
    		 });

    	}, this)
    	
    	
    	Ext.apply(config, {
    		title: this.localize('title'),
    		includeTools: {
    			'help': true,
    			'save': true,
    			'saveIt': {
    				tooltip: this.localize("saveItTip"),
    				callback: function() {
    					me.getExportHtml(); return;
    					/*
    					if (!("previousUrl" in this.getMetadata())) {
    						var passWin = Ext.create('Ext.window.Window', {
    				            title: me.localize('saveNewSpyralTitle'),
    						    layout: 'fit',
    						    items: {
    						    	padding: 10,
    				                flex: 1,
    				                width: 300,
    				                layout: {
    				                    type: 'vbox',
    				                    align: 'stretch'
    				                },
    				                items: [
    				                    {
    				                        html: '<p>'+me.localize('saveNewSpyralMessage')+'</p>'
    				                    },{
    				                    	xtype: 'textfield',
    				                    	fieldLabel: me.localize('password')
    				                    }
    				                ],

    						This appears to be a new Spyral notebook. You can choos
    					}
    					*/
    					me.mask(me.localize('saving'));
    			    	 Ext.Ajax.request({
    			    	     url: this.getTromboneUrl(),
    			    	     params: {
    			    	    	 tool: 'notebook.NotebookManager',
    			    	    	 jsonData: Ext.encode(me.getExportAllJson())
    			    	     },
    			    	     scope: this
    			    	 }).then(function(response, opts) {
    			    		 me.unmask();
    			    	     var data = Ext.decode(response.responseText);
    			    	     if (data && data.notebook && data.notebook.notebook) {
    			    	    	 var url = me.getBaseUrl()+"spyral/"+data.notebook.notebook;
    			    	    	 var params = me.getApplication().getModifiedApiParams();
    			    	    	 if (Object.keys(params).length>0) {
    			    	    		 url += "?"+Ext.Object.toQueryString(params);
    			    	    	 }
    			    	    	 window.history.pushState({
 			    					url: url
 			    				}, "Spyral Notebook: "+data.notebook.notebook, url);
    			    	    	 me.toastInfo({
    			    	    		 html: me.localize('savedUrlChanged'),
    			    	    		 anchor: 'tr'
    			    	    	 });
    			    	     } else {
    			    	    	 me.showError(me.localize('savedFailed'))
    			    	     }
    			    	 },
    			    	 function(response, opts) {
    			    		 me.unmask();
    			    		 me.showResponseError("Unable to save this notebook.", response);
    			    	 });
    				},
    				xtype: 'toolmenu',
    				glyph: 'xf0c2@FontAwesome',
    				//visible: false,
    				listeners: {
    					afterrender: function(tool) {
    						tool.setVisible(true);
    						me.setSaveItTool(tool);
    					}
    				},
//    				disabled: true,
    				scope: this
    			},
    			'open': {
    				tooltip: this.localize("openTip"),
    				callback: function() {
    					Ext.Msg.prompt(this.localize("openTitle"),this.localize("openMsg"),function(btn, text) {
    						text = text.trim();
    						if (btn=="ok") {
    							this.removeAll();
    							if (text.indexOf("http")==0) {
    								this.loadFromUrl(text);
    							} else {
    								this.loadBlocksFromString(text);
    							}
    						}
    					}, this, true);
    				},
    				xtype: 'toolmenu',
    				glyph: 'xf115@FontAwesome',
    				scope: this
    			},
    			'new': {
    				tooltip: this.localize("newTip"),
    				callback: function() {
    					this.openUrl(this.getBaseUrl()+"spyral/")
    				},
    				xtype: 'toolmenu',
    				glyph: 'xf067@FontAwesome',
    				scope: this
    			},
    			'runall': {
    				tooltip: this.localize("runallTip"),
    				callback: function() {
    					this.runAllCode();
    				},
    				xtype: 'toolmenu',
    				glyph: 'xf04e@FontAwesome',
    				scope: this
    			}
			 }
    	})
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    },
    
    autoScroll: true,
    exportToolClick: function() {
    	var panel = this.up('panel');
		Ext.create('Ext.window.Window', {
			title: panel.localize("exportTitle"),
			modal: true,
			items: {
				xtype: 'form',
				items: [{
					xtype: 'radio',
					name: 'export',
					inputValue: 'html',
					checked: true,
					boxLabel: panel.localize('exportHtml')
				},{
					xtype: 'radio',
					name: 'export',
					inputValue: 'json',
					boxLabel: panel.localize('exportJson')
				}],
				buttons: [{
	            	text: panel.localize("cancelTitle"),
	            	ui: 'default-toolbar',
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: panel.localize("exportTitle"),
					glyph: 'xf08e@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var form = btn.up('form'), exportOption = form.getValues()['export'];
	        			if (exportOption=='json') {
	        				panel.exportAll()
	        			} else if (exportOption=='html') {
	        		    	var contents = "", type, content;
	        		    	this.items.each(function(item, i) {
	        		    		type = item.isXType('notebookcodeeditorwrapper') ? 'code' : 'text';
	        		    		content = item.getContent();
	        		    		contents += "<div id='vn-section-"+i+"'><a name='vn-section-"+i+"'></a>";
	        		    		if (type=='code') {
	        		    			contents += "<div class='notebook-code-editor ace-chrome'>"+item.getTargetEl().query('.ace_text-layer')[0].outerHTML+"</div>";
	        		    			if (content.mode=='javascript') {
		        		    			contents += "<div class='notebook-code-results'>"+content.output+"</div>";
	        		    			}
	        		    		} else {
	        		    			contents += "<div class='notebook-text-editor'>"+content+"</div>";
	        		    		}
	        		    		contents += "</div>";
	        		    	}, this)

	                        var myWindow = window.open();
	                        myWindow.document.write('<html><head>');
	                        myWindow.document.write('<title>Spyral Notebooks</title>');
	                        myWindow.document.write(document.getElementById("ace-chrome").outerHTML);
	                        myWindow.document.write(document.getElementById("voyant-notebooks-styles").outerHTML);
//	                        myWindow.document.write('<link rel="Stylesheet" type="text/css" href="http://dev.sencha.com/deploy/ext-4.0.1/resources/css/ext-all.css" />');
//	                        myWindow.document.write('<script type="text/javascript" src="http://dev.sencha.com/deploy/ext-4.0.1/bootstrap.js"></script>');
	                        myWindow.document.write('</head><body class="exported-notebook"><a href="http://voyant-tools.org/docs/#!/guide/spyral"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB5CAYAAADyOOV3AAAgAElEQVR4nOWdd3hU5br2Z7s9Z59zvr2/s5NsKwgSCBBaSAghvffMZCaFkNAUECyAAmJDBVSkiDQ3HQREozSRIiUVEEhvk94nyWQmyfTeZ+7vj5m1mPQCyOi3ruu5pq9Z6/2t+3mf93nLolBGsAH4y0h+Z+sbgKcAPA3g6XPnzv31z3qeA27ESUulUnuJRJIkl8sTLZYgl8sTVCpVvFwuj5fL5fEqlSpOLBbHicXiOJlMxpDJZAyxWNzNZDIZXSaT0cVicTeTyWSxMpmMJpPJqEqlMlokEkVJpdJIiUQSrlAowhQKRahEIgkRi8VBYrE4UC6XB8jlcn+RSOQnk8l8ZDKZt0wm8xIKhZ4CgWCOVCqdLZFI3JVK5SyJRDJLLBbPlMlkk9Rq9RipVGrf3/lu3rz56c2bNz/9/w1sAH+lUCgUoVDoCQAmkwl9bcT7JpNpxGY0GkkzGAwwGAzQ6/Wk6XQ66HQ6aLVa0jQaDTQaDdRqNWkqlYo0hUIBhUIBmUwGqVSqk0gkSqlUyhOJROVSqfSyQCDYIRKJUrhcrjOAp3qc+9ObN29+qu+S+ZNsBGCJROJuKSy9QqEwyOVyI/H4KE2hUPQyuVxu6mkKhaKbyeVy9GcymQxyuZyErVKpoNPpyItSr9dDIBAY+Hx+VVdX1/6urq5Q4rwpFLOq/7SKJk5UKpXOVqvVIArXusAGMuJ7g32fgNHju71AjsSIi0ImkxFmlEqlBolEoheLxXqRSGQQiURQKBTQarWQSqXgcDg1LS0t60Ui0f/2LIs/1dYf4KHAtRXrqWapVAqpVAqJRAKJRAKRSAShUGgSCAQGHo+n6+zsNIpEIsjlcrBYrI7m5uaVPcvjT7PZCmClUjli6wlaJpORoCUSCcRiMUQiEQQCAXg8Hjo7O8Hlcg2tra06DocDgUCA+vr6nPb2dhcKhUL5U0XcTwLww8AcCmgCdk/IQqEQfD4fXV1d4HK5YLPZYLFYxvr6el1raytYLBa4XO7blqL5S8+g7A+5/R6AHxfQoUC2Bk1AJlTM4XDQ0tKCxsZGVFdX6ysqKtDS0oKmpqa9RPls3rz56SdH5xFsjwvw7wl1OGq2htzR0YG2tjY0NTWhrq4O1dXVxpKSEn1bWxtaW1vTuVzu/1AoFEpRUdF/PFlKD7E9asBPGmx/sPuDzOVywWKxUF9fj6qqKpSXl6OgoEDLZrPBZrNr2Gz2KArlDwz5UQF+0hCHqmi5XE5CFggE6OrqApvNRmNjI2pqalBeXo6SkhLk5eVpOzs70drayuFwOJMolD8o5IcF/KTBjVTN1pA7OjrAYrFQV1eHyspKlJaWIi8vDyUlJToej4eWlhY5n893o1D+gJBHCvj3hKJSqfp8/iggi0Qi8Hg8UsXV1dUoKytDQUEBcnJy0NLSou/o6EBzc7OWy+X6USgUSlVV1X8+WWrD2PoCPFBW6nHAe5Q2EshCoZBUcW1tLcrLy1FcXIy7d++iuroaXV1dei6Xi6amJimbzZ5AofyBlDwcBdsi0IcBrlCYOykkEgmp4oaGBlRWVqKkpAQ5OTkoLCwkIm5dR0cHGhsb2Twe73lL2dl+E2oogP+IYIcKW6FQkCrmcrlobm4m3XR+fj7u37+Pzs5OCAQCsNlsHY/HQ0NDQ1Vtbe0/KBRz1uvJEhxkGwzwHx3qYKAJVy0Wi9HV1YW2tjbU1dWhvLwcRUVF+O2338BmsyGVSomIWysQCNDU1HTHqgxtN+M1UB38ZwPbH2xCxXw+H+3t7WhsbCTd9N27d9HU1ASlUgmhUEhCFgqFaGhoOG0pw6dsNnfdj4KfGFjrjv2h2qOALJfL+3TT9+7dQ11dHTQaDenKOzs70dbWphOJRGhoaNhModhw0NUTsEKhMCmVStPvAXYkMB8XcIVCAbFYDEtyA7W1tWAymcjJyUF1dTV0Oh2USiWkUinRdjax2WxDV1cXWlpa5lMoNgr5YQHbCtSHha1UKiGRSLrVwxUVFcjPz0dlZSV0Oh0s5QOJREJANra1tYHFYoHNZntYytO2IuuRArZlqCOBTaiTx+Ohvb2dbC4VFBSgsrKSHCNmDZnP56Ojo0Pf0dGBpqYmXmdn57PWZWoTW1+AVSrVgID/aGCHAronYCKrVVRUhOrq6l4DAAmXzufzweVydZbIOt+qXG0jsh6Ogh83WKIAR2IPC5oAzOfzweFw0NzcjNraWpSWlqK+vh56vb7bSE+VSgWZTEamOtvb27USiQTNzc2nKBQKZfPmzbYRWQ9VwY8a7sPAfNTAewK27kJkMploaGiAUqmEWq2GVquFXq+HwWCAVqslldzV1YX29na9SCRCa2vrBxSKjQwW6EfBw4ZrC1AfBrY14I6ODrS2tpJdiJWVlaisrERVVRVqamrQ2NgINpsNHo8HsVhMpjv5fL6pvb3dKBAI0N7enmQp3ycbWQ8G+FHAfVJghwq6p4I7OzvR3t4OFouFxsZGYrQHKioqwGQyUVJSgsLCQhQUFKCoqAhMJhP19fVgs9no7Ow08Hg8sFgscWNj40vWZWxLgE1DgfuowVrPaBiOPSxo62YSMQigo6MDHA4HbDYbliE8YLFYaG5uJqHX1NSgoqICpaWlJPDS0lLU1NToBAIB2trayKDric2g6K8OHglc6/cfN9SHBd7zuK17loghPQKBAHw+HzweDzweD11dXcSQW7S3t5PQCeBVVVUoKytDUVERSkpKtJYkyEHrcv5DAH5Y1T4OqCOFTdS/1h0PPcdVEyYWi8kx1sQQXAI4kfBoaGgglG0qLi42tLS0oKGhIYlCeUKZrr4Aq9XqfgE/DNyhwFCpVP1+zuVyUVFRgeLiYhQWFqKwsBD5+WbXWFBQgPz8fBQUFKCpqQlyubzfSWwKhaLba8JFE5Cte9L66hcfaJSmdd1dW1trqK6uRnl5uaS6uvoFCuUJdC8OB/BI4Q4GltiHVqslZxfKZDI0NDQgNTUV+/btw86dO7Fu3Tq89eZbSE5OAZUWi4iISISHRyAiIhJRUdGg0xlYuHARli5dhs2bP8OuXbuwe/du3LlzB11dXZBIJN2OyzqQ7Nku7i8Z0ld/MuHaRSIRGYVbBtWjvr5ex2azUV1d/aulvH/furgnYKVS2SfgkcAdClgCqk6nQ0dHB3Jzc3HkyBEsW/YakpLmgUqlwd19NhwdJ4BCeRrPPz8agYFBSIhPwOLFr2DZstewdOkyLFq0CHFx8fDz9Ye9/bN44YXRcHFxhZ+fPyIjo5CQkIi1a9fiypUrKCwshEKh6FUPDxZpDwSeULVEIuk2JNcy7lrf0dGB2traJRTK7+yqhwL4UaqW+JyAqtPpUFdXh8OHj2LV6tVISEjE1KnTMXasIyIiIrFq1Srs3r0b589fQFFREZqbm9HW1gYOh4POzk7weHx0kTMVuGT7NS8vH2fOnMWOHV/h9dffQHh4BMaOdYSXpzfmzUvGhg0bkJqaCg6H08tdjxRyz8F8hJo5HI7Rkh3rIEaC/G5ZrsEAP0rV9gRbWlqKnTt3ITk5BSHBoXj++VEICQnFzp1f49q1a6iuroZSqYTRaOxzUvpQNqPRCJlMBiaTicuXL+Pzzz+Hl5c3nJ2nIjw8AvPmJePYsWNkn6914DUSyNZqth573dHRoZNKpWhvb19LofyOKh6sDh4O4IHgqlSqbor96quvsHDhIri7e2DmTDesW7cOV6/+itbWVmg0mj5hWa8SYDJaVg0gVg8wGbutINDfSgUKhQLNzc24cOFnvPnmm5g6dTr8/QMwf/4CHDhwAG1tbeT5yOXyYUG2rputXbZlVqNBLBajvb299HcB2x9gpVJJNpMeBVziM51OB6lUitTUVCQnpyAgIBDjxo3H5s2fIScnB3K5vJfyHiz/MDL19lw+oid0sViMrKxsrF//Hl544SWEhUVg/vwFuHjxImQyGRmIjUTF1gGYJdI28fl8U2dnJ9hs9nQK5XeKqPtS8KOES6iWyWRi9erViI2lY9IkZ6xfvx75+flQqdRkgTc0NKCoqKgboEexWS/lcOvWLQiFwm6fy2Ry3L59G6+//gYmTZqChIRErF//Hmpqavp12UMFbD2LQigU6jUaDbq6ul63lP3j74ywAuwxGOCRwj179ixSUlLg7u6BmBgqLl26BJlM1ktp+/cfgKOjE8rLyx8ZYOvFY86fPw8KhYK7d+8CAOnOiU0gEOD06dPw9/OHt7cPFi5chEuXLpPn/7CQJRKJXqfTgcfjHXtigIkg61HAlcvl2LHjKyQkJGL6dBds3LgJTc3N3QqfKOC6ujoEBAQhPDwCiYlz0Wz53sMEWCYrwOnp6WSz6eOPP4ZarSaPgTBiq6ysxDvvrIGLy0zMm5eMPXv2kfWxNeThumqpVGrQaDTg8Xh3LWX/+NvEjxowAZfL5eDTTz8FjRaL6TNckZr6IxQKRZ+FajQasXv3Hri5uSMpKQlzPL2wbt27pMpHqmTi4qiqqkJAQCCoVBoYjDjMnj0HBfkF3b4DAEar/xGJRDhw4CAmTZqC2Fg6vvjiC3R1dQ0Zcl8qlslkRqVSCZFI1ALgvyzl/3ibS30B1mg0poeB29DQgLfffseSZYrC7du3uxW6yeo5AJSVlcHfPwA0WiyoVBri4xMwdep0HD58BAaDoRvkoazHZf19oVCIN954EwEBgWAw4kCnM+Dt7YONGzd1UzGxWXsVg8GAK1euwtPTC1FR0Xj//ffR2traDfJQs14WyCbLKBCFSqUabSn/x6vikQAeCG5TUxNWrlyJ4OAQUKmxKCzsO2ginmu1WmzZsgVz5niCwYhDTAyVVNrUqdORlZX14MIYopIJQCaTCUeOHMW06TMQFxdv2TcVcXFxcHaehoKCgl7H1XMfAJCVlQ1PT2+Eh0fg3XffBZvNHjZkq7rYZHmcbV3+TwzwUNRLwGWz2Vi9ejWCgkLwyiuvoqqqqpvqrDfidWFhEWbMmAkGIw5UKg1UKg0xMVTExtIRHR2DiIhI1NXVkb9Tq9VWIygE4HA44PF4kEgkkMlkpCoB4ObNNMyYMRNxcfHkvqlUGqniDRs+JqP4viBbv5eXl0cez4YNGyAQCEjIw3TTeqPRCLlcHm8p/8cbaPUF2LoOHgyuWq0m27gbNmxAeHgEqFTakOBqNBps3LgJnp5eYDAY3SDExFBBpzPg5xeAlStXoaCgEL/+eg1bt27Da68tB53BQGRkFNnZQKPFYunSZfjyyy+RnZ2NzMxMREZGISoqGjRaLOkZrCG7urrh/v37vRTb81iJw8/JyYGHhyeio6nYtm07FArVsCHLZDI9AIjF4sVPHPBg6iXg6nQ67NjxFWJiqAgLC0dhYWG/cK0LMz+/AO7uHqDTu8OlUmlkfUynMxAREYnx450wdqwjfH39EBYWjqioaERHxyAmhoro6BhERUUjPDwCPj5+GD16LKZPdwGVSkNsLJ3cV8+Lx98/AO+//0G34K9fyJbIITMzE15e3mAw4vDvf+8fSbClBwCRSLTQ5gD3l6E6ffq0pZNgBm7dujUgXGv1btmyBZ6e3mTdS6PFIi4uHnFx8aTqYmmxSEhIxNy5SYiPTwCdziCh9WV0OgNz5yYhKWke6HQ6eREw6AzExycgNpZOQo6Li8fkyVNw7969AQH3/OzSpUtwcpqM5OQU3Lhxc0AV9xFsEQpe9LsCVqlU3ergwdRL5JZLSkqwcOEizJzpiu+//6HPAumroCorK+HhYQ6sYmPpYDDiEBEWDqexjnjuX8/Bx9sHwcEhmD3bA//42z8ww3kaYqJjyLqacLk0amw3VdJj6ZjtOgv//Zf/gvus2QgLDUdIcCicJ0/Bs//rgEA/fzAsFwmdzoCvrx8++OBDKJXKIUPW6XTYvXs3XFxcsXjxK6ivrycHEgxBxbYJuK9+XKFQiFWrVsPVbRY2bNhA5pMHLCTL4/79B+DiMhMJCYmIjIzCZMcJmP/qEqSePYu8wkKUVZSjsroapUwm7ubk4MiJE4iIiYH7TLdekGNiqGAw4hAcGIyZM13x9Tff4Lf791HKZKKqthaV1dUoLi3FtZtpWPfhh3B2moTQkFBzsymWjpkz3ZCfnw9g8MQK8XlXFw8rVrwOP78AfPLJJ6SC+4L8hwLc0zXTaLGIjIxGQ0PDoAVEgGez2UhOTkF0dAzCQ8MRER6BK9euo4vdDmFtHTqvpaHp2+9Qf/g4mk/9AF7WHYiamtHW0oo933yDiWMcSeXTLC7cw80dS19bjuLSUkjbOeDfvoeW735E3aFjqD/yLdovXIKIWQFxRyfu5uQgZf58+Pn4YW5SEjw85mD79h3QarWDXqDW51hUVAwPD08kJc3DjRs3/lCA+3XPhHpramqwcOEijB79Ms6dO0cWzFBcXFpaGpwmTkZYaBheeeVV1DU0QFbfiIqtXyHz+Wm4YW+Hm6Q9g5v29sh29kLLmfNQ8AT44exZOD4/GhHhEYiNpePF/2OP9z76CFxuB4R5hbhPT+6xDzvcsLdDmv1zKH57PSTMSrRzOFi5chW8Pb0Rn5AAT09vNDU1DQmwdQ/VwYMHMXHiZCxb9ho6Ozv7hGxzgLVarak/90yod+fOnfD29sXHH39C1l8DJSOI91UqFb744gt4zJ6DefOS0djcDEFeIbKed8ENeztk+0ciyycM6RPdSDjpo6Yi08Mf1+3twNz0JRTcDqTduoXo6Bj4ePvgyIkTEAkEaLvyK9Lt7ZA+eRYy3XyRPnoq0hwmIcPZHVneIcgOikbavyYjzd4OXbfvorWtDfOSk0GNocLdfTZ++umnAQH3dQHzeDwsXLgIERGROHny5KAqfuKAVSpVv4BVKvOIRyaTiQULFsLHxxfHjh1DR0dntxO37svtCZjL5SIsLBwuU6bjt9xcSMqrkG5vhwwXb9wKjkG6wzjcmumPsk++QNPPl9B89TqY277GbfcgZDi64oa9HQrfWgNpbQNYLBZq6uohb+ei7si3ZpU6jEPWFC/kL3kL5Tv2oPrfh1H6/ie47RmCNIfRyPaPROacAKTZ20FSXoXsu3cxffJU+PsH4r333usVbFmr1XrjcLhgMplgs9m4fPkyXFxcsXDhIrBYrAFVbBOAB0tu7Nz5NSIiIsFgxCExcS4WLFiIvXv3oba2tt8rnyig7OxsUCgUfL51K6TcDuS//jbSHJxwK5SKdIexYG7fBXkrG3qVmozIjFotZC1tKNuyAxkvuyD9pRnI9gxG7b4DaDh6AveSFuOmvR0yxruiYudeSBqboZXJYFCpYNRooFMooeB2oPboCWQ4TER2YBRu2o9ByfsfQ8DpwNp318PX2wdRUdGorKwkL9K+tvr6evz73/uxaNFihISEIjk5GRs3bsKiRYsRFRWN779P7Qb1DwOYqHsbGhowd24SmSGKjIxCSEgoXFxmIjAwCD/99BNyc3NRU1MLuVzRq4AOHjwECoWCrHt3wcvJww17O9wKi0Wa/TOo+vchGHW6PgsWAAxqDWoOH0e6w1hkeQWRdWvGNE9kODih6cIvGGz4B+vny8hwcEKWXzgyHMZDwqxE6oULcJs6A2PHOpK5b2JTKpWora1Fbm4uzp49i9DQcEyf7oKQkFBQqTSEhobD19cfiYlzQaXSsGDBQnR28nqp2KYAW7vonsHV0aNHERcXTyYMaJZsEYMRBxotFk5OkzBxojPo9DisWbMW33zzb9y+fRudnZ2QyWT49JNP8ZLzFLQ2NaP+6AnctLdD5gxv3Et+BSoe36x4gwEmoxFVVdU4efIUjh09hrbWNgCATipD4dvrkf7iVNwKjsGtECrSHZxQ8tlWGHU6shnW1dmF69ev4/R3p1FXWweTpRfLpDegZOMWpI82B3PsjGzczcvDHNdZ8PLyxv79B8DhcHDv3j188803WLduHeLi4jB5sjPGj3cClUpDXNyDCJ5OpyMmhooVK15HQkIiGHFxuHLlyh8LMPEoEAjwzjtrEBYW3mfu2Hzy8YiLi0NUVDS8vX3g5jYLU6dOR1RUNDZt+gwpScmgpySji9WC8vc/RfpEN6TbO6Du21Nm12jpHszKysLLLzvB29sXFAoFX3yxBWqVCgDQmZOPzOemI8srGFneIcj8lzM6frvfzY3On78AU6ZMg4uLK/z9A8jcOAB03s9DpqMbbtjboencRTCZTHj7+IIaQ0VCwlyEh0dixoyZcHWdBS8vH0RGRoHBiEN8fHy3cyVSqiEhoXh33bvYvm07goJDsGnTJtsLsgQCwZy+XLR1cJWfn4+5c5NI9T7IGVsn8qnk+3Q6AwxGHJmK9PcPQGhQMJJefRWdTSww129A2jgXZLw4A9zsO2b1WurrDRs2wMfHF0lJ8xATQ8WSJUvB4XAAAFq5AjnL3kTGeFdkufjgTuxcKLt4pHq/++47jB49FklJ85CcnIIXXhiNCxcumPcPQMUX4FYwFdft7dB89jyYZUx4+/qBZgWPwSCOndErl21tsbF0+Pj4YuPGTcjPz4enpxcWLVqEiooKqFTmVQBsDnBfLlqr1eKnn84gKiq6G+CBLIba/UpnMOJAjY5BKJUKTjMLtXsP4Ib9M8ic4glhhVlhRHCTmvojnnnmBcyfvwCzZs3GBx98SHYKGPV6lH22DenPT0HGxNm4t3gZ9BoNCfj8+fP4xz8ckJQ0D4mJc0GhUHDt2jUSsEYixf2kxfjV/p9oS89ETmEh3Ka7POiYoPX2TP0ZnU6Hp6c3PvvsM3A4HKxZsxYBAYHIyMjsM9B6ki66XwVrtVqIxWK89tpy0GixSEyc+yAXTIsFjTY4bOsrfua0GcgrKkR7eiau29shc4YPBCVlAECO4BCJRPjoow2gUCjw8vJGbm6uGa7JBKNej4odu5H+rDOyJnvg7sKl0Fn1A7e3t2PNmrV44YXRmDzZGdu3bwefzyc/10ikuBeXgpv2dhAWFOPi9WuYOGpstz7p4ZyPv38APvn4E+h0Ovz4o/nC3Lp1K6RSme246MEAd3V1ISEhAQkJiXjrrZWIjIwadmGYR1PEw9nRCQePH4e8uRV3QmNx094ObVeukwomVCyRSFBcXNItw2SCGXDRux8h/cWpyHT3w+1QGmSslm4eQCgUoqysDJWVlQ8SMZaLR9nFQ4ajK+4lLYKE1YLtu3bBZep0M+BBFNtbweYOiy+++AIAcPfuXUydOh3JySng8/l/HMB37twBlUrD8uUrsG/vPgQEBg1YN/VnRNOKRotFY1MTWD+cwVW7f6Js606YjEbzTAVj78SCyWQiAclYrbgdREWmux9uhdGQbu+AFuICMRj6bMMajUby99zbd3HN/p+o3rsf7RwOkuclIzQ0bMhVj7UxGAzMnu2BQ4cOAwBaW1vJuKOqqqpXoGWzgHfv3g0/vwBy3pCLi2ufHfWDKTg2lo7Q0DAkp6SA3dqG+mMncdPeDlmObugqKCYhmXrcxNJoMJB1bNU3h5DuMBqZk9yRPnoaMqbOwf0FS6G2NLOMej2MBqvfWuCaABg0GhR/+Clu2NshZ+FSSFvbsP/oUbg4T7O46OEpOC4uHpMmOePy5SsAzGPM1q5dh8jIKHz33Xd/HAV/tXMnJk1yxqXLl1FWVoZRo8aMqM5iMOLgNGosLl27Bml1HTIcJiLLKxgZ0zxxl5ECSWMzGQz1NWa57WYGMl6chgxnDxR/+jmK3tuAzLEzke4wEaUbt0AjEj/4vZVZ3ACazv+CDIfxyA6JwQ17O7Sc/wWNjY3wCwgEbdhVjnkE6D//+S9yFIter8fu3Xvg5eWDr7/e/cdR8Pbt2/H3vzugsLAQbW1tCAwMJl3ucNxzVEQkElJSwG1jo2bvfnMHg18Esn3Ckf7cFNyNSQT39l3oVSozXEteW80XoO74KWS8OA3ZPuG4YW8Hzm/3YNLqULLpS2S8NAPpz0xB3orV6MwtgE6hMLtrgwFGvR7yVjaq/n3IfEF5BiLbKxgZbr644xMJSUsrDn/7LWY4T+02snPw8yGaSX7dukvPnTuHKVOm4euvv/5jKFgikeCjjz7C00//Hc3NLCiVKqxe/Tb8/PwtbnrwAiGGyIx/6WX8eO48xPWNyHppJrK8gpA1JxBZHgHI9g1HhrMHMhwmIe+Nt1HzzSE0nPwe5dt34W7CfKTZP4Ms72Bzr5C9HfjMCgCAqKYOWZPmICsgAuljZiDzX1ORs+wtlG3eioodu1G0fgNuh8Yi3eF5ZHkHI8szyPx/fhG4bm8H9qWrKK+qwizXWcOoh80jSAIDg7By5cpuUfrt23cwatQYfPbZF7bTDh4IMJvNxorXX4eLiytaW1sBAEePHsWkSc6Ii48fEmBC6X6+/qipq0NL6llct6g3a04gCTnLOwRZ3sHIeHEq0hxeQpr9C0h3eBkZE93N3/UOwU17O9QcPg6j1pyaNBkMqPx6nzmvHRBl/v2oaUh3GI80B0ekO0xE5nSvB//lEYCsOYHI9glD+nNTkLf0TUjYHGz84gu4u84yq3iwC5b6YEzX4cOHSfUCQHV1NSiUp/HOO2vAZrNtH3BVVRXi4+MRGhqGtjZzTvj+/fvw8vIZ0hUfQzUPqXF3dcOnn38OCbsdua+9hfTnpiDbJ+wB4DmByPIIRJZnELJ9wpDtE45s33Dzo0+IWe2TPVD37XcwaDRkQAYAGqEIbVdvICf5VWTO8Lb8LuyBeQV3/x/CfMORZm8HQWExrqanY/KYcUOOLWLpdHh4zMGdO+YsHNGGZ7FYeOaZ5/H662+gsrLStgFrNBoUFBSARotFfHwCmS4US8RYsWIFQkPDhwSZwYiD81hHXLx+HcKiUqTb2yHLN6zvQu9pHoHI9g5B+kQ35KQshU4ifRBtWzefWlpxOzAGma6+5jz1oPs1u+kb9naoP3YSLY1NCI6MREx0zJA8UkREJBYvfgUikagX4OnTXfHaa8tRXFxs+4BzcnJAo9Exb14yuFwuWddcvXoV48aNR3x8wqCBCY1KwxxvH9TW1KD57Hmze/aPHA5ySCIAABdnSURBVBpgwrxDkPGvKWi5eoN0iUTbGSYTKvfsx83h7tcrCOlT5yAvcRH4La1479NPEejrN+BFGxNDRXx8AsaPd8KFn38my4Nw0S0tLZgzxxOvvroERUVFtgW4rzFZubm5oNFikZQ0rxtgHo+PhQsXISwsHHQ6o1/INFoswoJDsPStt9DFakHJynVIe9mlf7fZj9qyvILN6nxuBoRMc8e8Qa8HAEgam5Ht7IXMOQEPArfhQHYYD0F5JS5evoIxz4+ymsvUu7qJjaUjIiISc+cmoaOjwwLX1A3w7NlzsGTJUhQV2YiChUKhZ3+ACwoKEBsbCzo9HhwOt5s7yszMxIQJE3vN/+nunhlwn+mKfYcOgd/UjNseQch08zVHs8MBYXGpaQ7jUPzhp9ArlOYgy2hE1TcHkWb/HLJ9I8ggaqiW7WtudnGv3EBBURFGjxqDuLj+6mGzeh0dJ+D6dbMnsZ4GS7joKVOmY/ny5SgtLbUtwCqVythzVkN1dTXmzp2LgIAgMsgiTkar1eLrr3fB1XVWv646Pj4B//PX/0ZaRiaEeYWW5k7I8OBaA/GPQLq9HYQ15klpbTfSkeEwYcT7JOrhmm8OoL6xETQqDVGR0X1OeYmPT4C7uwe+/HJrr+mnRJk0Nzfjb3/7X6xYsQL19fW2MapSKBR6ajSaPsdFt7e34623VmLy5ClkM8l6BCWfz8fy5SswZ44nEhISe0GOY8Rh7EvjkF9YCM4vV83JDd/wkQP2CUOa/Quo+y4VLZd+RdZz05A5y88cWA1TvVkeZgWn2b+Iwvc3oKO1DavXrIGfj5+52qE+GFwfn5AAL28fLF78Cjo7O7vBtX5eUVGB//zPf+C9995HR0eH7QC2mpvUTcFSqRSffPIJnn32RVRXV5sB97hq29ra8OqrS+DhMQcJCQnk3CLiMTgoGJXV1ai3jH7s1v4drlnq46wJs5Bmb4csT3M9Omy4xAXjHYIMZw/cjUmErImF7Xt2Y5rTZLIeJgbXe3l5Y/78BWhmsbqdOwnY8piZmYVx48Zj69atvW4wZiuAe0H+6quvMGnSFGRmZlqu1gcnRpwoh8PF++9/gHHjxpNzhWi0WISHhWPevGSwWlpQvnOPZfxzhLnN+5CQs33DyczUiPflFYRMD39kO82BtLIGB0+cwKQxjmRcER0dA0dHJ6xdsxZsSxXV35RYk8mE77//AS4urti1a5dNTT4jXXTfgHfCw8MTx48ff3ByfUCWy+U4d+4coqKi4evrj7i4ePj7+eONlavAaWah+KNPcdP+uYdy0Y/cPIPMTTCH5yEoKsHpc+fgPHZ8t0j6xx9/hFRqbn+bjP3PmjQajdi2bRv8/ALw9de2C7jX8g379+9HUFAwNm7c1GvdjJ6QAfPAt48//hjh4RHw9fLB+o8+Ar+xGflvvI00h0m9M1hP2vzMGa2uvAJcuHoVU8ZNQHx8Anx8fMnppX255Z6AlUolVq1ajejoGFy+fNm2AFtPPlOpVN0AFxQUgEqNxcKFi8Dj8foETLxHvH/r1i2MGTMO/j5++PizzyBqbEbuKyuQPmaGzQHO9o/ATXs7dN7Pw5W0NEwbPxF0OgOhoWHk+Q5lYl11dQ1iYqhITJyL1tZW2wLcl4IJyHw+H0lJSfDx8UVeXl6/gK0LIicnB88/Pwp+3r74dMsWiBtZyFmwFOnjZppzyzYAlgQcEImb9nbouJ+LXzMyMG3CJMTGmsc8E6nIgSalEeecnp6OiROdsWjRIvD5fNsDrFKpjJo+VtmRSqV47733MGrUmEFnExInW1xcDGfnqfD19sGGTZsgbGpG7pI3kD56mu0qOCcPl2/exHSnSaBSzTMVJBLJgICJ9w0GAw4ePGTpYTrS5y16bQJwTwUTkK9duwZfXz+sX79+wJN+sABZNULDwuHj6Y13P/wQvKZmFKxcgzSHiTYHmKiDeXkFOH/lCmY4TUZkZBTWrl076MT2B5PCuzB3bhJotFjcvn0bSqUSMpnMtgD3XGVHrVZDLpdDo9GguLgYr7zyKqZOnY6ampr+AVvea2G1YP78hfDx8sGKN95Ae0sLijd+bu4Q8HvIZlJPBQ437Wn9O88gZHkHI9NhLATFpfjuzBnMnDwVAQGB2LNn75Anhufm5mLUqDFYseINNDY2Qqk0LytsU4CJ9aKtASstC37J5XJ88skncHKajJMnTz5wUei7TSiRSLF+/XtwnzUbSXOT0MRioXLPNw/awU9atYR5BSNzth9uTfGBrLoO+48fh9u0GZg2bQYuXbo0IFRrFW/fvgNeXj7YsWMHuaqOzbno/labJe5U8tNPZ0Gl0rBo0WJ0dPRO1/WEvG/fPkyZMg3BQSFgVlSg6cTph89kPWLL9g5BupMr7iUuhLS5BVu++gpes+dg3LgJyM3NIwH2BxYwNwujo2NApzNw//79PtX7RAHLZDIvK8C9IBMq5nK5WLRoMcaPd8KVK1cHBZya+iO8PL3h+PJ45Obno/N6+kPnoh+pWcaC3bS3R/HHm8BpbcUbb61EgH8AYmKoZFXUF2Dr8z516hTGj3fCO++sgUQisXnA5GjAvgKukye/Q2BgEJYvXwGBQNAnZOJ1Xl4egoKC4TjmZVy8cgWCsgqkOziZc8eeNgB4zoPepPrDx1FdW4vIiCh4e/tg3bp3Bwwmiffa2trIUSvXr1/v1z3bPGBCxY2NjVi6dCkcHJ7D1at9q9i6pyk2lgEvdw9s+WoneKwW3AujI2OG9/A75h8XYJ8w3LC3Q1daFnLy8uA4bjw8Zs/Bvn3fDAoXAE6cOIGJEydj9eq30dXV1a96bRJwfyo+duwYIiOjkJKyAO3t7b3cmPWiK59//jl8PL2QsGABOppZqPxsO246ONpGU4nwIuNcIairx3epP2Lm1Onw9fVHdvatfgFbj6AMD48Anc4gU5M9m0ZWcMmlDG0KsDVkQsUcDgdLlizB5MlTcODAQRiN3ddptk6CXL9+HWPHjIO3pxeKSkrAvplhrocDoh5pU2lE5hWCtHEuKH5rLfitbVjx9tsIDQpBeHhEn32+1q81Gg02b96MWbNm4/33P4BYLB5MvbahYPUgt7YjIN+4cQNJSfPg5jYbeXm9V4qzjjDpdAYmvTQOx77/HtLaemRP80Gmu9/QRj8Oxc2OpB3sEYDsgEhct7dDy8VLqK6qhq+fP7y9vLFz59fQaHq3f60v3Bs3bsLJaRLmz1+A3NzcQdVrE4CVSqWxL7jWkAnAKpUKmzdvRlBQMJYuXWY1AM3YrWD0ej2+/PJLjBk1Bstffx1cNhvML3eYEx5PMpr2CkLmbH9kTZgNaU09vjtzBm5Tp8PFxbXfZYatL1oaLRbR0VQcOHCgT6h9AX7iLtoCeNDbyxKQWSwWli5dilmz3LFt27Ze45SIx4yMTHjO8cJExwn4LScH/Ls5T7y5ZG4e2aF8605w2e1Y9tprmOXmjjfeeLPP1gEBVyQSYc2aNfDy8sbKlSvB5XKH4pptQ8HDuUE0AfnuvXtISZmPCRMmIjU1tU93JhQKsXjxK/Bwczf3LHG4yF/2FtIdZyL7IQbgjdhFewQiywJYWFiCrDu/YZKjE2a7e+Bny1jnbnCt6t19+/Zh4kRnLF78CsrLy4fqmm0HMNGGGwpkwk6cOIHExCS4ubnjypUrvQISAPjll1/gMmMmPGbNRmFJKTpv/WYJtoY5AP5hjUxuvAzmp1+Az+Hi7XXvItDPHwkJib2CK+veolOnvoOr6ywkJ6fg/Pnz3SAOAa5tuGilUmkiDnIwyISK1Wo1du/ebV6iwXkaOXbL2rXxeDwsXbYME8dNwCeffw5pZxeK3nkPaQ6OZlf9EOOqhqVgyxCddHs7SCqqcTM7G1PGO8HVdRap3r4u0J9//hmOjuaRHgcOHCJBDtE124aCewIeDmSVSoVt27ZZFiYJRHp6Ri/IaWnmG2W4TXfBrXt3IS6vNM9T8gn7fTJbHgHIDozCdXs7NJ78Hh0cDha98grc3dyxcuWqbp371rfXuXDhZ3h4eCI2lo5du3aTih0m3CcK2NsKcK8DHgwyccNlmUyGL7/cilg6A5MnT8GlS5e6qUCv12P79u1wd3PH3KR5aGe3g/XTOfNcpcDH3C4mZkY854y8xSug6OJh/5EjcJvugsCgIHJRcGu4arUap06dwrhxExAbS8fXX+8ioY4Arm0AVqlUppFCVqlUkMvl2L59O+LjEzBr1mycOnUKSpUKRqMRGRkZWLVqNahUGjzc3PHVrt1QCEUo3bQF1+3tcCso+uGGwA4E1yccGTO8kO00B7LaemT/9hucrabdbNnyJXJzc7ut1LNnj/mObPHxCdi9e/fDwn2idfCggIcDWa1WY+/evZg7Nwn/+Ic99uzZix9+SMWLL76E4OBQxMbSERcXj7H/eh4/nT8PFbcT+StW44a9A7IDHzFkS1CVOcsX6fZ2EBWXorquDoEBgeZFVS0zCT08PPHCCy+hsrISLBYLK1euwqRJzkhOTsHBgwdHWufanoIHa7QPBtp6Ec7U1FSkpMyHt7cv/P0DyUVLre9wNnPaDFzPSIeKzUH+ayvN7jo4emRTUXqAzZoTiOzAKKQ7zkSmgyOEBUVobmnBvKR5CAkO6TYrkhiov3HjRqSkmFfYW7JkCc5ZouVHANc2AA+k4JFALi4uxvLly0m4xPJLxLQQagwVLtNm4HpGBlQdXWB+ucO8Ap6lzhz2LEQisvYJQ5afeebgvZi5kFZWo6G5GYmJifDz9QMjrvuCK8Q6IsHBIYiMjMLKlavIdu4jgvvkASsUiiHBHQpo6/Y0m83Grl27kJCQSK53SaiHWCNy5rTpSD17FgqBEG0XLyNr1EzcsLdD1hxzzjjbN9ys6v6AewYh2zvEPAHcOwRpDhNx094O1Xv3Q9HOQW5BARh0BoICg3rN/yXuxxQZGYV585Jx8OBBMkNlqTsfBVybAGzsr7N6pGqWy+Xk8zt37mDlylWg0xmIioom1Uwoe/yosfhi2zY0NTdD2tiMmj37kTnOzbJc/1hkuHgj0zMQWT5h5uWX/CPMKvcJQ+acAKSPdyVvyFGy/iMIi0oh6OrC92fOYIrTJISHhXe7ERcBNioqGgxGHNavfw+5uXnkefWXoRohXNsBPBLIg6mZeC4SCXHu3DksWbKUBE3UxwkJiZjt5o6IyEhc+vVXdHA4kNbVg3XmPIo/+AT3whjIfm4m0q3upnLT3g4Z9na4PdkbeYuWo/bwMYgKiyHkcJGTn483Vq7ENKfJ5htnWVlMDJUE++abb+Hy5ctkl99ALvkh4NoGYLlc3m/67VGC5nA4+OWXX8jV0qlUGiIiIpGYOBc0Kg2OL47BgsWv4uzFi2BWVYHf2gZxQxP4ldXglVdarML8WFEJYXUtJC1taGpqwvXMTLz7/gcY8+JLCA4MQkJiIgk2MjIKdMut7tasWYu0tDTweLwhgX1IuE8WsFar7QX4YSD3B5uo04jXQqEQ2dnZ2LJlC15dsoSMsuPi4hEaHIJR/3wWwQFBePOdd7Bx61bsO3IEp8+exc+//opL16/j56tXcerMT9hz6BA+3LQJCQmJmDBqLAKsbmNnHUS9/vob2L79K+Tl5ZED5Ah3/JhUaxuArVy0qeeBPSzk/kD3fL+2tha3b9/G3r17kZIyH8nJKVi8eDHi4uLh6+0L1ynT4fzyeDg++wLG2j+Dl+2exbh/vQCnF8dg2viJcHdxRXhYOBISEpGUNI+8UeWiRYtx+vRp3Llzp9eksIGCqEcM98kmOggFD3SAjwJ0T+jEvnvCFwgEaG5uxsWLF7F7927s2rUL27Ztx4YNG7By5SosX74CK1a8jmXLXsNrry3HmjXrsHHjJmzfvh07duzAnj17cOvWLXC53F4TwQiovxfYJ65gkUjkYwW4l4IfJ2RrI6qH/upxpVIJPp+P1tZW1NXVoby8HJWVVWhsbER7ezskEumA+x/MDT9muE9OwcMB/HuAfpL2OMBaeYwn5qJ9+guy/n8B/bjAWlcHjw0wgL9Y7CkAf7XY0wD+1hPwUBX8ZwH9OMH2gEsClslkr1AoFMqtW7f+y8LiKYv9BcBfBoP5lAXe05YfD/wDCoUilUpna7VayOVyY48DGtBkMlk3G85vbcF6Hn9/1t93h7N/a8ByuTx+CIL8qxXDp4YC/f8CGA1gml6vDzAYDHP1ev2HOp3ukFarLbREr6bBVDnQ2KyhmEaj6fbYc0Wf39uGe/yE9RcEDuIdjJZbBWYYjcY1BoMhAYCnTCabCOB5AH8fUJAAnpJKpU4GgyFRr9dv0Gg0xzUaTZpWqy1Tq9VsjUYjValURr1lEU9iU6vVEAgEJj6fDx6Ph87OTnC5XLS3t6OtrQ0tLS1obm5GY2Mj6urqUFNTg6qqKlRUVKC8vBxMJhNlZWUoLS1FSUkJiouLUVRUhKKiIhQWFqKwsBAFBQWk5efnIz8/H3l5eX1abm7uI7W+/oM4hvz8/G7HRhwvcfzFxcUoKSlBaWkpysrKwGQyUV5ejoqKClRVVaGmpgZ1dXVoaGhAc3MzWlpa0NbWhvb2dnC5XHR2doLH44HP50MgEEAkEhl1VjfhtKysoFWpVEK1Wt2i1WpL9Hr9TYPBcEKr1X5mMBiiAYwD8DQFgJPRaKxDP5vJZIJarYZEIoFAIDDyeDwdl8vVtLe3a9lstqGlpUXf2Nior6+v19fU1OgrKyv1TCZTX1xcrM/Pzzfcv3/fcOfOHUNWVpbh5s2bxmvXrhkvX75s/OWXX4wXL140XbhwwXTu3DnTmTNnTD/++KMpNTXV9MMPP5hOnz5tOnXqFE6ePIkTJ07g22+/xfHjx3H8+HEcO3YMR48exZEjR3DkyBEcPnwYhw8fxqFDh3Do0CEcPHiwlx04cIC0vj4/ePAg+Xtif8T+jx49imPHjpH//+233+LEiRM4efIkTp06hdOnT+OHH34wpaammn766SfTmTNnTOfOnTNduHDBdPHiRdMvv/xivHz5svHatWvGmzdvGrOysgx37twx3L9/35Cfn28oLi7WM5lMfWVlpb6mpkZfX1+vb2xs1Le2turZbLaey+UaOjs7dTweTycQCEwymYxcRaC/Ta/X3wXwIqFiO4VCMcNgMMTq9fr1Op1ur16vP6fT6e5pNJo6lUrVqVar5Uql0qjRaKDX68kbUhmNRuj1euh0Olj6hyGXyyGRSCAUCsHj8dDR0QEOh4O2tjawWCw0NTV1U3Z1dTWqqqpQWVmJiooKMJlMMJlME5PJNJaVlRlLSkoMxcXFhuLiYkNRURFhesIKCwv7tYKCggGtj+8bCgsLSbP6P/IYSktLjWVlZcaysjIjk8k0MplMY3l5uclapdXV1aRSGxsb0dTUBBaLhba2NnA4HHR0dKCrqwsCgQASiYTshdJoNNDpdA9u72NVxhY3r1UqlWKVStWq0WgqdTrdXY1Gc1Gn0+3VaDRrDQZDLIBJAP5jsDiKgP80gH8CGAVgCoDZGo0mzGAwxOl0usVGo/FtvV7/vkaj2a5Sqb5Rq9XHlErlBaVSeUWhUKQpFIo8hUJRLJPJmFKptF4sFreLRCKuRCLpEovFIoFAoBKJRBqhUKgVCAR6gUBg4PP5EIlEkEgkkEgkZDKjZ11v/ThAFPrIgympVAqpVAqJREI+F4lEEAgEJqFQqBeJRFqRSKQRCARqsVgslkgkXSKRiCuTydhSqbROJpMx5XJ5sUKhKFYqlTlqtfq6Uqn8Ra1WH9NoNHvVavUWvV7/nkajWaPT6ZYYDIY4jUYTCmAWgAkAngXw34MFw+TnPSKw/xhOND2czbLf/7EEBv+0HOgYS33hCMAJgLNCoZgBYLZer/cB4KvRaMINBgPNYDAwDAZDvMFgSFSpVEkqlWqeSqVKVigUKSM1lUqVLJfLk+Vy+Ty5XJ6k1WoTtVptglarjddqtQytVktXKpU0pVIZo1QqozQaTbharQ4BEKDX6/30er2PXq/3thT+NIt6xlvOaSyA5yzn+nfLuT/SRMVg7P4fMkBkQqYa3GwAAAAASUVORK5CYII="'+
	                        		' alt="Spyral Notebook" title="Spyral Notebook" style="float: right; padding-left: 1em; padding-right: 1em;"></a><article>');
	                        myWindow.document.write(contents);
	                        myWindow.document.write('</article></body></html>');
	                        myWindow.focus();
	        			}
	        			btn.up('window').close();
	        		},
	        		scope: panel
	            }]
			},
			bodyPadding: 5
		}).show()
    },
    
    init: function() {
    	if (this.docsLoading>0) {
    		var me = this;
    		return setTimeout(function() {
    			me.init();
    		}, 100);
    	}
    	var queryParams = Ext.Object.fromQueryString(document.location.search, true);
    	var isRun = Ext.isDefined(queryParams.run);
    	if (queryParams.input) {
    		if (queryParams.input.indexOf("http")===0) {
    			this.loadFromUrl(queryParams.input, isRun);
    		} else {
        		this.loadBlocksFromString(queryParams.input, isRun);
    		}
    	}
    	else {
    		var url = location.href.replace(location.hash,"").replace(location.search,''),
    			url = url.substring(url.indexOf("/spyral/")+8); // grab after notebook
    			if (url.charAt(url.length-1)=="?") {url = url.substring(0, url.length-1);}
    			urlParts = url.split("/"), notebook = urlParts.shift();
    		if (notebook && urlParts.length>1 && url.charAt(url.length-1)=='/') {url = url.slice(0, -1);} // remove trailing
    		if (!notebook || notebook=="new") {
    			if (this.getSaveItTool()) {this.getSaveItTool().setVisible(true);}
    			this.loadData(undefined, isRun);
    		} else if (notebook=="gist") {
				return this.loadFromUrl(url, isRun);
    		} else {
    			// special compilation of a notebook series
    			if (url=='alta' && queryParams && queryParams.all && queryParams.all=='true') {
        			this.loadFromUrl('alta-start', isRun);
        			this.loadFromUrl('alta-create', isRun);
        			this.loadFromUrl('alta-smaller', isRun);
        			this.loadFromUrl('alta-tables', isRun);
        			this.loadFromUrl('alta-scale', isRun);
    			} else {
    				if (url.indexOf("/")==-1) { // assume stored resource, which means no .json in resources/spyral (but subdirectory is ok)
    	    			if (this.getSaveItTool()) {this.getSaveItTool().setVisible(true);}
    				}
        			this.loadFromUrl(url, isRun);
    			}
    		}
    	}
    	
    	var me = this;
	    window.addEventListener("beforeunload", function (e) {
	        if (me.getIsEdited()) {
		        var confirmationMessage = me.localize('editsAndLeaving');
		        (e || window.event).returnValue = confirmationMessage; //Gecko + IE
		        return confirmationMessage; //Gecko + Webkit, Safari, Chrome etc.
	        } else {
	        	return undefined
	        }
	    });
    },
    
    setIsEdited: function(val) {
    	if (this.getSaveItTool()) {
    		this.getSaveItTool().setDisabled(val==false);
    		if (!this.getAutoSaveTimer() && this.getMetadata().previousNotebook) {
    			var me = this;
    			this.setAutoSaveTimer(setTimeout(function() {
			    	 Ext.Ajax.request({
			    	     url: me.getTromboneUrl(),
			    	     params: {
			    	    	 tool: 'notebook.NotebookManager',
			    	    	 jsonData: Ext.encode(me.getExportAllJson()),
			    	    	 notebook: me.getMetadata().previousNotebook,
			    	    	 autosave: true
			    	     },
			    	     scope: this
			    	 }).then(function(response, opts) {
			    	     var data = Ext.decode(response.responseText);
		    	    	 me.toastInfo({
		    	    		 html: data && data.notebook && data.notebook.notebook ? me.localize('autoSaved') : me.localize('autoSavedFailed'),
		    	    		 anchor: 'br'
		    	    	 });
			    	 },
			    	 function(response, opts) {
			    		 me.showResponseError(me.localize('autoSavedFailed'), response);
			    	 });
    			}, 30000))
    		}
    	}
		this.callParent(arguments);
    },
    
    listeners: {
    	boxready: function() {
    		this.init();
    	},
    	
    	notebookWrapperMoveUp: function(wrapper) {
    		var i = this.items.findIndex('id', wrapper.id);
    		if (i==0) {
    			Ext.Msg.show({
    				title: this.localize('error'),
    				msg: this.localize('cannotMoveHigher'),
    				buttons: Ext.MessageBox.OK,
    				icon: Ext.MessageBox.WARNING
    			});
    		}
    		else {
    			this.move(i, i-1);
        		this.redoOrder();
    		}
    	},
    	
    	notebookWrapperMoveDown: function(wrapper) {
    		var i = this.items.findIndex('id', wrapper.id);
    		if (i==this.items.getCount()-1) {
    			Ext.Msg.show({
    				title: this.localize('error'),
    				msg: this.localize('cannotMoveLower'),
    				buttons: Ext.MessageBox.OK,
    				icon: Ext.MessageBox.WARNING
    			});
    		}
    		else {
    			this.move(i, i+1);
        		this.redoOrder();
    		}
    	},
    	
    	notebookWrapperRemove: function(wrapper) {
    		this.remove(wrapper);
    		this.redoOrder();
    	},
    	
    	notebookWrapperRun: function(wrapper) {
    	},

    	notebookWrapperAdd: function(wrapper, e) {
    		var i = this.items.findIndex('id', wrapper.id);
    		var xtype = wrapper.getXType(wrapper);
    		var cmp;
    		if ((xtype=='notebooktexteditorwrapper' && !e.hasModifier()) || (xtype=='notebookcodeeditorwrapper' && e.hasModifier())) {
    			cmp = this.addCode('',i+1);
    		}
    		else {
    			cmp = this.addText('',i+1);
    		}
			cmp.getTargetEl().scrollIntoView(this.getTargetEl(), null, true, true);
    		this.redoOrder();
    	}

    },
    
    redoOrder: function() {
    	this.query("notebookwrappercounter").forEach(function(counter, i) {
    		counter.setOrder(i);
    	})
    },
    
    loadFromUrl: function(url, isRun) {
    	var me = this;
		if (url.indexOf("https://gist.github.com/")==0 || url.indexOf("https://gist.githubusercontent.com/")==0) {
			url = "gist:"+url.substring(url.indexOf(".com")+5, url.length - (url.charAt(url.length-1) == "/" ? 1 : 0)).replace(/\//g, ":");
		}
		if (url.indexOf("gist:")==0) {
			var gistParts = url.substring(5).split(":");
			if (gistParts.length<2) {
				return this.showError(this.localize("invalidGistUrl"));
			}
			if (gistParts[2] && gistParts[2]=="raw") {
				gistParts.splice(2,1); // remove raw
			}
			
			var gistUrl = "gist:"+gistParts.slice(0,3).join(":");
			window.history.pushState({
				url: url
			}, "Spyral Notebook: "+gistUrl, this.getBaseUrl()+"spyral/"+gistUrl);
			url = "https://gist.githubusercontent.com/"+gistParts.slice(0,2).join("/")+"/raw/"+(gistParts[2] ? gistParts[2] : "");
		} else if (url.indexOf("http")==0) {
			window.history.pushState({
				url: url
			}, "Spyral Notebook: "+url, this.getBaseUrl()+"spyral/?input="+url);
		}
		
    	me.mask(this.localize("fetchingNotebook"));
    	 Ext.Ajax.request({
    	     url: this.getTromboneUrl(),
    	     params: {
    	    	 tool: 'notebook.NotebookManager',
    	    	 notebook: url,
    	    	 noCache: true // make sure we load most recent
    	     },
    	     timeout: 60000,
    	     scope: this
    	 }).then(function(response, opts) {
    		 me.unmask();
    	     var data = Ext.decode(response.responseText);
    		 var json = me.getBlocksFromString(data.notebook.jsonData);
    		 json.metadata = json.metadata || {};
    		 json.metadata.previousNotebook = url;
    		 Ext.applyIf(json.metadata, {originalUrl: url});
    	     if (json && json.metadata && json.metadata.url) {
	    		 var jsonMetadataUrl;
	    		 try {
	    			 jsonMetadataUrl = new URL(json.metadata.url);
	    		 } catch(e) {
	    			 // ignore
	    		 }
	    		 if (jsonMetadataUrl && jsonMetadataUrl.hostname!=window.location.hostname) {
    	    		 return Ext.Msg.confirm(me.localize('differentUrlTitle'), new Ext.XTemplate(me.localize('differentUrl')).apply([json.metadata.url, window.location.href]), function(btn) {
    	    			 me.loadData(json, btn=='yes')
    	    		 }, me);
    	    	 }
    	     }
    		 me.loadData(json, isRun);
    		 
    		 // look for an autosave
        	 Ext.Ajax.request({
        	     url: me.getTromboneUrl(),
        	     params: {
        	    	 tool: 'notebook.NotebookManager',
        	    	 notebook: url,
        	    	 autosave: true,
        	    	 noCache: true,
        	    	 failQuietly: true
        	     },
        	     timeout: 60000,
        	     scope: me
        	 }).then(function(response, opts) {
        	     var data = Ext.decode(response.responseText);
        		 var json = me.getBlocksFromString(data.notebook.jsonData);
        		 if (json && "metadata" in json && "modified" in json.metadata && json.metadata.modified>me.getMetadata().modified) {
    	    		 return Ext.Msg.confirm(me.localize('autoSaveAvailableTitle'), me.localize('autoSaveAvailable'), function(btn) {
    	    			 if (btn=='yes') {
    	    				 me.removeAll();
    	    				 me.loadData(json, isRun)
    	    			 }
    	    		 }, me);
        		 }
        	 },
        	 function(response, opts) {
        		 // ignore
        	 });

    	 },
    	 function(response, opts) {
    		 me.showResponseError("Unable to load specified notebook: "+url, response);
    		 me.unmask();
    		 me.loadData()
    	 });
    },
    
    loadData: function(data, isRun) {
    	if (!data) {
    		data = {
    			blocks: [{
    				type: 'text',
    				input: "<h1 style='text-align: center;'>Spyral Notebook Template (title)</h1><p>This is a Spyral Notebook, a dynamic document that combines writing, code and data in service of reading, analyzing and interpreting digital texts.</p><p>Spyral Notebooks are composed of text blocks (like this one) and code blocks (like the one below). You can <span class='marker'>click on the blocks to edit</span> them and add new blocks by clicking add icon that appears in the left column when hovering over a block.</p>"
    			},{
    				input: 'new Corpus("Hello Spyral!").show();',
    		        output: [
    		                   " <div class=\"info\">This corpus has 1 document with 2 <span class=\"info-tip\" data",
    		                   "-qtip=\"every occurrence of every word (like multiple occurrences of &quot;the&qu",
    		                   "ot;) is counted\">total words</span> and 2 <span class=\"info-tip\" data-qtip=\"mult",
    		                   "iple occurrences of words (like &quot;the&quot;) are counted once\">unique word f",
    		                   "orms</span>. Created <span class=\"info-tip\" data-qtip=\"2016-05-07, 15:51:18\">abo",
    		                   "ut 26 days ago</span>.</div>"
    		        ]
    			}]
    		}
    	}
    	if (Ext.isString(data) || Ext.isArray(data)) {
    		data = {blocks: data}
    	}
    	if (Ext.isObject(data)) {
    		if (!("metadata" in data)) {
    			data.metadata = {
    					created: new Date().getTime() // others will be set later as needed
    			}
    		}
			this.setMetadata(data.metadata);
        	Ext.Array.from(data.blocks).forEach(function(block) {
        		if (block) {
            		if (Ext.isString(block) && block!='') {this.addCode({input: block});}
            		else if (block.input) {
                		if (block.type=='text') {this.addText(block);}
                		else {
                			if (isRun) {block.output="";}
                			this.addCode(block);
                		}
            		}
        		}
        	}, this);
        	if (document.location.hash) { // try to handle anchors in URL
        		setTimeout(function() {
            		var el = document.body.querySelector(location.hash);
            		if (el) {
            			el.scrollIntoView();
            			setTimeout(function() {
                			Ext.get(el.parentElement).frame().frame();
            			}, 200);
            		}
        		}, 200)
        	}
    	} else {
    		this.showError("Unable to load Notebooks data.");
    		console.warn(data);
    	}
    	if (isRun) {
    		this.runAllCode();
    	}
    },
    
    getBlocksFromString: function(string) {
    	if (/^\s*[\[\{]/m.test(string)) {
    		var json = undefined;
    		try {
    			json = jQuery.parseJSON(string);
    		}
    		catch (e) {
    			Ext.create("Voyant.util.DetailedError", {
					msg: this.localize("failedNotebookParse"),
					error: e.message,
					details: e.stack+"\n\n"+this.localize("originalJson")+": "+string
				}).showMsg()
    		}
    		return json;
    	} else {
        	return undefined;
    	}
    },
    
    loadBlocksFromString: function(string, isRun) {
    	if (/^\s*[\[\{]/m.test(string)) {
    		var json = this.getBlocksFromString(string);
    		this.loadData(json, isRun);
    	}
    	else {
    		this.loadData(string, isRun); // treat as single content block
    	}
    },
    
    addText: function(block, order) {
    	return this._add(block, order, 'notebooktexteditorwrapper');
    },
 
    addCode: function(block, order) {
    	return this._add(block, order, 'notebookcodeeditorwrapper');
    },
    
    _add: function(block, order, xtype) {
    	if (Ext.isString(block)) {
    		block = {input: block}
    	}
    	order = (typeof order === 'undefined') ? this.items.getCount() : order;
    	return this.insert(order, Ext.apply(block, {
    		xtype: xtype,
    		order: order,
    		docs: xtype == 'notebookcodeeditorwrapper' ? this.docs: undefined
    	}))
    },
    
    runAllCode: function(upToCmp) {
    	var containers = [];
    	Ext.Array.each(this.query("notebookcodeeditorwrapper"), function(item) {
			containers.push(item);
			item.clearResults();
    		if (upToCmp && upToCmp==item) {return false;}
    	}, this);
    	this._runCodeContainers(containers);
    },
    
    _runCodeContainers: function(containers) {
    	if (containers.length>0) {
        	if (Voyant.application.getDeferredCount()==0) {
        		var container = containers.shift();
        		container.run(true);
        	}
        	Ext.defer(this._runCodeContainers, 100, this, [containers]);
    	}
    },

    getExportHtml: function() {
    	var out = "";
    	this.items.each(function(item, i) {
    		type = item.isXType('notebookcodeeditorwrapper') ? 'code' : 'text';
    		content = item.getContent();
    		out+="<div class='notebook-editor-wrapper "+item.xtype+"'>\n"+
    			"<div class='notebookwrappercounter'><a href='#_"+(i)+"' name='"+i+"'>"+(i+1)+"</a></div>";
    		if (type=='code') {
    			out+="<div class='notebook-code-editor ace-chrome'>\n"+item.getTargetEl().query('.ace_text-layer')[0].outerHTML+"\n</div>\n"+
    				"<div class='notebook-code-results'>\n"+content.output+"\n</div>\n";
    		} else {
    			out+=content+"\n";
    		}
    		out+="</div>\n"
    	})
        var myWindow = window.open();
        myWindow.document.write('<html><head>');
        myWindow.document.write('<title>Spyral Notebooks</title>');
        myWindow.document.write(document.getElementById("ace-chrome").outerHTML);
        myWindow.document.write(document.getElementById("voyant-notebooks-styles").outerHTML);
        myWindow.document.write('</head><body class="exported-notebook">');
        myWindow.document.write(out);
        myWindow.document.write('</body></html>');
        myWindow.document.close();
        myWindow.focus();
    },
    
    getExportAllJson: function() {
    	var blocks = [], maxLen=70, block, type, content, output;
    	this.items.each(function(item) {
    		type = item.isXType('notebookcodeeditorwrapper') ? 'code' : 'text';
    		content = item.getContent();
    		if (type=='code') { 
    			if (/[\r\n]/.test(content.input)) {content.input = content.input.replace(/\r\n?/, "\n").split(/\n/)}
        		block = {
        			type: 'code',
        			input: content.input,
        			mode: content.mode,
        			output: this.wrap(content.output)
        		}
    		} else {
        		block = {
        			type: 'text',
        			input: this.wrap(content)
        		}
    		}
    		blocks.push(block)
    	}, this)
    	
    	var metadata = this.getMetadata();
    	Ext.applyIf(metadata, {
    		created: new Date().getTime(),
    		version: this.getVersion()
    	})
    	Ext.apply(metadata, {
    		modified: new Date().getTime(),
    		url: window.location.href
    	});
    	
    	return {
    		metadata: metadata,
    		blocks: blocks
    	}
    	
    },
    exportAll: function() {

    	var data = this.getExportAllJson();

    	// if we have one code block, just show the code
    	if (data.blocks.length==1 && data.blocks[0].type=='code') {
    		data.blocks = blocks[0].input
    	}
    	
    	Ext.Msg.prompt("Export Notebook", "Currently only copying and pasting the notebook is available. You can select all the contents of the box below and copy to the clipboard.", undefined, undefined, true, JSON && JSON.stringify ? JSON.stringify(data, undefined, 4) : Ext.encode(data))

    },
    
    wrap: function(content) {
    	content = content || "";
    	var maxLen = 80;
    	if (content && content.length>maxLen) {
			var contents = [];
			for (var i=0, len=Math.ceil(content.length/maxLen); i<len; i++) {
				contents.push(content.substr(i*maxLen, maxLen))
			}
			content = contents
    	}
    	return content;
    }
    
    
    
})
Ext.define('Voyant.VoyantApp', {
	
    extend: 'Ext.app.Application',
	mixins: ['Voyant.util.Deferrable','Voyant.util.Localization','Voyant.util.Api','Voyant.util.CategoriesManager'],
	requires: ['Voyant.util.ResponseError'],
    
    name: 'VoyantApp',
    
    statics: {
    	i18n: {
    	},
    	api: {
    		palette: 'default',
    		lang: undefined,
    		debug: undefined
    	}
    },
    
    config: {
    	baseUrl: undefined,
    	tromboneUrl: undefined
    },
    
    constructor: function(config) {
    	this.setBaseUrl(this.config.baseUrl);
    	
    	// set the Trombone URL from the baseURL // TODO: maybe allow this to be overridden
		this.setTromboneUrl(this.config.baseUrl+'trombone');
		
    	// set the application for the Corpus so that we can use a simple constructor
		Voyant.application = this;
		
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		
		this.mixins['Voyant.util.CategoriesManager'].constructor.apply(this, arguments);
		this.addFeature('color');
		this.addFeature('font', '"Palatino Linotype", "Book Antiqua", Palatino, serif');
		
		// call the parent constructor
        this.callParent(arguments);
        
        // palettes
        var cat10 = d3.scaleOrdinal(d3.schemeCategory10).range().map(function(val) { return this.hexToRgb(val); }, this);
        var cat20a = d3.scaleOrdinal(d3.schemeCategory20).range().map(function(val) { return this.hexToRgb(val); }, this);
        var cat20b = d3.scaleOrdinal(d3.schemeCategory20b).range().map(function(val) { return this.hexToRgb(val); }, this);
        var cat20c = d3.scaleOrdinal(d3.schemeCategory20c).range().map(function(val) { return this.hexToRgb(val); }, this);
        this.addColorPalette('d3_cat10', cat10);
        this.addColorPalette('d3_cat20a', cat20a);
        this.addColorPalette('d3_cat20b', cat20b);
        this.addColorPalette('d3_cat20c', cat20c);
        
        var extjs = Ext.create('Ext.chart.theme.Base').getColors().map(function(val) { return this.hexToRgb(val); }, this);
        this.addColorPalette('extjs', extjs);
    },
    
    getBaseUrlFull: function() {
    	return window.location.origin+this.getBaseUrl(); // maybe doesn't work in all browsers?
    },

    getRelativeUrl: function() {
    	var url = window.location.pathname.substring(this.getBaseUrl().length);
    	var relative = "";
    	for (var i=0, len=url.split("/").length-1; i<len; i++) {
    		relative+="../"
    	}
    	return relative;
    },
    
    getTools: function() {
    	return [{type: 'maximize'},{type: 'help'}]
    },
    
    launch: function() {
    	Ext.tip.QuickTipManager.init();
    	Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), {
    	    showDelay: 50 // shorten the delay before showing
    	});
    	
    	// check for categories
    	var queryParams = Ext.Object.fromQueryString(document.location.search);
    	if (queryParams.categories) {
    	    this.loadCategoryData(queryParams.categories).then(function() {
    	        this.setColorTermAssociations();
    	    }, null, null, this);
    	}
    	
		this.callParent(arguments);
    },
    
    tromboneCall: function(config) {
    	var config = config ? config : {};
    	Ext.applyIf(config, {
    		url: this.getTromboneUrl()
    	});
    	if (!config.success && !config.failure && !config.callback) {
        	Ext.applyIf(config, {
        		url: this.getTromboneUrl(),
        	    scope: this,
        	    callback: function(response, success, options) {
        	    	this.dispatchEvent(config.tool+"Loaded", response, success, options)
        	    }
        	});
    	};
    	Ext.Ajax.request(config);
    },
    
    getViewport: function() {
    	return Ext.ComponentQuery.query('viewport')[0];
    },

    dispatchEvent: function(eventName, src) {
    	var viewport = this.getViewport();
		var panels = viewport.query("panel,chart");
		var isHeard = false;

		// tell the app
		if (this.hasListener && this.hasListener(eventName)) {
			this.fireEvent.apply(this, arguments);
			isHeard = true
		}
		
		// tell the panels, except the current one
		for (var i=0; i<panels.length; i++) {
			if (panels[i].hasListener && panels[i].hasListener(eventName)) {
				if (src && src.getId && panels[i].getId && src.getId()==panels[i].getId()) {
					continue; // don't send to self
				}
				isHeard = true;
				panels[i].fireEvent.apply(panels[i], arguments);
			}
		}
		
		if (!isHeard) {
			// let the application know that we have an unhandledEvent
			var args = ["unhandledEvent", src, eventName];
			for (var i=2; i<arguments.length; i++) {args.push(arguments[i])}
			this.fireEvent.apply(this, args);
		}
    },
    
	showResponseError: function(config, response) {
		this.showError(Ext.create("Voyant.util.ResponseError", {msg: (Ext.isString(config) ? config : config.msg), response: response}))
	},
	
	showError: function(config, response) {
		if (config instanceof Voyant.util.ResponseError) {
			config = {
				message: config.getMsg()+"<p class='error'>\n"+config.getError()+"  "+
					"<a href='#' onclick=\"window.open('').document.write(unescape('<pre>"+escape(config.getDetails())+"</pre>')); return false;\">more</a></p>"
			}
		} else {
			if (Ext.isString(config)) {
				config = {message: config}
			} else if (Ext.isObject(config)) {
				if (config.responseText) {
					// rebundle as error (without nice message)
					return this.showResponseError(config.statusText, config);
				} else if (config.statusText) {
					return this.showResponseError(config.statusText, config)
				}
			}
			// maybe handle other forms
		}
		

		Ext.applyIf(config, {
			title: this.localize("error"),
		    buttons: Ext.Msg.OK,
		    icon: Ext.MessageBox.ERROR,
		    autoScroll: true
		})
		Ext.Msg.show(config);
	},
	
	getToolConfigFromToolXtype: function(xtype) {
		cls = Ext.ClassManager.getByAlias("widget."+xtype);		
		return {
			xtype: xtype,
			title: this._localizeClass(cls, "title"),
			tooltip: { // this needs to be an object for compatibility (other configs can be changed)
				text: this._localizeClass(cls, "helpTip")
			},
			glyph: cls && cls.glyph ? cls.glyph : 'xf12e@FontAwesome'
		};
	},
	
	/**
	 * Palettes for use with terms and documents.
	 * @private
	 */
	palettes: {
		'default': [[0, 0, 255], [51, 197, 51], [255, 0, 255], [121, 51, 255], [28, 255, 255], [255, 174, 0], [30, 177, 255], [182, 242, 58], [255, 0, 164], [51, 102, 153], [34, 111, 52], [155, 20, 104], [109, 43, 157], [128, 130, 33], [111, 76, 10], [119, 115, 165], [61, 177, 169], [202, 135, 115], [194, 169, 204], [181, 212, 228], [182, 197, 174], [255, 197, 197], [228, 200, 124], [197, 179, 159]]
	},
	
	rgbToHex: function(a) {
		return "#" + ((1 << 24) + (a[0] << 16) + (a[1] << 8) + a[2]).toString(16).slice(1);
	},
	
	hexToRgb: function(hex) {
	    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
	        return r + r + g + g + b + b;
	    });

	    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	    return result ? [
	        parseInt(result[1], 16),
	        parseInt(result[2], 16),
	        parseInt(result[3], 16)
	    ] : null;
	},
	
	/**
	 * Adds a new palette to the list.
	 * @param key {String} The palette name.
	 * @param values {Array} The array of colors. Format: [[,g,b],[r,g,b],....]
	 */
	addColorPalette: function(key, values) {
		this.palettes[key] = values;
	},
	
	/**
	 * Gets the whole color palette.
	 * @param {String} [key] The key of the palette to return, defaults to the "palette" api param value.
	 * @param {Boolean} [returnHex] True to return a hexadecimal representation of each color (optional, defaults to rgb values).
	 * @return {Array} The color palette.
	 * @private
	 */
	getColorPalette: function(key, returnHex) {
		var paletteKey = key || this.getApiParam('palette') || 'default';
		var palette = this.palettes[paletteKey];
		if (palette === undefined) {
			palette = [];
		}
		if (returnHex) {
			var colors = [];
			for (var i = 0; i < palette.length; i++) {
				colors.push(this.rgbToHex(palette[i]));
			}
			return colors;
		} else {
			return palette;
		}
	},
	
	/**
	 * Gets a particular color from the palette.
	 * @param {Integer} index The index of the color to get.
	 * @param {Boolean} [returnHex] True to return a hexadecimal representation of the color (optional, defaults to rgb values).
	 * @return {Mixed} The requested color, either a hex string or array of rgb values.
	 * @private
	 */
	getColor: function(index, returnHex) {
		var paletteKey = this.getApiParam('palette') || 'default';
		var palette = this.palettes[paletteKey];
		if (index >= palette.length) {
			index = index % palette.length;
		}
		if (returnHex) {
			return this.rgbToHex(palette[index]);
		} else {
			return palette[index];
		}
	},
	
	/**
	 * For tracking associations between a term and a color, to ensure consistent coloring across tools.
	 * @private
	 */
	colorTermAssociations: new Ext.util.MixedCollection(),
	
	/**
	 * Gets the color associated with the term.  Creates a new association if none exists.
	 * @param {String} term The term to get the color for.
	 * @param {Boolean} [returnHex] True to return a hexadecimal representation of the color (optional, defaults to rgb values).
	 * @return {Mixed} The requested color, either a hex string or array of rgb values.
	 * @private
	 */
	getColorForTerm: function(term, returnHex) {
		if (term.indexOf(':') != -1) {
			term = term.split(':')[1];
		}
		var color = this.colorTermAssociations.get(term);
		if (color == null) {
			var paletteKey = this.getApiParam('palette') || 'default';
			var palette = this.palettes[paletteKey];
			
			var index = this.colorTermAssociations.getCount() % palette.length;
			color = palette[index];
			this.colorTermAssociations.add(term, color);
		}
		if (returnHex) {
			color = this.rgbToHex(color);
		}
		return color;
	},
	
	getRgb: function(index, alpha) {
		var color = this.getColor(index);
		 return "rgba("+color[0]+","+color[1]+","+color[2]+","+alpha+")";
	},
	
	getRgbaForTerm: function(term, alpha) {
		 var color = this.getColorForTerm(term);
		 return "rgba("+color[0]+","+color[1]+","+color[2]+","+alpha+")";
	},

	/**
	 * Opens a URL in a new window (handling the case when popup windows aren't allowed).
	 * @param {String} url The URL to open.
	 * @private
	 */
	openUrl: function(url) {
		var win = window.open(url);
		if (!win) { // popup blocked
			Ext.Msg.show({
				title: "Popup Blocked",
				buttonText: {ok: "Close"},
				icon: Ext.MessageBox.INFO,
				message: "A popup window was blocked. <a href='"+url+"' target='_blank' class='link'>Click here</a> to open the new window.",
				buttons: Ext.Msg.OK
			});
		}
	}

    
});
Ext.define('Voyant.VoyantCorpusApp', {
	
    extend: 'Voyant.VoyantApp',
    
    name: 'VoyantCorpusApp',

    requires: ['Voyant.panel.CorpusSet','Voyant.data.model.Corpus','Voyant.panel.VoyantHeader', 'Voyant.panel.VoyantFooter', 'Voyant.panel.CorpusCreator', 'Voyant.panel.Cirrus', 'Voyant.panel.Summary', 'Voyant.panel.DreamScape', 'Voyant.panel.CorpusTerms', 'Voyant.panel.Reader', 'Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts', 'Voyant.panel.DocumentTerms','Voyant.panel.CorpusCollocates','Voyant.panel.CollocatesGraph','Voyant.panel.Phrases','Voyant.panel.ScatterPlot','Voyant.panel.TopicContexts','Voyant.panel.TermsRadio','Voyant.panel.TermsBerry'],
    
    statics: {
    	i18n: {
    	},
    	api: {
    		toolFlow: undefined
    	}
    },
    
	constructor: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
        this.callParent(arguments);
	},
	
    config: {
    	corpus: undefined,
    	corpusAccess: undefined,
    	moreTools: [{
			i18n: 'moreToolsScaleCorpus',
			glyph: 'xf065@FontAwesome',
			items: ['cirrus','corpusterms','bubblelines','correlations','corpuscollocates','dreamscape','loom','mandala','microsearch','streamgraph','phrases','documents','summary','trends','scatterplot','termsradio','topics','veliza','wordtree']
    	},{
			i18n: 'moreToolsScaleDocument',
			glyph: 'xf066@FontAwesome',
			items: ['bubbles','cirrus','contexts','documentterms','reader','textualarc','trends','knots','topics']
    	},{
			i18n: 'moreToolsTypeViz',
			glyph: 'xf06e@FontAwesome',
			items: ['cirrus','bubblelines','bubbles','collocatesgraph','dreamscape','loom','knots','mandala','microsearch','streamgraph','scatterplot','textualarc','trends','termsberry','termsradio','wordtree']
		},{
			i18n: 'moreToolsTypeGrid',
			glyph: 'xf0ce@FontAwesome',
			items: ['corpusterms','corpuscollocates','correlations','phrases','contexts','documentterms','documents','topics']
		},{
			
			i18n: 'moreToolsTypeOther',
			glyph: 'xf035@FontAwesome',
			items: ['reader','summary','veliza']
    	}]
    },
    
    launch: function(config) {
		this.callParent(arguments);

    	if (this.hasQueryToLoad()) {
        	var queryParams = Ext.Object.fromQueryString(document.location.search);
        	if (!queryParams.corpus && this.getCorpusId && this.getCorpusId()) {
        		queryParams.corpus = this.getCorpusId();
        	}
        	if (config && config.useCache) { // for large corpora
        		queryParams.useCache = config.useCache;
        	}
        	this.loadCorpusFromParams(queryParams);
        	
        	if (queryParams.palette) {
        		if (queryParams.palette.indexOf(",")>-1) { // treat as inline
        	    	var palette = Ext.decode(queryParams.palette);
        	    	this.addColorPalette(queryParams.palette, palette);
        		} else {
            		this.loadColorPaletteForCorpus(queryParams.corpus, queryParams.palette);
        		}
        	}
    	} else {
    		var viewport = this.getViewport();
    		if (viewport) {
    			var corpuscreator = viewport.down("corpuscreator")
    			if (corpuscreator) {
    				var toast = corpuscreator.toastInfo({
    					html: this.localize('didYouKnowText'),
    					title: this.localize('didYouKnow'),
    					anchor: corpuscreator.down("textareafield"),
    					align: 'tr',
    					listeners: {
    						beforeclose: {
    							fn: function() {
    								this.getHeader().getTools().forEach(function(tool) {
    									if (tool.type=="gear" || tool.type=='help') {
    										tool.getEl().frame("#ff0000", 1, { duration: 3000 })
    									}
    								});
    							},
    							scope: corpuscreator
    						}
    					}
    				});
    			}
    		}
    	}
    },
    
    loadCorpusFromParams: function(params) {
		var me = this;
		var view = me.getViewport()
		view.mask(this.localize("fetchingCorpus"));
		if (params.archive) { // fix a few URLs we know about
			if (Ext.isString(params.archive)) {params.archive=[params.archive]}
			params.archive = params.archive.map(function(archive) {
				return archive.replace('/blogs.sub.uni-hamburg.de/hup/lhn/', '/wikis.sub.uni-hamburg.de/lhn/index.php/')
					.replace('/hup.sub.uni-hamburg.de/', '/wikis.sub.uni-hamburg.de/')
			})
		}
		
		this.validateCorpusLoadParams(params);

		new Voyant.data.model.Corpus(params).then(function(corpus) {
			view.unmask();
			me.setCorpus(corpus);
			if (me.validateCorpusAccess()) {
				me.dispatchEvent('loadedCorpus', this, corpus);
			}
		}).otherwise(function() {
			view.unmask();
		})
    },
    
    validateCorpusLoadParams: function(params) {
    	// leave untouched by default, this can be overridden
    },
    
    validateCorpusAccess: function() {
		var me = this, view = me.getViewport(), corpus = this.getCorpus();
		if (corpus && corpus.requiresPassword() && !me.getViewport().query("panel").every(function(panel) {
			return !panel.isConsumptive
		})) {
			var noPasswordAccess = corpus.getNoPasswordAccess();
			var passWin = Ext.create('Ext.window.Window', {
	            title: me.localize('passwordRequiredTitle'),
			    layout: 'fit',
			    items: {
			    	padding: 10,
	                flex: 1,
	                width: 300,
	                layout: {
	                    type: 'vbox',
	                    align: 'stretch'
	                },
	                items: [
	                    {
	                        html: '<p>'+me.localize('passwordRequiredMessage')+'</p>' + (noPasswordAccess=='NONCONSUMPTIVE' ? '<p>'+me.localize('nonConsumptiveMessage')+"</p>" : "")+'</p>'
	                    },{
	                    	xtype: 'textfield',
	                    	fieldLabel: me.localize('password')
	                    }
	                ],
	                bbar: {
	//                	ui: 'footer',
	                	layout: {pack: 'center'},
	                	items: [{
	                    	text: me.localize('passwordValidateButton'),
	                    	ui: 'default',
	                    	handler: function() {
	                    		var password = passWin.query("textfield")[0].getValue().trim();
	                    		if (password.length==0) {
	                    			me.showError({
	                    				message: me.localize('noPasswordGiven')
	                    			})
	                    			return;
	                    		}
	                    		passWin.mask();
	                    		Ext.Ajax.request({
	                    			  url: me.getTromboneUrl(),
	                    			  params: {
	                    				  corpus: corpus.getId(),
	                    				  passwordForSession: password
	                    			  },
	                    			  method: 'POST',
	                    			  success: function(result, request) {
	                    				  passWin.unmask();
	                    				  var access = result.responseText;
	                    				  if (access=="ADMIN" || access=="ACCESS") {
			                    			    passWin.close();
			                    			    view.unmask();
			                    			    me.setCorpusAccess(access);
					            				me.dispatchEvent('loadedCorpus', this, corpus);
	                    				  }
	                    				  else {
	  		                    			me.showError({
			                    				message: me.localize('badPassword')
			                    			})
	                    				  }
	                    			  },
	                    			  failure: function(result, request) {
	                    				  passWin.unmask();
	  		                    			me.showError({
			                    				message: me.localize('passwordValidationError')
			                    			})
	                    			  } 
	                    		});
	                    	}
	                    },{
	                    	text: me.localize('nonConsumptiveButton'),
	                    	hidden: corpus.getNoPasswordAccess()=='NONE',
	                    	handler: function() {
	                    		passWin.mask();
	                    		Ext.Ajax.request({
	                    			  url: me.getTromboneUrl(),
	                    			  params: {
	                    				  corpus: corpus.getId(),
	                    				  passwordForSessionRemove: true
	                    			  },
	                    			  method: 'POST',
	                    			  callback: function(result, request) { // do this even if request fails
	                    				  passWin.unmask();
	                    				  passWin.close();
	                    				  view.unmask();
	                    				  me.dispatchEvent('loadedCorpus', me, corpus);
	                    			  }
	                    		});
	                    	}
	                    }]
	                }
	            }
			}).show();
			return false;
		} else {
			return true
		}
    },
    
    hasQueryToLoad: function(params) {
    	if (!params) {
    		params = Ext.Object.fromQueryString(document.location.search);
    	}
    	return params.corpus || params.input || (this.getCorpusId && this.getCorpusId()); // TODO: should this include "archive" from V1?
    },
    
    loadColorPaletteForCorpus: function(corpusId, paletteId) {
		Ext.Ajax.request({
    	    url: this.getTromboneUrl(),
    	    params: {
        		tool: 'resource.StoredResource',
        		retrieveResourceId: paletteId,
    			corpus: corpusId
    	    },
    	    success: function(response, req) {
    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	var value = json.storedResource.resource;
    	    	var palette = Ext.decode(value);
    	    	this.addColorPalette(paletteId, palette);
    	    },
    	    failure: function(response) {
    	    	this.setApiParam('palette', undefined);
    	    },
    	    scope: this
    	});
    },
    
    listeners: {
    	loadedCorpus: function(src, corpus) {
    		this.setCorpus(corpus);
//    		this.colorTermAssociations.clear();
    		
    		this.on("unhandledEvent", function(src, eventName, data) {
				var url = this.getBaseUrl() + '?corpus='+corpus.getAliasOrId();
				var api = this.getModifiedApiParams() || {}; // use application, not tool
				delete api.view; // make sure we show default view
				if (eventName=='termsClicked') {
					api.query=data;
				}
				else if (eventName=='documentsClicked') {
					var docIndex = [];
					if (data.forEach) {
						data.forEach(function(doc) {
							docIndex.push(doc.getIndex())
						})
					}
					api.docIndex=docIndex
				}
				else if (eventName=='corpusTermsClicked') {
					if (data.map) {
						api.query = data.map(function(corpusTerm) {return corpusTerm.getTerm()});
					}
				}
				else if (eventName=='documentTermsClicked') {
					if (data.map) {
						api.query = data.map(function(documentTerm) {return documentTerm.getTerm()});
						api.docIndex = data.map(function(documentTerm) {return documentTerm.getDocIndex()});
					}
				}
				else {
					if (console) {console.warn("Unhandled event: "+eventName, data)}
					return;
				}
				if (api.toolFlow) {
					var toolFlow = Ext.Array.from(api.toolFlow.split(","));
					api.view = toolFlow.shift();
					if (toolFlow.length>0) {
						api.toolFlow = toolFlow.join(",");
					} else {
						delete api.toolFlow
					}
				}
				url += "&"+Ext.Object.toQueryString(api)
				this.openUrl(url)
			})
    	}
    }

});
Ext.define('Voyant.panel.DocumentClusters', {
	extend: 'Ext.panel.Panel',
	alias: 'widget.documentclusters',
	title: "Document Clusters"
})
Ext.define('Voyant.panel.RezoViz', {
	extend: 'Ext.panel.Panel',
	alias: 'widget.rezoviz',
	title: "RezoViz"
})
Ext.define('Voyant.VoyantCorpusToolsetApp', {
	extend : 'Voyant.VoyantCorpusApp',
	requires: ['Voyant.panel.Contexts','Voyant.panel.CollocatesGraph','Voyant.panel.Trends'],
	name : 'VoyantCorpusToolsetApp',
	launch: function() {
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: [{
		        region: 'south',
		        xtype: 'voyantfooter'
		    }, {
         	   xtype: 'tabpanel',
        	   region: 'center',
		    	split: true,
        	   items: [{
        		   xtype: 'cirrus',
                   collapsible: true
        	   },{
        		   xtype: 'corpusterms',
                   collapsible: true
        	   },{
        		   xtype: 'documents',
                   collapsible: true
        	   },{
        		   xtype: 'rezoviz',
                   collapsible: true
        	   },{
        		   xtype: 'trends',
                   collapsible: true
        	   },{
        		   xtype: 'documentclusters',
                   collapsible: true
        	   }],
        	   flex: 6
           }]
		});
        this.callParent(arguments);
	}
});
Ext.define('Voyant.VoyantDefaultApp', {
	extend : 'Voyant.VoyantCorpusApp',
	mixins: ['Voyant.util.Api'],
	name : 'VoyantDefaultApp',
	constructor: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
        this.callParent(arguments);
	},
	statics: {
		i18n: {
		},
		api: {
			view: 'corpusset',
			stopList: 'auto',
			panels: undefined,
			rtl: undefined
		}
	},
	
	listeners: {
    	loadedCorpus: function(src, corpus) {
    		this.viewport.down('voyantheader').collapse();
    		this.viewport.down('#toolsContainer').setActiveItem(1);
    		var corpusId = this.getCorpusId && this.getCorpusId() ? this.getCorpusId() : undefined;
    		if (window.history.pushState && !corpusId) {
    			// add the corpusId to the url
    			var corpusId = corpus.getAliasOrId();
        		var queryParams = Ext.Object.fromQueryString(document.location.search);
        		
    			var url = this.getBaseUrl()+'?corpus='+corpusId;
    			for (var key in queryParams) {
    				if (key !== 'corpus') {
    					var vals = Ext.isString(queryParams[key]) ? [queryParams[key]] : queryParams[key];
    					if (Ext.isArray(vals)) {
    						vals.forEach(function(val) {
    	    					url += '&'+key+'='+val;
    						})
    					}
    				}
    			}
    			window.history.pushState({
    				corpus: corpusId
    			}, 'Corpus: '+corpusId, url);
    		}
    	}
	},
	getViewComponent: function() {
		return this.viewport.down('#toolsContainer-main')
	},
	launch: function() {
		var queryParams = Ext.Object.fromQueryString(document.location.search) || {};
		var view = this.getApiParam('view', 'CorpusSet');
		var xtype = view.toLowerCase();
		if (!Ext.ClassManager.getByAlias("widget."+xtype) || queryParams.noskin) {
			Ext.Msg.show({
			    title: this.localize('noViewErrorTitle'),
			    message: new Ext.Template(this.localize(queryParams.noskin ? 'noViewKnownErrorTpl' : 'noViewErrorTpl')).apply({
			    	view: queryParams.noskin ? queryParams.noskin : view,
			    	additional: queryParams.noskin && queryParams.noskin == 'convert' ? this.localize(queryParams.noskin+'SkinMsg') : ''
			    }),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
			xtype = 'corpusset'; // switch to default view
		}
		var SPLIT_SIZE = 5;
		this.viewport = Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    rtl: (this.getApiParam('rtl')!==undefined || Voyant.util.Localization.LANGUAGE=="ar" || Voyant.util.Localization.LANGUAGE=="he"),
		    items: [{
		    	xtype: 'voyantheader',
		    	region: 'north'
		    },{
		        region: 'south',
		        xtype: 'voyantfooter'
		    },{
		    	region: 'center',
		    	layout: 'card',
		    	itemId: 'toolsContainer',
				activeItem: 0,
				items: [{
					xtype : 'container',
					layout: {
						type: 'vbox',
						pack: 'center',
						align: 'center'
					},
					items: [{
						xtype: 'corpuscreator'
					},{
						xtype: 'container',
						width: 800,
						html: "<div id='voyantIs' style='font-style: italic; text-align: center; margin-top: 10px;'><div>"+this.localize('voyantIs')+"</div>" + (this.localize('translatedBy').indexOf("English") == -1 ? "<div>"+this.localize('translatedBy')+"</div>" : "") +
							(this.getCorpusCreatorText &&  this.getCorpusCreatorText().trim().length>0 ?  "<div id='corpusCreatorText'>"+this.getCorpusCreatorText()+"</div>" : "")
					}]	
				},{
					layout: 'fit',
					itemId: 'toolsContainer-main',
					items: {
						xtype: xtype
					}
				}]
		    }]
		});
		this.callParent(arguments);
	}
});
Ext.define('Voyant.panel.MoreLikeThis', {
	extend: 'Ext.panel.Panel',
	alias: 'widget.morelikethis',
	title: "More Like this"
})
Ext.define('Voyant.VoyantDocumentToolsetApp', {
	extend : 'Voyant.VoyantCorpusApp',
	requires: ['Voyant.panel.Contexts','Voyant.panel.CollocatesGraph','Voyant.panel.Trends'],
	name : 'VoyantDocumentToolsetApp',
	launch: function() {
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: [{
		        region: 'south',
		        xtype: 'voyantfooter'
		    }, {
         	   xtype: 'tabpanel',
        	   region: 'center',
		    	split: true,
        	   items: [{
        		   xtype: 'cirrus',
                   collapsible: true
        	   },{
        		   xtype: 'documentterms',
                   collapsible: true
        	   },{
        		   xtype: 'contexts',
                   collapsible: true
        	   },{
        		   xtype: 'collocatesgraph',
                   collapsible: true
        	   },{
        		   xtype: 'trends',
                   collapsible: true
        	   },{
        		   xtype: 'morelikethis',
                   collapsible: true
        	   }],
        	   flex: 6
           }]
		});
        this.callParent(arguments);
	}
});
Ext.define('Voyant.VoyantNotebookApp', {
	extend : 'Voyant.VoyantApp',
	requires: ['Voyant.panel.VoyantFooter','Voyant.notebook.Notebook','Voyant.data.model.Corpus','Voyant.notebook.util.Show'],
	name : 'VoyantNotebookApp',
	launch: function() {
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: [{
		    	xtype: 'notebook',
		    	region: 'center'
		    },{
		    	xtype: 'voyantfooter',
		    	region: 'south'
		    }]
		});
		this.callParent(arguments);    	
	}
});
Ext.define('Voyant.VoyantToolApp', {
	extend : 'Voyant.VoyantCorpusApp',
	name : 'VoyantToolApp',
	statics: {
		api: {
			minimal: undefined,
			embeddedApiId: undefined
		}
	},
	launch: function() {
		var items = [], me = this;
		if (!this.getApiParam('minimal')) {
			items.push({
		        region: 'south',
		        xtype: 'voyantfooter'
		    })
		};
		items.push({
	        region: 'center',
	        layout: 'fit',
	        itemId: 'toolcontainer',
	        items: {
		        xtype: this.getApiParam('embeddedApiId') ? 'container' : this.getTool()
	        },
	        listeners: {
	        	afterrender: function(container) {
	        		if (me.getApiParam('embeddedApiId')) {
	    				var dfd = me.getDeferred(this);
	    	    		container.mask(this.localize('loadingConfiguration'));
	        	    	Ext.Ajax.request({
	        	    	    url: me.getTromboneUrl(),
	        	    	    params: {
	        	        		tool: 'resource.StoredResource',
	        	        		retrieveResourceId: this.getApiParam('embeddedApiId')
	        	    	    }
	        	    	}).then(function(response) {
	    					dfd.resolve();
	    	    	    	var json = Ext.util.JSON.decode(response.responseText);
	        	    		var configString = decodeURIComponent(json.storedResource.resource);
	        	    		var config = Ext.decode(configString);
	        	    		var tool = Ext.create({xtype: me.getTool()});
	        	    		tool.setApiParams(config);
	        	    		container.unmask();
	        	    		container.remove(container.down('container'));
	        	    		container.add(tool);
	        	    		if (config.corpus) {
	        	    			me.loadCorpusFromParams(config);
	        	    		}
	        	    	}).otherwise(function(response) {
	        	    		if (me.getTargetEl) {
	            				Voyant.notebook.util.Show.TARGET = me.getTargetEl();
	            				showError(response);
	        	    		}
	        	    		Voyant.application.showError(response);
	        	    		dfd.reject();
	        	    	})
	    			}
	        	},
	        	scope: this
	        }
	    });
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: items
		});
		this.callParent(arguments);
	}
});
