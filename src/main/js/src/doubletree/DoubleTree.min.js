/* (This is the new BSD license.)
* Copyright (c) 2012-2014, Chris Culy
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Chris Culy nor the 
*		names of its contributors may be used to endorse or promote 
*		products from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Chris Culy
* ``AS IS'' AND ANY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
* ARE DISCLAIMED. IN NO EVENT SHALL Chris Culy
* BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
* CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
* GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
* CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
* TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/"use strict";

var doubletree = {};

(function() {
  function old_pruneTree(tree, ids) {
    if (!tree.children) {
      return;
    }
    var n = tree.children.length;
    for (var i = 0; i < n; i++) {
      var c = tree.children[i];
      if (containedIn(c.info.ids, ids)) {
        tree.children[i] = null;
      } else {
        old_pruneTree(c, ids);
      }
    }
    tree.children = tree.children.filter(function(c) {
      return c != null;
    });
    var cMax = d3.max(tree.children.map(function(c) {
      return c.maxChildren;
    }));
    tree.maxChildren = Math.max(tree.children.length, cMax);
  }
  function new_pruneTree(tree, ids, copyIDs) {
    if (!tree.children) {
      return;
    }
    if (copyIDs) {
      if (!tree.info.origIDs) {
        tree.info.origIDs = {};
        addTo(tree.info.origIDs, tree.info.ids);
        tree.info.origCount = Object.keys(tree.info.origIDs).length;
      } else {
        tree.info.ids = {};
        addTo(tree.info.ids, tree.info.origIDs);
        tree.info.count = Object.keys(tree.info.ids).length;
      }
    }
    var idNums = Object.keys(ids);
    for (var i = 0, n = idNums.length; i < n; i++) {
      var cid = idNums[i];
      delete tree.info.ids[cid];
    }
    tree.info.count = Object.keys(tree.info.ids).length;
    var n = tree.children.length;
    for (var i = 0; i < n; i++) {
      var c = tree.children[i];
      if (containedIn(c.info.ids, ids)) {
        tree.children[i] = null;
      } else {
        new_pruneTree(c, ids, false);
      }
    }
    tree.children = tree.children.filter(function(c) {
      return c != null;
    });
    tree.info.continuations = tree.children.length;
    var cMax = d3.max(tree.children.map(function(c) {
      return c.maxChildren;
    }));
    tree.maxChildren = Math.max(tree.children.length, cMax);
  }
  function restoreTree(tree) {
    if (tree.info.origCount) {
      tree.info.ids = {};
      addTo(tree.info.ids, tree.info.origIDs);
      tree.info.count = tree.info.origCount;
      var n = tree.children.length;
      tree.info.continuations = n;
      for (var i = 0; i < n; i++) {
        var c = tree.children[i];
        restoreTree(c);
      }
    }
  }
  function overlap(o1, o2) {
    for (var k in o1) {
      if (k in o2) {
        return true;
      }
    }
    return false;
  }
  function containedIn(o1, o2) {
    if (!o1 || !o2) {
      return false;
    }
    for (var k in o1) {
      if (!(k in o2)) {
        return false;
      }
    }
    return true;
  }
  function addTo(o1, o2) {
    for (var k in o2) {
      o1[k] = o2[k];
    }
  }
  function noOp() {}
  doubletree.DoubleTree = function() {
    function mine(selection) {
      selection.each(function(d, i) {
        containers.push(this[i]);
      });
    }
    var containers = [];
    var visWidth = 600;
    var visHt;
    var prefixesOnRight = false;
    var filters = {
      left: [],
      right: []
    };
    var handlers = {
      alt: noOp,
      shift: noOp
    };
    var showTokenExtra = true;
    var scaleLabels = true;
    var sortFun = doubletree.sortByStrFld("token");
    var nodeText = doubletree.tokenText;
    var tokenExtraText = function(info) {
      return doubletree.fieldText(info, "POS");
    };
    var rectColor = function(info) {
      return "rgba(255,255,255,0)";
    };
    var rectBorderColor = function(info) {
      return "rgba(255,255,255,0)";
    };
    var continuationColor = function(info) {
      return "red";
    };
    var basicStyles = {
      node: {
        fill: "white",
        stroke: "steelblue",
        "stroke-width": "1.5px"
      },
      branch: {
        stroke: "#aaa",
        "stroke-width": "1.5px"
      }
    };
    var succeeded = false;
    var dispatch = d3.dispatch("idsUpdated");
    dispatch.on("idsUpdated", function() {
      if (this == leftTree) {
        rtTree.setIds(leftTree.continuationIDs);
        rtTree.updateContinuations();
      } else if (this == rtTree) {
        leftTree.setIds(rtTree.continuationIDs);
        leftTree.updateContinuations();
      }
    });
    var leftTrie, rtTrie, leftTree, rtTree;
    var visibleIDs;
    var kFontSize = 14;
    var kBigFontSize = 1.15 * kFontSize;
    var kMinFontSize = 8;
    var textScale;
    mine.init = function(containerPattern) {
      d3.select(d3.selectAll(containerPattern)).call(this);
      return mine;
    };
    mine.redraw = function() {
      mine.setupFromTries(leftTrie, rtTrie);
      return mine;
    };
    mine.setupFromTries = function(leftOne, rtOne) {
      leftTrie = leftOne.getUniqRoot();
      rtTrie = rtOne.getUniqRoot();
      var leftTrieTree = leftTrie.toTree(filters.left);
      var rtTrieTree = rtTrie.toTree(filters.right);
      var copyIDs = true;
      if (Object.keys(rtTrieTree.pruned).length > 0) {
        new_pruneTree(rtTrieTree, rtTrieTree.pruned, copyIDs);
        new_pruneTree(leftTrieTree, rtTrieTree.pruned, copyIDs);
        copyIDs = false;
      }
      if (Object.keys(leftTrieTree.pruned).length > 0) {
        new_pruneTree(leftTrieTree, leftTrieTree.pruned, copyIDs);
        new_pruneTree(rtTrieTree, leftTrieTree.pruned, copyIDs);
      }
      var newInfo = {};
      for (var k in rtTrieTree.info) {
        if (k != "continuations" && k != "ids" && k != "count") {
          newInfo[k] = rtTrieTree.info[k];
        }
      }
      newInfo["right continuations"] = rtTrieTree.info.continuations;
      newInfo["left continuations"] = leftTrieTree.info.continuations;
      newInfo.ids = {};
      addTo(newInfo.ids, rtTrieTree.info.ids);
      addTo(newInfo.ids, leftTrieTree.info.ids);
      newInfo.count = Object.keys(newInfo.ids).length;
      visibleIDs = Object.keys(newInfo.ids);
      if (rtTrieTree.info.origIDs || leftTrieTree.info.origIDs) {
        newInfo.origIDs = {};
        addTo(newInfo.origIDs, rtTrieTree.info.origIDs);
        addTo(newInfo.origIDs, leftTrieTree.info.origIDs);
        newInfo.origCount = Object.keys(newInfo.origIDs).length;
      }
      rtTrieTree.info = newInfo;
      leftTrieTree.info = newInfo;
      var maxChildren = Math.max(leftTrieTree.maxChildren, rtTrieTree.maxChildren);
      if (isNaN(maxChildren) || maxChildren == 0) {
        succeeded = false;
        return mine;
      }
      if (scaleLabels) {
        textScale = d3.scale.log().range([ kMinFontSize, kFontSize ]);
      } else {
        textScale = function() {
          return kFontSize;
        };
        textScale.domain = function() {};
      }
      visHt = Math.max(200, maxChildren * (kBigFontSize - 2));
      var maxLen = Math.max(leftTrieTree.maxLen, rtTrieTree.maxLen);
      var brLen = Math.max(80, maxLen * .6 * kBigFontSize);
      if (brLen > 200) {
        brLen = 200;
      }
      var minCount = Math.min(leftTrieTree.minCount, rtTrieTree.minCount);
      textScale.domain([ minCount, leftTrieTree.info.count ]);
      var margin = {
        top: 20,
        right: 20,
        bottom: 20,
        left: 20
      }, width = visWidth - margin.right - margin.left, height = visHt - margin.top - margin.bottom;
      containers[0].forEach(function(d, i) {
        function zoomF() {
          if (d3.event.sourceEvent.type !== "mousemove") {
            return;
          }
          d3.select(thisContainer).select("svg > g").attr("transform", "translate(" + d3.event.translate + ")");
        }
        var thisContainer = d;
        var thisVis;
        var tmp = d3.select(thisContainer).select("svg");
        if (tmp[0][0] == null) {
          thisVis = d3.select(thisContainer).append("svg").attr("width", width + margin.right + margin.left).attr("height", height + margin.top + margin.bottom).attr("cursor", "move").call(d3.behavior.zoom().on("zoom", function() {
            if (d3.event.sourceEvent.type !== "mousemove") {
              return;
            }
            d3.select(thisContainer).select("svg > g").attr("transform", "translate(" + d3.event.translate + ")");
          }));
          thisVis.append("g");
        } else {
          thisVis = tmp;
          thisVis.attr("width", width + margin.right + margin.left).attr("height", height + margin.top + margin.bottom);
          thisVis.selectAll("g *").remove();
        }
        leftTree = new doubletree.Tree(thisVis.select("g"), visWidth, visHt, brLen, leftTrieTree, true, sortFun, dispatch, textScale, showTokenExtra, nodeText, tokenExtraText, rectColor, rectBorderColor, continuationColor, basicStyles);
        rtTree = new doubletree.Tree(thisVis.select("g"), visWidth, visHt, brLen, rtTrieTree, false, sortFun, dispatch, textScale, showTokenExtra, nodeText, tokenExtraText, rectColor, rectBorderColor, continuationColor, basicStyles);
      });
      leftTree.handleAltPress = handlers.alt;
      rtTree.handleAltPress = handlers.alt;
      leftTree.handleShiftPress = handlers.shift;
      rtTree.handleShiftPress = handlers.shift;
      succeeded = true;
      return mine;
    };
    mine.setupFromArrays = function(prefixArray, hitArray, suffixArray, idArray, caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray) {
      if (undefined == caseSensitive && leftTrie) {
        caseSensitive = leftTrie.caseSensitive();
      }
      if (undefined == fieldNames && leftTrie) {
        fieldNames = leftTrie.fieldNames();
      }
      if (undefined == fieldDelim && leftTrie) {
        fieldDelim = leftTrie.fieldDelim();
      }
      if (undefined == distinguishingFieldsArray && leftTrie) {
        distinguishingFieldsArray = leftTrie.distinguishingFieldsArray();
      }
      leftTrie = new doubletree.Trie(caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);
      rtTrie = new doubletree.Trie(caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);
      var n = hitArray.length;
      for (var i = 0; i < n; i++) {
        var thisID = idArray ? idArray[i] : i;
        var thisHit = hitArray[i];
        var thesePrefixes = prefixArray[i].slice();
        var theseSuffixes = suffixArray[i].slice();
        thesePrefixes.push(thisHit);
        thesePrefixes.reverse();
        theseSuffixes.unshift(thisHit);
        if (prefixesOnRight) {
          rtTrie.addNgram(thesePrefixes, thisID);
          leftTrie.addNgram(theseSuffixes, thisID);
        } else {
          leftTrie.addNgram(thesePrefixes, thisID);
          rtTrie.addNgram(theseSuffixes, thisID);
        }
      }
      mine.setupFromTries(leftTrie, rtTrie);
      return mine;
    };
    mine.filteredIDs = function() {
      return visibleIDs;
    };
    mine.search = function(searchRE) {
      leftTree.search(searchRE);
      rtTree.search(searchRE);
      var thisVis = d3.select(containers[0][0]);
      var found = thisVis.selectAll("text.foundText");
      if (found.empty()) {
        return 0;
      }
      var what = found[0].length;
      var foundRt = thisVis.selectAll("text.rtNdText.foundText");
      if (foundRt[0][0] != null) {
        what--;
      }
      return what;
    };
    mine.clearSearch = function() {
      leftTree.clearSearch();
      rtTree.clearSearch();
      return mine;
    };
    mine.updateTokenExtras = function() {
      leftTree.showTokenExtras(showTokenExtra);
      rtTree.showTokenExtras(showTokenExtra);
      var thisVis = d3.select(containers[0][0]);
      var tokExtra = thisVis.select('.tokenExtra[display="inline"]');
      if (!tokExtra.empty()) {
        var ht = tokExtra.style("height");
        if (ht == "0px") {
          mine.redraw();
        }
      }
      return mine;
    };
    mine.visWidth = function(value) {
      if (!arguments.length) return visWidth;
      visWidth = value;
      return mine;
    };
    mine.prefixesOnRight = function(value) {
      if (!arguments.length) return prefixesOnRight;
      prefixesOnRight = value;
      return mine;
    };
    mine.filters = function(value) {
      if (!arguments.length) return filters;
      filters = value;
      return mine;
    };
    mine.handlers = function(value) {
      if (!arguments.length) return handlers;
      handlers = value;
      return mine;
    };
    mine.showTokenExtra = function(value) {
      if (!arguments.length) return showTokenExtra;
      showTokenExtra = value;
      return mine;
    };
    mine.scaleLabels = function(value) {
      if (!arguments.length) return scaleLabels;
      scaleLabels = value;
      return mine;
    };
    mine.succeeded = function() {
      return succeeded;
    };
    mine.sortFun = function(value) {
      if (!arguments.length) return sortFun;
      sortFun = value;
      return mine;
    };
    mine.nodeText = function(value) {
      if (!arguments.length) return nodeText;
      nodeText = value;
      return mine;
    };
    mine.tokenExtraText = function(value) {
      if (!arguments.length) return tokenExtraText;
      tokenExtraText = value;
      return mine;
    };
    mine.rectColor = function(value) {
      if (!arguments.length) return rectColor;
      rectColor = value;
      return mine;
    };
    mine.rectBorderColor = function(value) {
      if (!arguments.length) return rectBorderColor;
      rectBorderColor = value;
      return mine;
    };
    mine.continuationColor = function(value) {
      if (!arguments.length) return continuationColor;
      continuationColor = value;
      return mine;
    };
    mine.basicStyles = function(stylesObj) {
      if (!arguments.length) return basicStyles;
      Object.keys(basicStyles).forEach(function(aspect) {
        if (aspect in stylesObj) {
          Object.keys(basicStyles[aspect]).forEach(function(attr) {
            if (attr in stylesObj[aspect]) {
              basicStyles[aspect][attr] = stylesObj[aspect][attr];
            }
          });
        }
      });
      return mine;
    };
    return mine;
  };
  doubletree.Tree = function(vis, visWidth, visHt, branchW, data, toLeft, sortFun, dispatch, textScale, showTokenXtra, nodeTextFun, tokenExtraTextFun, rectColorFun, rectBorderFun, contColorFun, baseStyles) {
    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }
    function collapseSiblings(nd) {
      if (nd.parent) {
        nd.parent.children.forEach(function(d) {
          if (d != nd) {
            collapse(d);
          }
        });
      }
    }
    function click(d, i) {
      if (d3.event.altKey) {
        that.handleAltPress(d, i);
        return;
      }
      if (d3.event.shiftKey) {
        that.handleShiftPress(d, i);
        return;
      }
      if (!d.parent) {
        return;
      }
      if (that.continuationIDs != d.info.ids) {
        that.setIds(d.info.ids);
        that.clickedNode = d.id;
        dispatch.idsUpdated.apply(that);
      }
      collapseSiblings(d);
      toggleChildren(d, true);
    }
    function toggleChildren(d, update) {
      if (d.children) {
        if (d.children && d.children.length == 1) {
          toggleChildren(d.children[0], true);
        }
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
        if (d.children && d.children.length == 1) {
          toggleChildren(d.children[0], false);
        }
      }
      if (update) {
        that.update(d);
      }
    }
    function positionX(x) {
      return toLeft ? width / 2 - x : width / 2 + x;
    }
    function positionY(y) {
      return y - dx;
    }
    var branchWidth = branchW;
    var showTokenExtra = false || showTokenXtra;
    var continuationIDs = {};
    var clickedNode;
    var nodeText = nodeTextFun;
    var tokenExtraText = tokenExtraTextFun;
    var rectColor = rectColorFun;
    var rectBorderColor = rectBorderFun;
    var continuationColor = contColorFun;
    var basicStyles = baseStyles;
    var margin = {
      top: 20,
      right: 20,
      bottom: 20,
      left: 20
    }, width = visWidth - margin.right - margin.left, height = visHt - margin.top - margin.bottom, i = 0, duration = 200, root;
    var dx;
    if (!sortFun) {
      sortFun = doubletree.sortByStrFld("token");
    }
    var tree = d3.layout.tree().size([ height, width ]).sort(sortFun);
    var diagonal = d3.svg.diagonal().projection(function(d) {
      return [ positionX(d.y), positionY(d.x) ];
    });
    vis = vis.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    this.readJSONTree = function(json) {
      root = json;
      root.x0 = height / 2;
      root.y0 = width / 2;
      root.children.forEach(collapse);
      this.update(root);
    };
    var that = this;
    this.update = function(source) {
      if (!source) {
        source = root;
      }
      var nodes = tree.nodes(root).reverse();
      dx = root.x - height / 2;
      nodes.forEach(function(d) {
        d.y = d.depth * branchWidth;
      });
      var node = vis.selectAll("g.node_" + toLeft).data(nodes, function(d) {
        return d.id || (d.id = ++i);
      });
      var nodeEnter = node.enter().append("g").attr("class", "node node_" + toLeft).attr("transform", function(d) {
        return "translate(" + positionX(source.y0) + "," + positionY(source.x0) + ")";
      }).on("click", click);
      nodeEnter.append("title").text(function(d) {
        var what = doubletree.infoToText(d.info);
        return what;
      });
      nodeEnter.append("circle").attr("r", 1e-6).style("fill", function(d) {
        return d._children ? "#fff" : basicStyles.node.fill;
      }).style("stroke", function(d) {
        return basicStyles.node.stroke;
      });
      var txtNode = nodeEnter.append("text").attr("class", function(d) {
        if (d.depth == 0) {
          return "rtNdText";
        } else {
          return "";
        }
      }).attr("x", function(d) {
        if (d.children || d._children) {
          return 0;
        } else {
          return toLeft ? 10 : -10;
        }
      }).attr("text-anchor", function(d) {
        if (!d.parent) {
          return "middle";
        }
        if (d.children || d._children) {
          return toLeft ? "end" : "start";
        } else {
          return toLeft ? "start" : "end";
        }
      }).style("font-size", function(d) {
        return textScale(d.info.count) + "pt";
      });
      txtNode.append("tspan").attr("dy", ".35em").attr("class", "tokenText").text(function(d) {
        return nodeText(d.info, d.depth < 1);
      }).style("fill-opacity", 1e-6);
      txtNode.append("tspan").attr("dx", ".35em").attr("class", "tokenExtra").text(function(d) {
        return tokenExtraText(d.info, d.depth < 1);
      }).style("fill-opacity", 1e-6);
      this.drawRects = function() {
        var which = showTokenExtra ? "inline" : "none";
        vis.selectAll(".tokenExtra").attr("display", which);
        node.selectAll("rect").remove();
        var nodeRect = node.append("rect").attr("class", "nodeRect").attr("height", function() {
          return this.parentElement.getBBox().height - 6;
        }).attr("y", function(d) {
          if (!d.parent) {
            return -.5 * this.parentElement.getBBox().height / 2 - 2;
          } else {
            return -.5 * this.parentElement.getBBox().height / 2;
          }
        }).attr("width", function() {
          return this.parentElement.getBBox().width;
        }).attr("x", function(d) {
          var parentW = this.parentElement.getBBox().width;
          if (!d.parent) {
            return -.33333 * parentW;
          }
          if (!toLeft) {
            return 0;
          }
          return -.5 * parentW;
        }).style("stroke-opacity", 1).style("stroke-width", 1).style("stroke", function(d) {
          return rectBorderColor(d.info);
        }).style("fill", function(d) {
          return rectColor(d.info);
        }).style("fill-opacity", function(d) {
          if (!d.parent && !toLeft) {
            return 1e-6;
          } else {
            return 1;
          }
        });
      };
      try {
        this.drawRects();
      } catch (e) {}
      var nodeUpdate = node.transition().duration(duration).attr("transform", function(d) {
        return "translate(" + positionX(d.y) + "," + positionY(d.x) + ")";
      });
      nodeUpdate.select("circle").attr("r", function(d) {
        return d.children || d._children ? 1e-6 : 4.5;
      }).style("fill", function(d) {
        return d._children ? "#fff" : basicStyles.node.fill;
      }).style("stroke-width", basicStyles.node["stroke-width"]);
      nodeUpdate.select("text").attr("class", function(d) {
        var isContinuation = containedIn(that.continuationIDs, d.info.ids);
        if (isContinuation || !d.parent) {
          classListAdd(this, "continuation");
        } else {
          classListRemove(this, "continuation");
        }
        return classListToString(this);
      }).style("fill-opacity", 1).style("fill", function(d) {
        if (classListContains(this, "continuation")) {
          return continuationColor(d.info);
        }
        return "#444";
      });
      nodeUpdate.selectAll("tspan").style("fill-opacity", 1);
      var nodeExit = node.exit().transition().duration(duration).attr("transform", function(d) {
        return "translate(" + positionX(source.y) + "," + positionY(source.x) + ")";
      }).remove();
      nodeExit.select("circle").attr("r", 1e-6);
      nodeExit.selectAll("tspan").style("fill-opacity", 1e-6);
      var link = vis.selectAll("path.link_" + toLeft).data(tree.links(nodes), function(d) {
        return d.target.id;
      });
      link.enter().insert("path", "g").attr("class", "link link_" + toLeft).attr("d", function(d) {
        var o = {
          x: source.x0,
          y: source.y0
        };
        return diagonal({
          source: o,
          target: o
        });
      }).style("fill", "none").style("stroke", basicStyles.branch.stroke).style("stroke-width", basicStyles.branch["stroke-width"]);
      link.transition().duration(duration).attr("d", diagonal);
      link.exit().transition().duration(duration).attr("d", function(d) {
        var o = {
          x: source.x,
          y: source.y
        };
        return diagonal({
          source: o,
          target: o
        });
      }).remove();
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    };
    this.setIds = function(ids) {
      that.continuationIDs = ids;
    };
    this.updateContinuations = function() {
      vis.selectAll("g.node_" + toLeft + " text").classed("continuation", function(d) {
        var isContinuation = overlap(d.info.ids, that.continuationIDs);
        if (isContinuation) {
          classListAdd(this, "continuation");
        } else {
          classListRemove(this, "continuation");
        }
        return isContinuation;
      }).style("fill", function(d) {
        if (classListContains(this, "continuation")) {
          return continuationColor(d.info);
        }
        return "#444";
      });
    };
    this.search = function(searchRE) {
      vis.selectAll("g.node text").attr("class", function(d) {
        var what = searchRE.test(nodeText(d.info));
        if (what) {
          classListAdd(this, "foundText");
        } else {
          classListRemove(this, "foundText");
        }
        return classListToString(this);
      });
    };
    this.clearSearch = function() {
      vis.selectAll("g.node text").attr("class", function(d) {
        classListRemove(this, "foundText");
        return classListToString(this);
      });
    };
    this.showTokenExtras = function(show) {
      if (arguments.length == 0) {
        return showTokenExtra;
      }
      showTokenExtra = show;
      this.drawRects();
      return this;
    };
    this.setRectColor = function(rectColorFun) {
      if (arguments.length == 0) {
        return rectColor;
      }
      rectColor = rectColorFun;
      this.drawRects();
      return this;
    };
    this.handleAltPress = function() {};
    this.handleShifttPress = function() {};
    this.readJSONTree(data);
    return this;
  };
  doubletree.sortByStrFld = function(fld) {
    var field = fld;
    return function(a, b) {
      var aUndefined = undefined == a.info[field];
      var bUndefined = undefined == b.info[field];
      if (aUndefined && bUndefined) {
        return 0;
      } else if (aUndefined) {
        return -1;
      } else if (bUndefined) {
        return 1;
      }
      var aVal = a.info[field].join(" ").toLowerCase();
      var bVal = b.info[field].join(" ").toLowerCase();
      if (aVal < bVal) {
        return -1;
      } else if (aVal > bVal) {
        return 1;
      }
      return 0;
    };
  };
  doubletree.sortByCount = function() {
    return function(a, b) {
      return b.info.count - a.info.count;
    };
  };
  doubletree.sortByContinuations = function() {
    return function(a, b) {
      return b.info.continuations - a.info.continuations;
    };
  };
  doubletree.filterByMinCount = function(n) {
    return function(inf) {
      return inf.count >= n;
    };
  };
  doubletree.filterByMaxCount = function(n) {
    return function(inf) {
      return inf.count <= n;
    };
  };
  doubletree.filterByPOS = function(pos) {
    var re = new RegExp(pos);
    return function(inf) {
      return inf["POS"] && inf["POS"].filter(function(p) {
        return p.search(re) > -1;
      }).length > 0;
    };
  };
  doubletree.fieldText = function(info, fieldName) {
    return info[fieldName];
  };
  doubletree.tokenText = function(info) {
    return doubletree.fieldText(info, "token");
  };
  doubletree.infoToText = function(info) {
    var what = "";
    for (var infp in info) {
      if (infp == "ids" || infp == "origIDs") {
        what += infp + "	:	" + Object.keys(info[infp]).join(",") + "\n";
      } else {
        what += infp + "	:	" + info[infp] + "\n";
      }
    }
    return what;
  };
})();